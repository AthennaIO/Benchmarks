"use strict";
/*
 * @adonisjs/fold
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.IocProxyClass = exports.IocProxyObject = void 0;
function getBindingValue(handler) {
    return handler.options.has(handler.namespace)
        ? handler.options.resolve(handler.namespace, handler.value)
        : handler.value;
}
/**
 * Proxy handler to handle objects
 */
const objectHandler = (options) => {
    return {
        get(_, key, receiver) {
            const descriptor = Object.getOwnPropertyDescriptor(options.value, key);
            /**
             * Handling the proxy invariants use case. Learn more
             *
             * https://262.ecma-international.org/8.0/#sec-proxy-object-internal-methods-and-internal-slots-get-p-receiver
             *
             * Check the following "get" trap
             * https://github.com/kpruden/on-change/blob/5b80da1f5f7ac80c37d7bd19122188acb7ad0b19/index.js#L44-L66
             */
            if (descriptor && !descriptor.configurable) {
                if (descriptor.set && !descriptor.get) {
                    return undefined;
                }
                if (descriptor.writable === false) {
                    return Reflect.get(options.value, key, receiver);
                }
            }
            return Reflect.get(getBindingValue(options), key, receiver);
        },
        apply(_, thisArgument, args) {
            return Reflect.apply(getBindingValue(options), thisArgument, args);
        },
        defineProperty(_, propertyKey, attributes) {
            return Reflect.defineProperty(getBindingValue(options), propertyKey, attributes);
        },
        deleteProperty(_, propertyKey) {
            return Reflect.deleteProperty(getBindingValue(options), propertyKey);
        },
        getOwnPropertyDescriptor(_, propertyKey) {
            return Reflect.getOwnPropertyDescriptor(getBindingValue(options), propertyKey);
        },
        getPrototypeOf(_) {
            return Reflect.getPrototypeOf(getBindingValue(options));
        },
        has(_, propertyKey) {
            return Reflect.has(getBindingValue(options), propertyKey);
        },
        isExtensible(_) {
            return Reflect.isExtensible(getBindingValue(options));
        },
        ownKeys(_) {
            return Reflect.ownKeys(getBindingValue(options));
        },
        preventExtensions() {
            throw new Error('Cannot prevent extensions during a fake');
        },
        set(_, propertyKey, value, receiver) {
            return Reflect.set(getBindingValue(options), propertyKey, value, receiver);
        },
        setPrototypeOf(_, proto) {
            return Reflect.setPrototypeOf(getBindingValue(options), proto);
        },
    };
};
/**
 * Proxy handler to handle classes and functions
 */
const classHandler = (options) => {
    return Object.assign({}, objectHandler(options), {
        construct(_, args, newTarget) {
            return Reflect.construct(getBindingValue(options), args, newTarget);
        },
    });
};
/**
 * Proxies the objects to fallback to fake, when it exists.
 */
class IocProxyObject {
    constructor(namespace, value, options) {
        this.namespace = namespace;
        this.value = value;
        this.options = options;
        return new Proxy(value, objectHandler({ namespace, value, options }));
    }
}
exports.IocProxyObject = IocProxyObject;
/**
 * Proxies the class constructor to fallback to fake, when it exists.
 */
function IocProxyClass(namespace, value, options) {
    return new Proxy(value, classHandler({ namespace, value, options }));
}
exports.IocProxyClass = IocProxyClass;
