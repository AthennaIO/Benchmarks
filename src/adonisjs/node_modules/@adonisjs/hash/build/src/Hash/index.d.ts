/// <reference path="../../adonis-typings/hash.d.ts" />
import { Manager } from '@poppinss/manager';
import { ApplicationContract } from '@ioc:Adonis/Core/Application';
import { HashConfig, HashContract, HashDriverContract, HashersList } from '@ioc:Adonis/Core/Hash';
/**
 * The Hash module exposes the API to hash values using an underlying
 * Hash driver.
 */
export declare class Hash<Config extends HashConfig> extends Manager<ApplicationContract, HashDriverContract, HashDriverContract, {
    [P in keyof HashersList]: HashersList[P]['implementation'];
}> implements HashContract {
    config: Config;
    /**
     * Reference to fake driver. Created when `Hash.fake` is called
     */
    private fakeDriver;
    protected singleton: boolean;
    /**
     * A boolean to know, if hash module is running in fake
     * mode or not
     */
    get isFaked(): boolean;
    constructor(application: ApplicationContract, config: Config);
    /**
     * Validate config
     */
    private validateConfig;
    /**
     * Pulling the default driver name from the user config.
     */
    protected getDefaultMappingName(): never;
    /**
     * Returns the config for a mapping
     */
    protected getMappingConfig(name: keyof HashersList): never;
    /**
     * Returns the driver name for a mapping
     */
    protected getMappingDriver(name: keyof HashersList): string | undefined;
    /**
     * Creating bcrypt driver. The manager will call this method anytime
     * someone will ask for the `bcrypt` driver.
     */
    protected createBcrypt(_: string, config: any): any;
    /**
     * Creating argon driver. The manager will call this method anytime
     * someone will ask for the `argon` driver.
     */
    protected createArgon2(_: string, config: any): any;
    /**
     * Creating fake driver. The manager will call this method anytime
     * someone will ask for the `fake` driver.
     */
    protected createFake(): any;
    /**
     * Initiate faking hash calls. All methods invoked on the main hash
     * module and the underlying drivers will be faked using the
     * fake driver.
     *
     * To restore the fake. Run the `Hash.restore` method.
     */
    fake(): void;
    /**
     * Restore fake
     */
    restore(): void;
    /**
     * Hash value using the default driver
     */
    make(value: string): any;
    /**
     * Verify value using the default driver
     */
    verify(hashedValue: string, plainValue: string): any;
    /**
     * Find if value needs to be re-hashed as per the default driver.
     */
    needsReHash(hashedValue: string): any;
    /**
     * Pull pre-configured driver instance
     */
    use<K extends keyof HashersList>(name?: K): ReturnType<HashContract['use']>;
}
