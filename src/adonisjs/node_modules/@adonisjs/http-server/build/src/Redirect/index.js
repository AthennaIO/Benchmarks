"use strict";
/**
 * @adonisjs/http-server
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Redirect = void 0;
/// <reference path="../../adonis-typings/index.ts" />
const qs_1 = __importDefault(require("qs"));
const url_1 = require("url");
const encodeurl_1 = __importDefault(require("encodeurl"));
/**
 * Exposes the API to construct redirect routes
 */
class Redirect {
    constructor(request, response, router) {
        this.request = request;
        this.response = response;
        this.router = router;
        /**
         * A boolean to forward the existing query string
         */
        this.forwardQueryString = false;
        /**
         * The status code for the redirect
         */
        this.statusCode = 302;
        /**
         * A custom query string to forward
         */
        this.queryString = {};
    }
    /**
     * Sends response by setting require headers
     */
    sendResponse(url, query) {
        const stringified = qs_1.default.stringify(query);
        url = stringified ? `${url}?${stringified}` : url;
        this.response.location((0, encodeurl_1.default)(url));
        this.response.safeStatus(this.statusCode);
        this.response.type('text/plain; charset=utf-8');
        this.response.send(`Redirecting to ${url}`);
    }
    /**
     * Returns the referrer url
     */
    getReferrerUrl() {
        let url = this.request.headers['referer'] || this.request.headers['referrer'] || '/';
        return Array.isArray(url) ? url[0] : url;
    }
    /**
     * Set a custom status code.
     */
    status(statusCode) {
        this.statusCode = statusCode;
        return this;
    }
    /**
     * Clearing query string values added using the
     * "withQs" method
     */
    clearQs() {
        this.forwardQueryString = false;
        this.queryString = {};
        return this;
    }
    withQs(name, value) {
        if (typeof name === 'undefined') {
            this.forwardQueryString = true;
            return this;
        }
        if (typeof name === 'string') {
            this.queryString[name] = value;
            return this;
        }
        Object.assign(this.queryString, name);
        return this;
    }
    /**
     * Redirect to the previous path.
     */
    back() {
        let query = {};
        const url = (0, url_1.parse)(this.getReferrerUrl());
        /**
         * Parse query string from the referrer url
         */
        if (this.forwardQueryString) {
            query = qs_1.default.parse(url.query || '');
        }
        /**
         * Append custom query string
         */
        Object.assign(query, this.queryString);
        /**
         * Redirect
         */
        this.sendResponse(url.pathname || '', query);
    }
    /**
     * Redirect the request using a route identifier.
     */
    toRoute(routeIdentifier, params, options) {
        if (options && options.qs) {
            this.withQs(options.qs);
            options.qs = undefined;
        }
        const url = this.router.makeUrl(routeIdentifier, params, options);
        return this.toPath(url);
    }
    /**
     * Redirect the request using a path.
     */
    toPath(url) {
        let query = {};
        /**
         * Extract query string from the current URL
         */
        if (this.forwardQueryString) {
            query = qs_1.default.parse((0, url_1.parse)(this.request.url).query || '');
        }
        /**
         * Assign custom query string
         */
        Object.assign(query, this.queryString);
        /**
         * Redirect
         */
        this.sendResponse(url, query);
    }
}
exports.Redirect = Redirect;
