import { ApplicationContract } from '@ioc:Adonis/Core/Application';
import { ManifestLoader } from '../Manifest/Loader';
import { CommandFlag, KernelContract, CommandContract, ManifestCommand, RunHookCallback, FindHookCallback, GlobalFlagHandler, CommandConstructorContract } from '../Contracts';
/**
 * Ace kernel class is used to register, find and invoke commands by
 * parsing `process.argv.splice(2)` value.
 */
export declare class Kernel implements KernelContract {
    application: ApplicationContract;
    /**
     * Reference to hooks class to execute lifecycle
     * hooks
     */
    private hooks;
    /**
     * Reference to the manifest loader. If defined, we will give preference
     * to the manifest files.
     */
    private manifestLoader;
    /**
     * The command that started the process
     */
    private entryCommand?;
    /**
     * The state of the kernel
     */
    private state;
    /**
     * Exit handler for gracefully exiting the process
     */
    private exitHandler;
    /**
     * Find if CLI process is interactive. This flag can be
     * toggled programmatically
     */
    isInteractive: boolean;
    /**
     * Find if console output is mocked
     */
    isMockingConsoleOutput: boolean;
    /**
     * The default command that will be invoked when no command is
     * defined
     */
    defaultCommand: CommandConstructorContract;
    /**
     * List of registered commands
     */
    commands: {
        [name: string]: CommandConstructorContract;
    };
    aliases: {
        [alias: string]: string;
    };
    /**
     * List of registered flags
     */
    flags: {
        [name: string]: CommandFlag & {
            handler: GlobalFlagHandler;
        };
    };
    /**
     * The exit code for the process
     */
    exitCode?: number;
    /**
     * The error collected as part of the running commands or executing
     * flags
     */
    error?: any;
    constructor(application: ApplicationContract);
    /**
     * Executing global flag handlers. The global flag handlers are
     * not async as of now, but later we can look into making them
     * async.
     */
    private executeGlobalFlagsHandlers;
    /**
     * Returns an array of all registered commands
     */
    private getAllCommandsAndAliases;
    /**
     * Processes the args and sets values on the command instance
     */
    private processCommandArgsAndFlags;
    /**
     * Execute the main command. For calling commands within commands,
     * one must call "kernel.exec".
     */
    private execMain;
    /**
     * Handles exiting the process
     */
    private exitProcess;
    /**
     * Register a before hook
     */
    before(action: 'run', callback: RunHookCallback): this;
    before(action: 'find', callback: FindHookCallback): this;
    /**
     * Register an after hook
     */
    after(action: 'run', callback: RunHookCallback): this;
    after(action: 'find', callback: FindHookCallback): this;
    /**
     * Register an array of command constructors
     */
    register(commands: CommandConstructorContract[]): this;
    /**
     * Register a global flag. It can be defined in combination with
     * any command.
     */
    flag(name: string, handler: GlobalFlagHandler, options: Partial<Exclude<CommandFlag, 'name' | 'propertyName'>>): this;
    /**
     * Use manifest instance to lazy load commands
     */
    useManifest(manifestLoader: ManifestLoader): this;
    /**
     * Register an exit handler
     */
    onExit(callback: (kernel: this) => void | Promise<void>): this;
    /**
     * Returns an array of command names suggestions for a given name.
     */
    getSuggestions(name: string, distance?: number): string[];
    /**
     * Preload the manifest file. Re-running this method twice will
     * result in a noop
     */
    preloadManifest(): Promise<void>;
    /**
     * Finds the command from the command line argv array. If command for
     * the given name doesn't exists, then it will return `null`.
     *
     * Does executes the before and after hooks regardless of whether the
     * command has been found or not
     */
    find(argv: string[]): Promise<CommandConstructorContract | null>;
    /**
     * Run the default command. The default command doesn't accept
     * and args or flags.
     */
    runDefaultCommand(): Promise<any>;
    /**
     * Find if a command is the main command. Main commands are executed
     * directly from the terminal.
     */
    isMain(command: CommandContract): boolean;
    /**
     * Enforce mocking the console output. Command logs, tables, prompts
     * will be mocked
     */
    mockConsoleOutput(): this;
    /**
     * Toggle interactive state
     */
    interactive(state: boolean): this;
    /**
     * Execute a command as a sub-command. Do not call "handle" and
     * always use this method to invoke command programatically
     */
    exec(commandName: string, args: string[]): Promise<CommandContract>;
    /**
     * Makes instance of a given command by processing command line arguments
     * and setting them on the command instance
     */
    handle(argv: string[]): Promise<void>;
    /**
     * Print the help screen for a given command or all commands/flags
     */
    printHelp(command?: CommandConstructorContract, commandsToAppend?: ManifestCommand[], aliasesToAppend?: Record<string, string>): void;
    /**
     * Trigger kernel to exit the process. The call to this method
     * is ignored when command is not same the `entryCommand`.
     *
     * In other words, subcommands cannot trigger exit
     */
    exit(command: CommandContract, error?: any): Promise<void>;
}
