import { ParsedOptions } from 'getopts';
import { Prompt, FakePrompt } from '@poppinss/prompts';
import { instantiate } from '@poppinss/cliui/build/api';
import { ApplicationContract } from '@ioc:Adonis/Core/Application';
import { CommandArg, CommandFlag, KernelContract, CommandSettings, CommandContract, GeneratorContract } from '../Contracts';
/**
 * Abstract base class other classes must extend
 */
export declare abstract class BaseCommand implements CommandContract {
    application: ApplicationContract;
    kernel: KernelContract;
    /**
     * Reference to the exit handler
     */
    protected exitHandler?: () => void | Promise<void>;
    /**
     * Accepting AdonisJs application instance and kernel instance
     */
    constructor(application: ApplicationContract, kernel: KernelContract);
    /**
     * Is the current command the main command executed from the
     * CLI
     */
    get isMain(): boolean;
    /**
     * Terminal is interactive
     */
    get isInteractive(): boolean;
    /**
     * Command arguments
     */
    static args: CommandArg[];
    /**
     * Command aliases
     */
    static aliases: string[];
    /**
     * Command flags
     */
    static flags: CommandFlag[];
    /**
     * Command name. The command will be registered using this name only. Make
     * sure their aren't any spaces inside the command name.
     */
    static commandName: string;
    /**
     * The description of the command displayed on the help screen.
     * A good command will always have some description.
     */
    static description: string;
    /**
     * Any settings a command wants to have. Helpful for third party
     * tools to read the settings in lifecycle hooks and make
     * certain decisions
     */
    static settings: CommandSettings;
    /**
     * Whether or not the command has been booted
     */
    static booted: boolean;
    /**
     * Boots the command by defining required static properties
     */
    static boot(): void;
    /**
     * Define an argument directly on the command without using the decorator
     */
    static $addArgument(options: Partial<CommandArg>): void;
    /**
     * Define a flag directly on the command without using the decorator
     */
    static $addFlag(options: Partial<CommandFlag>): void;
    /**
     * Reference to cli ui
     */
    ui: {
        table: () => import("@poppinss/cliui/build/src/Table").Table;
        tasks: {
            (): import("@poppinss/cliui/build/src/Task/Manager").TaskManager;
            verbose(): import("@poppinss/cliui/build/src/Task/Manager").TaskManager;
        };
        icons: {
            tick: string;
            cross: string;
            bullet: string;
            nodejs: string;
            pointer: string;
            info: string;
            warning: string;
            squareSmallFilled: string;
        };
        logger: import("@poppinss/cliui/build/src/Logger").Logger;
        sticker: () => import("@poppinss/cliui/build/src/Instructions").Instructions;
        instructions: () => import("@poppinss/cliui/build/src/Instructions").Instructions;
        isInteractive: boolean;
        supportsColors: boolean;
        consoleRenderer: import("@poppinss/cliui/build/src/Renderer/Console").ConsoleRenderer;
        testingRenderer: import("@poppinss/cliui/build/src/Renderer/Memory").MemoryRenderer;
    };
    /**
     * Parsed options on the command. They only exist when the command
     * is executed via kernel.
     */
    parsed?: ParsedOptions;
    /**
     * The prompt for the command
     */
    prompt: Prompt | FakePrompt;
    /**
     * Returns the instance of logger to log messages
     */
    logger: import("@poppinss/cliui/build/src/Logger").Logger;
    /**
     * Reference to the colors
     */
    colors: ReturnType<typeof instantiate>['logger']['colors'];
    /**
     * Generator instance to generate entity files
     */
    generator: GeneratorContract;
    /**
     * Error raised by the command
     */
    error?: any;
    /**
     * Command exit code
     */
    exitCode?: number;
    run?(...args: any[]): Promise<any>;
    prepare?(...args: any[]): Promise<any>;
    completed?(...args: any[]): Promise<any>;
    /**
     * Execute the command
     */
    exec(): Promise<any>;
    /**
     * Register an onExit handler
     */
    onExit(handler: () => void | Promise<void>): this;
    /**
     * Trigger exit
     */
    exit(): Promise<void>;
    /**
     * Must be defined by the parent class
     */
    handle?(...args: any[]): Promise<any>;
}
