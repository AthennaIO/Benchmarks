"use strict";
/*
 * @adonisjs/ace
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManifestGenerator = void 0;
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const utils_1 = require("@poppinss/utils");
const helpers_1 = require("@poppinss/utils/build/helpers");
const validateCommand_1 = require("../utils/validateCommand");
/**
 * Exposes the API to generate the ace manifest file. The manifest file
 * contains the meta data of all the registered commands. This speeds
 * up the boot cycle of ace
 */
class ManifestGenerator {
    constructor(basePath, commands) {
        this.basePath = basePath;
        this.commands = commands;
        /**
         * Here we keep track of processed command files to prevent loops. Mainly when using
         * listDirectoryFiles to export command paths from directory and not excluding current file.
         */
        this.processedFiles = new Set();
    }
    /**
     * Loads a given command from the disk. A command line can recursively
     * exposed sub command paths. But they should be resolvable using
     * the base path
     */
    async loadCommand(commandPath) {
        if ((0, path_1.isAbsolute)(commandPath)) {
            throw new utils_1.Exception('Absolute path to a command is not allowed when generating the manifest file');
        }
        const resolvedPath = (0, helpers_1.resolveFrom)(this.basePath, commandPath);
        if (this.processedFiles.has(resolvedPath)) {
            return [];
        }
        const commandOrSubCommandsPaths = (0, utils_1.esmRequire)(resolvedPath);
        this.processedFiles.add(resolvedPath);
        if (Array.isArray(commandOrSubCommandsPaths)) {
            return this.loadCommands(commandOrSubCommandsPaths);
        }
        /**
         * File export has command constructor
         */
        (0, validateCommand_1.validateCommand)(commandOrSubCommandsPaths, commandPath);
        return [
            {
                command: commandOrSubCommandsPaths,
                commandPath,
            },
        ];
    }
    /**
     * Loads all the commands from the disk recursively.
     */
    async loadCommands(commandPaths) {
        let commands = [];
        for (const commandPath of commandPaths) {
            const command = await this.loadCommand(commandPath);
            commands = commands.concat(command);
        }
        return commands;
    }
    /**
     * Generates and writes the ace manifest file to the base path
     */
    async generate() {
        const commands = await this.loadCommands(this.commands);
        const manifest = commands.reduce((result, { command, commandPath }) => {
            const manifestNode = {
                settings: command.settings || {},
                commandPath: commandPath.replace(new RegExp(`${(0, path_1.extname)(commandPath)}$`), ''),
                commandName: command.commandName,
                description: command.description,
                args: command.args,
                aliases: command.aliases,
                flags: command.flags,
            };
            result.commands[command.commandName] = manifestNode;
            command.aliases.forEach((alias) => {
                result.aliases[alias] = command.commandName;
            });
            return result;
        }, { commands: {}, aliases: {} });
        await (0, fs_extra_1.outputJSON)((0, path_1.join)(this.basePath, 'ace-manifest.json'), manifest, { spaces: 2 });
    }
}
exports.ManifestGenerator = ManifestGenerator;
