"use strict";
/*
 * @adonisjs/ace
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManifestLoader = void 0;
const fs_extra_1 = require("fs-extra");
const utils_1 = require("@poppinss/utils");
const helpers_1 = require("@poppinss/utils/build/helpers");
const validateCommand_1 = require("../utils/validateCommand");
/**
 * The manifest loader exposes the API to load ace commands from one
 * or more manifest files.
 */
class ManifestLoader {
    constructor(files) {
        this.files = files;
        /**
         * An array of defined manifest files
         */
        this.manifestFiles = [];
        this.booted = false;
    }
    /**
     * Loads the manifest file from the disk
     */
    async loadManifestFile(file) {
        const manifestCommands = await (0, fs_extra_1.readJSON)(file.manifestAbsPath);
        /**
         * Find if we are dealing with an old or the new manifest file
         */
        const isNewManifestFile = manifestCommands['commands'] && manifestCommands['aliases'];
        const commands = isNewManifestFile ? manifestCommands['commands'] : manifestCommands;
        const aliases = isNewManifestFile ? manifestCommands['aliases'] : {};
        return { basePath: file.basePath, commands, aliases };
    }
    /**
     * Returns the command manifest node for a give command
     */
    getCommandManifest(commandName) {
        return this.manifestFiles.find(({ commands, aliases }) => {
            const aliasCommandName = aliases[commandName];
            return commands[commandName] || commands[aliasCommandName];
        });
    }
    /**
     * Boot manifest loader to read all manifest files from the disk
     */
    async boot() {
        if (this.booted) {
            return;
        }
        this.booted = true;
        this.manifestFiles = await Promise.all(this.files.map((file) => this.loadManifestFile(file)));
    }
    /**
     * Returns base path for a given command
     */
    getCommandBasePath(commandName) {
        return this.getCommandManifest(commandName)?.basePath;
    }
    /**
     * Returns manifest command node. One must load the command
     * in order to use it
     */
    getCommand(commandName) {
        const manifestCommands = this.getCommandManifest(commandName);
        if (!manifestCommands) {
            return;
        }
        const aliasCommandName = manifestCommands.aliases[commandName];
        const command = manifestCommands.commands[commandName] || manifestCommands.commands[aliasCommandName];
        return {
            basePath: manifestCommands.basePath,
            command: command,
        };
    }
    /**
     * Find if a command exists or not
     */
    hasCommand(commandName) {
        return !!this.getCommandBasePath(commandName);
    }
    /**
     * Load command from the disk. Make sure to use [[hasCommand]] before
     * calling this method
     */
    async loadCommand(commandName) {
        const { basePath, command } = this.getCommand(commandName);
        const commandConstructor = (0, utils_1.esmRequire)((0, helpers_1.resolveFrom)(basePath, command.commandPath));
        (0, validateCommand_1.validateCommand)(commandConstructor);
        return commandConstructor;
    }
    /**
     * Returns an array of manifest commands
     */
    getCommands() {
        return this.manifestFiles.reduce((result, { commands, aliases }) => {
            Object.keys(commands).forEach((commandName) => {
                result.commands = result.commands.concat(commands[commandName]);
            });
            Object.assign(result.aliases, aliases);
            return result;
        }, { commands: [], aliases: {} });
    }
}
exports.ManifestLoader = ManifestLoader;
