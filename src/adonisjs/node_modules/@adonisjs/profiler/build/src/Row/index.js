"use strict";
/*
 * @adonisjs/profiler
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProfilerRow = void 0;
/// <reference path="../../adonis-typings/profiler.ts" />
const helpers_1 = require("@poppinss/utils/build/helpers");
const utils_1 = require("@poppinss/utils");
const Action_1 = require("../Action");
const DummyProfiler_1 = require("../DummyProfiler");
const AbstractProfiler_1 = require("../Profiler/AbstractProfiler");
/**
 * Profiler row class is used to group profiling actions together. Any
 * number of nested rows can be created.
 */
class ProfilerRow extends AbstractProfiler_1.AbstractProfiler {
    constructor(label, manager, data, parentId) {
        super();
        this.label = label;
        this.manager = manager;
        this.data = data;
        this.parentId = parentId;
        this.id = (0, helpers_1.cuid)();
        this.timestamp = Date.now();
        this.start = process.hrtime();
        this.ended = false;
    }
    /**
     * Makes the log packet for the log row
     */
    makeLogPacket() {
        return {
            id: this.id,
            type: 'row',
            label: this.label,
            parent_id: this.parentId,
            timestamp: this.timestamp,
            data: this.data || {},
            duration: process.hrtime(this.start),
        };
    }
    /**
     * Returns the action instance to be used by the [[AbstractProfiler]] class
     */
    getAction(action, data) {
        if (this.ended) {
            throw new utils_1.Exception('cannot profile after parent row has been ended');
        }
        return this.manager.isEnabled(action)
            ? new Action_1.ProfilerAction(action, this.manager.processor, this.id, data)
            : DummyProfiler_1.dummyAction;
    }
    /**
     * Returns a boolean telling if a parent exists
     */
    get hasParent() {
        return !!this.parentId;
    }
    /**
     * End the profiler instance by emitting end packet. After
     * this all profiling calls will be considered overflows
     */
    end(data) {
        /**
         * Raise error when end has been called already
         */
        if (this.ended) {
            throw new utils_1.Exception('attempt to end profiler row twice');
        }
        /**
         * Setting end to true to avoid multiple calls
         */
        this.ended = true;
        /**
         * Merge data
         */
        if (data) {
            this.data = Object.assign({}, this.data, data);
        }
        /**
         * Invoke processor
         */
        this.manager.processor(this.makeLogPacket());
    }
    /**
     * Get a new child logger. Child logger will emit a new row
     * in the events timeline
     */
    create(label, data) {
        if (this.manager.isEnabled(label)) {
            return new ProfilerRow(label, this.manager, data, this.id);
        }
        return DummyProfiler_1.dummyRow;
    }
}
exports.ProfilerRow = ProfilerRow;
