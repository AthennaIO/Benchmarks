/// <reference path="../../adonis-typings/profiler.d.ts" />
import { LoggerContract } from '@ioc:Adonis/Core/Logger';
import { AbstractProfiler } from './AbstractProfiler';
import { ProfilerConfig, ProfilerContract, ProfilerProcessor, ProfilerRowContract, ProfilerActionContract } from '@ioc:Adonis/Core/Profiler';
/**
 * Profiler exposes the public interface to create new profiling
 * rows and actions. In case of blacklisted actions, dummy
 * implementations are returned, resulting in noop.
 */
export declare class Profiler extends AbstractProfiler implements ProfilerContract {
    private appRoot;
    private logger;
    private worker?;
    /**
     * Subscribe to listen for events
     */
    processor?: Exclude<ProfilerProcessor, string>;
    /**
     * Profiler config
     */
    private config;
    constructor(appRoot: string, logger: LoggerContract, config: Partial<ProfilerConfig>);
    /**
     * Returns the action to be used for timing functions
     */
    protected getAction(action: string, data?: any): ProfilerActionContract;
    /**
     * Returns a boolean telling if profiler is enabled for
     * a given `action` or `label` or not?
     */
    isEnabled(labelOrAction: string): boolean;
    /**
     * Creates a new profiler row for a given action. If action is not enabled
     * then a copy of [[this.dummyRow]] is returned, which has the same
     * public API with all actions to a noop.
     */
    create(label: string, data?: any): ProfilerRowContract;
    /**
     * Close the worker and cleanup memory
     */
    cleanup(): void;
    /**
     * Define subscriber for the profiler. Only one subscriber can be defined
     * at max. Redifying the subscriber will override the existing subscriber
     */
    process(fn: ProfilerProcessor): void;
}
