/// <reference path="../../adonis-typings/index.d.ts" />
/// <reference types="node" />
import { DriveManagerContract } from '@ioc:Adonis/Core/Drive';
import { MultipartStream, FileValidationOptions } from '@ioc:Adonis/Core/BodyParser';
import { File } from './File';
/**
 * Part handler handles the progress of a stream and also internally validates
 * it's size and extension.
 *
 * This class offloads the task of validating a file stream, regardless of how
 * the stream is consumed. For example:
 *
 * In classic scanerio, we will process the file stream and write files to the
 * tmp directory and in more advanced cases, the end user can handle the
 * stream by themselves and report each chunk to this class.
 */
export declare class PartHandler {
    private part;
    private options;
    private drive;
    /**
     * The stream buffer reported by the stream consumer. We hold the buffer until are
     * able to detect the file extension and then buff memory is released
     */
    private buff?;
    /**
     * A boolean to know if we can use the magic number to detect the file type. This is how it
     * works.
     *
     * - We begin by extracting the file extension from the file name
     * - If the file has no extension, we try to inspect the buffer
     * - If the extension is something we support via magic numbers, then we ignore the extension
     * 	 and inspect the buffer
     * - Otherwise, we have no other option than to trust the extension
     *
     * Think of this as using the optimal way for validating the file type
     */
    private get canFileTypeBeDetected();
    /**
     * Creating a new file object for each part inside the multipart
     * form data
     */
    file: File;
    /**
     * A boolean to know, if we have emitted the error event after one or
     * more validation errors. We need this flag, since the race conditions
     * between `data` and `error` events will trigger multiple `error`
     * emit.
     */
    private emittedValidationError;
    constructor(part: MultipartStream, options: Partial<FileValidationOptions & {
        deferValidations: boolean;
    }>, drive: DriveManagerContract);
    /**
     * Detects the file type and extension and also validates it when validations
     * are not deferred.
     */
    private detectFileTypeAndExtension;
    /**
     * Skip the stream or end it forcefully. This is invoked when the
     * streaming consumer reports an error
     */
    private skipEndStream;
    /**
     * Finish the process of listening for any more events and mark the
     * file state as consumed.
     */
    private finish;
    /**
     * Start the process the updating the file state
     * to streaming mode.
     */
    begin(): void;
    /**
     * Handles the file upload progress by validating the file size and
     * extension.
     */
    reportProgress(line: Buffer, bufferLength: number): Promise<void>;
    /**
     * Report errors encountered while processing the stream. These can be errors
     * apart from the one reported by this class. For example: The `s3` failure
     * due to some bad credentails.
     */
    reportError(error: any): Promise<void>;
    /**
     * Report success data about the file.
     */
    reportSuccess(data?: {
        filePath?: string;
        tmpPath?: string;
    } & {
        [key: string]: any;
    }): Promise<void>;
}
