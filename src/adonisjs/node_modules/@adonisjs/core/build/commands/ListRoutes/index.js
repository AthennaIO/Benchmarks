"use strict";
/*
 * @adonisjs/core
 *
 * (c) AdonisJS
 *
 * For the full copyright and license information, please view the LICENSE.md
 * file that was distributed with this source code.
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const ace_1 = require("@adonisjs/ace");
const TableRenderer_1 = require("./Renderers/TableRenderer");
const PrettyRenderer_1 = require("./Renderers/PrettyRenderer");
/**
 * A command to display a list of routes
 */
class ListRoutes extends ace_1.BaseCommand {
    /**
     * Returns the display handler name
     */
    getHandlerName(route) {
        const resolvedHandler = route.meta.resolvedHandler;
        if (resolvedHandler.type === 'function') {
            return 'Closure';
        }
        const defaultControllersNamespace = this.application.namespacesMap.get('httpControllers');
        return `${resolvedHandler.namespace.replace(new RegExp(`^${defaultControllersNamespace}\/`), '')}.${resolvedHandler.method}`;
    }
    /**
     * Apply the method filter on the route
     */
    hasPassedMethodFilter(route) {
        if (!this.methodsFilter || !this.methodsFilter.length) {
            return true;
        }
        return !!this.methodsFilter.find((filter) => route.methods.includes(filter.toUpperCase()));
    }
    /**
     * Apply the pattern filter on the route
     */
    hasPassedPatternFilter(route) {
        if (!this.patternsFilter || !this.patternsFilter.length) {
            return true;
        }
        return !!this.patternsFilter.find((filter) => route.pattern.includes(filter));
    }
    /**
     * Apply the name filter on the route
     */
    hasPassedNameFilter(route) {
        if (!this.namesFilter || !this.namesFilter.length) {
            return true;
        }
        return !!this.namesFilter.find((filter) => route.name.includes(filter));
    }
    /**
     * Log message
     */
    log(message) {
        if (this.application.environment === 'test') {
            this.logger.log(message);
        }
        else {
            console.log(message);
        }
    }
    /**
     * Serialize route to JSON
     */
    serializeRoute(route, domain) {
        return {
            domain,
            name: route.name || '',
            pattern: route.pattern,
            methods: route.methods,
            handler: this.getHandlerName(route),
            middleware: route.middleware.map((one) => (typeof one === 'function' ? 'Closure' : one)),
        };
    }
    /**
     * Returns an array of routes as JSON, filtered according to the
     * flags passed to the command
     */
    serializeRoutes() {
        const Router = this.application.container.use('Adonis/Core/Route');
        Router.commit();
        const routes = Router.toJSON();
        return Object.keys(routes).reduce((result, domain) => {
            const domainRoutes = routes[domain]
                .map((route) => this.serializeRoute(route, domain))
                .filter((route) => {
                return (this.hasPassedMethodFilter(route) &&
                    this.hasPassedNameFilter(route) &&
                    this.hasPassedPatternFilter(route));
            });
            if (this.reverse) {
                domainRoutes.reverse();
            }
            result[domain] = domainRoutes;
            return result;
        }, {});
    }
    async run() {
        if (this.json) {
            this.log(JSON.stringify(this.serializeRoutes(), null, 2));
        }
        else if (this.table) {
            new TableRenderer_1.RoutesTableRenderer(this).render();
        }
        else {
            new PrettyRenderer_1.RoutesPrettyRenderer(this).render();
        }
        await this.application.shutdown();
    }
}
ListRoutes.commandName = 'list:routes';
ListRoutes.description = 'List application routes';
/**
 * Load application
 */
ListRoutes.settings = {
    loadApp: true,
    stayAlive: true,
};
__decorate([
    ace_1.flags.boolean({ name: 'verbose', description: 'Display more information' }),
    __metadata("design:type", Boolean)
], ListRoutes.prototype, "verbose", void 0);
__decorate([
    ace_1.flags.boolean({ alias: 'r', name: 'reverse', description: 'Reverse routes display' }),
    __metadata("design:type", Boolean)
], ListRoutes.prototype, "reverse", void 0);
__decorate([
    ace_1.flags.array({ alias: 'm', name: 'methods', description: 'Filter routes by method' }),
    __metadata("design:type", Array)
], ListRoutes.prototype, "methodsFilter", void 0);
__decorate([
    ace_1.flags.array({ alias: 'p', name: 'patterns', description: 'Filter routes by the route pattern' }),
    __metadata("design:type", Array)
], ListRoutes.prototype, "patternsFilter", void 0);
__decorate([
    ace_1.flags.array({ alias: 'n', name: 'names', description: 'Filter routes by route name' }),
    __metadata("design:type", Array)
], ListRoutes.prototype, "namesFilter", void 0);
__decorate([
    ace_1.flags.boolean({ description: 'Output as JSON' }),
    __metadata("design:type", Boolean)
], ListRoutes.prototype, "json", void 0);
__decorate([
    ace_1.flags.boolean({ description: 'Output as Table' }),
    __metadata("design:type", Boolean)
], ListRoutes.prototype, "table", void 0);
__decorate([
    ace_1.flags.number({ description: 'Specify maximum rendering width. Ignored for JSON Output' }),
    __metadata("design:type", Number)
], ListRoutes.prototype, "maxWidth", void 0);
exports.default = ListRoutes;
