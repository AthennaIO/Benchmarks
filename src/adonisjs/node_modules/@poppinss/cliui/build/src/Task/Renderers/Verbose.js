"use strict";
/*
 * @poppinss/cliui
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.VerboseRenderer = void 0;
const Logger_1 = require("../../Logger");
const Console_1 = require("../../Renderer/Console");
/**
 * Verbose renderer shows a detailed output of the tasks and the
 * messages logged by a given task
 */
class VerboseRenderer {
    constructor(options, testing = false) {
        this.options = options;
        this.testing = testing;
    }
    /**
     * Returns the renderer for rendering the messages
     */
    getRenderer() {
        if (!this.renderer) {
            this.renderer = new Console_1.ConsoleRenderer();
        }
        return this.renderer;
    }
    /**
     * Prefixes pipe to a line of text
     */
    prefixPipe(text) {
        return text
            .split('\n')
            .map((line) => `${this.logger.colors.dim('│')}  ${line}`)
            .join('\n');
    }
    /**
     * Instantiates the logger and defines a custom renderer
     * to log messages in context with the currently running
     * task
     */
    instantiateLogger() {
        this.logger = new Logger_1.Logger({ ...this.options, dim: true }, this.testing);
        this.logger.useRenderer({
            log: (message) => this.getRenderer().log(this.prefixPipe(message)),
            logError: (message) => this.getRenderer().logError(this.prefixPipe(message)),
            logUpdate: (message) => this.getRenderer().logUpdate(this.prefixPipe(message)),
            logUpdateDone: () => this.getRenderer().logUpdateDone(),
        });
    }
    /**
     * Logs message based upon the state of the task
     */
    updateTask(task) {
        /**
         * Task started running
         */
        if (task.state === 'running') {
            this.getRenderer().log(`${this.logger.colors.dim('┌')} ${task.title}`);
            return;
        }
        const pipe = this.logger.colors.dim('└');
        const duration = this.logger.colors.dim(`(${task.duration})`);
        /**
         * Task failed
         */
        if (task.state === 'failed') {
            task.completionMessage && this.logger.fatal(task.completionMessage);
            this.getRenderer().logError(`${pipe} ${this.logger.colors.red('failed')} ${duration}`);
            return;
        }
        /**
         * Task succeeded
         */
        if (task.state === 'succeeded') {
            task.completionMessage && this.logger.colors.green(task.completionMessage);
            this.getRenderer().log(`${pipe} ${this.logger.colors.green('completed')} ${duration}`);
            return;
        }
    }
    /**
     * Define a custom renderer. Logs to "stdout" and "stderr"
     * by default
     */
    useRenderer(renderer) {
        this.renderer = renderer;
        return this;
    }
    /**
     * Register tasks to render
     */
    tasks(tasks) {
        this.registeredTasks = tasks;
        return this;
    }
    /**
     * Render all tasks
     */
    render() {
        this.instantiateLogger();
        this.registeredTasks.forEach((task) => task.onUpdate(($task) => this.updateTask($task)));
    }
}
exports.VerboseRenderer = VerboseRenderer;
