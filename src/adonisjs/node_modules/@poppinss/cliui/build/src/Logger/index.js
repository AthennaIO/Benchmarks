"use strict";
/*
 * @poppinss/clui
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = void 0;
const Action_1 = require("./Action");
const Colors_1 = require("../Colors");
const Spinner_1 = require("./Spinner");
const Console_1 = require("../Renderer/Console");
/**
 * Default config options
 */
const DEFAULTS = {
    dim: false,
    dimLabels: false,
    colors: true,
    labelColors: true,
    interactive: true,
};
/**
 * Logger exposes the API to log messages with consistent styles
 * and colors
 */
class Logger {
    constructor(options, testing = false) {
        this.testing = testing;
        this.options = { ...DEFAULTS, ...options };
        this.colors = (0, Colors_1.getBest)(this.testing, this.options.colors);
        this.labelColors = (0, Colors_1.getBest)(this.testing, this.options.labelColors && this.options.colors);
    }
    /**
     * Colors the logger label
     */
    colorizeLabel(color, text) {
        if (this.options.dim || this.options.dimLabels) {
            return `[ ${this.labelColors.dim()[color](text)} ]`;
        }
        return `[ ${this.labelColors[color](text)} ]`;
    }
    /**
     * Returns the label for a given logging type
     */
    getLabel(type) {
        switch (type) {
            case 'success':
                return this.colorizeLabel('green', 'success');
            case 'error':
            case 'fatal':
                return this.colorizeLabel('red', type);
            case 'warning':
                return this.colorizeLabel('yellow', 'warn');
            case 'info':
                return this.colorizeLabel('blue', 'info');
            case 'debug':
                return this.colorizeLabel('cyan', 'debug');
            case 'await':
                return this.colorizeLabel('cyan', 'wait');
        }
    }
    /**
     * Appends the suffix to the message
     */
    addSuffix(message, suffix) {
        if (!suffix) {
            return message;
        }
        return `${message} ${this.colors.dim().yellow(`(${suffix})`)}`;
    }
    /**
     * Prepends the prefix to the message. We do not DIM the prefix, since
     * gray doesn't have much brightness already
     */
    addPrefix(message, prefix) {
        if (!prefix) {
            return message;
        }
        prefix = prefix.replace(/%time%/, new Date().toISOString());
        return `${this.colors.dim(`[${prefix}]`)} ${message}`;
    }
    /**
     * Prepends the prefix to the message
     */
    prefixLabel(message, label) {
        return `${label}  ${message}`;
    }
    /**
     * Decorate message string
     */
    decorateMessage(message) {
        if (this.options.dim) {
            return this.colors.dim(message);
        }
        return message;
    }
    /**
     * Decorate message string
     */
    formatStack(stack) {
        if (!stack) {
            return '';
        }
        return `\n${stack
            .split('\n')
            .splice(1)
            .map((line) => {
            return `${this.colors.dim(line)}`;
        })
            .join('\n')}`;
    }
    /**
     * Returns the renderer for rendering the messages
     */
    getRenderer() {
        if (!this.renderer) {
            this.renderer = new Console_1.ConsoleRenderer();
        }
        return this.renderer;
    }
    /**
     * Define a custom renderer. Logs to "stdout" and "stderr"
     * by default
     */
    useRenderer(renderer) {
        this.renderer = renderer;
        return this;
    }
    /**
     * Log message using the renderer. It is similar to `console.log`
     * but uses the underlying renderer instead
     */
    log(message) {
        this.getRenderer().log(message);
    }
    /**
     * Log message by overwriting the existing one
     */
    logUpdate(message) {
        this.getRenderer().logUpdate(message);
    }
    /**
     * Persist the message logged using [[this.logUpdate]]
     */
    logUpdatePersist() {
        this.getRenderer().logUpdateDone();
    }
    /**
     * Log error message using the renderer. It is similar to `console.error`
     * but uses the underlying renderer instead
     */
    logError(message) {
        this.getRenderer().logError(message);
    }
    /**
     * Log success message
     */
    success(message, prefix, suffix) {
        message = this.decorateMessage(message);
        message = this.prefixLabel(message, this.getLabel('success'));
        message = this.addPrefix(message, prefix);
        message = this.addSuffix(message, suffix);
        this.log(message);
    }
    /**
     * Log error message
     */
    error(message, prefix, suffix) {
        message = typeof message === 'string' ? message : message.message;
        message = this.decorateMessage(message);
        message = this.prefixLabel(message, this.getLabel('error'));
        message = this.addPrefix(message, prefix);
        message = this.addSuffix(message, suffix);
        this.logError(message);
    }
    /**
     * Log fatal message
     */
    fatal(message, prefix, suffix) {
        const stack = this.formatStack(typeof message === 'string' ? undefined : message.stack);
        message = typeof message === 'string' ? message : message.message;
        message = this.decorateMessage(message);
        message = this.prefixLabel(message, this.getLabel('error'));
        message = this.addPrefix(message, prefix);
        message = this.addSuffix(message, suffix);
        this.logError(`${message}${stack}`);
    }
    /**
     * Log warning message
     */
    warning(message, prefix, suffix) {
        message = this.decorateMessage(message);
        message = this.prefixLabel(message, this.getLabel('warning'));
        message = this.addPrefix(message, prefix);
        message = this.addSuffix(message, suffix);
        this.log(message);
    }
    /**
     * Log info message
     */
    info(message, prefix, suffix) {
        message = this.decorateMessage(message);
        message = this.prefixLabel(message, this.getLabel('info'));
        message = this.addPrefix(message, prefix);
        message = this.addSuffix(message, suffix);
        this.log(message);
    }
    /**
     * Log debug message
     */
    debug(message, prefix, suffix) {
        message = this.decorateMessage(message);
        message = this.prefixLabel(message, this.getLabel('debug'));
        message = this.addPrefix(message, prefix);
        message = this.addSuffix(message, suffix);
        this.log(message);
    }
    /**
     * Log a message with a spinner
     */
    await(message, prefix, suffix) {
        const messageBuilder = {
            prefix: prefix,
            suffix: suffix,
            logger: this,
            render(text) {
                text = this.logger.decorateMessage(text);
                text = this.logger.prefixLabel(text, this.logger.getLabel('await'));
                text = this.logger.addPrefix(text, this.prefix);
                text = this.logger.addSuffix(text, this.suffix);
                return text;
            },
        };
        return new Spinner_1.Spinner(message, this, this.testing).useMessageBuilder(messageBuilder).start();
    }
    /**
     * Initiates a new action
     */
    action(title) {
        return new Action_1.Action(title, this);
    }
}
exports.Logger = Logger;
