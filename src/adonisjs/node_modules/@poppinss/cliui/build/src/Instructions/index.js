"use strict";
/*
 * @poppinss/cliui
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Instructions = void 0;
const cli_boxes_1 = __importDefault(require("cli-boxes"));
const string_width_1 = __importDefault(require("string-width"));
const Icons_1 = require("../Icons");
const Colors_1 = require("../Colors");
const Console_1 = require("../Renderer/Console");
/**
 * The box styling used by the instructions
 */
const BOX = cli_boxes_1.default.round;
/**
 * Default config options
 */
const DEFAULTS = {
    icons: true,
    colors: true,
};
/**
 * The API to render instructions wrapped inside a box
 */
class Instructions {
    constructor(options, testing = false) {
        this.testing = testing;
        this.state = {
            content: [],
        };
        /**
         * Line of the widest line inside instructions content
         */
        this.widestLineLength = 0;
        /**
         * Number of white spaces on the left of the box
         */
        this.leftPadding = 4;
        /**
         * Number of white spaces on the right of the box
         */
        this.rightPadding = 8;
        /**
         * Number of empty lines at the top
         */
        this.paddingTop = 1;
        /**
         * Number of empty lines at the bottom
         */
        this.paddingBottom = 1;
        this.options = { ...DEFAULTS, ...options };
        this.colors = (0, Colors_1.getBest)(this.testing, this.options.colors);
    }
    /**
     * Returns the renderer for rendering the messages
     */
    getRenderer() {
        if (!this.renderer) {
            this.renderer = new Console_1.ConsoleRenderer();
        }
        return this.renderer;
    }
    /**
     * Repeats text for given number of times
     */
    repeat(text, times) {
        return new Array(times + 1).join(text);
    }
    /**
     * Adds dim transformation
     */
    dim(text) {
        return this.colors.dim(text);
    }
    /**
     * Wraps content inside the left and right vertical lines
     */
    wrapInVerticalLines(content, leftWhitespace, rightWhitespace) {
        return `${this.dim(BOX.left)}${leftWhitespace}${content}${rightWhitespace}${this.dim(BOX.right)}`;
    }
    /**
     * Returns the top line for the box
     */
    getTopLine() {
        const horizontalLength = this.widestLineLength + this.leftPadding + this.rightPadding;
        const horizontalLine = this.repeat(this.dim(BOX.top), horizontalLength);
        return `${this.dim(BOX.topLeft)}${horizontalLine}${this.dim(BOX.topRight)}`;
    }
    /**
     * Returns the bottom line for the box
     */
    getBottomLine() {
        const horizontalLength = this.widestLineLength + this.leftPadding + this.rightPadding;
        const horizontalLine = this.repeat(this.dim(BOX.bottom), horizontalLength);
        return `${this.dim(BOX.bottomLeft)}${horizontalLine}${this.dim(BOX.bottomRight)}`;
    }
    /**
     * Decorates the instruction line by wrapping it inside the box
     * lines
     */
    getContentLine(line) {
        const rightWhitespace = this.repeat(' ', this.widestLineLength - line.width + this.rightPadding);
        const leftWhitespace = this.repeat(' ', this.leftPadding);
        return this.wrapInVerticalLines(line.text, leftWhitespace, rightWhitespace);
    }
    /**
     * Returns the heading line with the border bottom
     */
    getHeading() {
        if (!this.state.heading) {
            return;
        }
        /**
         * Creating the header text
         */
        const leftWhitespace = this.repeat(' ', this.leftPadding);
        const rightWhitespace = this.repeat(' ', this.widestLineLength - this.state.heading.width + this.rightPadding);
        const headingContent = this.wrapInVerticalLines(this.state.heading.text, leftWhitespace, rightWhitespace);
        /**
         * Creating the heading border bottom
         */
        const horizontalLength = this.widestLineLength + this.leftPadding + this.rightPadding;
        const borderLine = this.repeat(this.dim(cli_boxes_1.default.single.top), horizontalLength);
        const border = this.wrapInVerticalLines(borderLine, '', '');
        return `${headingContent}\n${border}`;
    }
    /**
     * Returns node for a empty line
     */
    getEmptyLineNode() {
        return { text: '', width: 0 };
    }
    /**
     * Returns instructions lines with the padding
     */
    getLinesWithPadding() {
        const top = new Array(this.paddingTop).fill('').map(this.getEmptyLineNode);
        const bottom = new Array(this.paddingBottom).fill('').map(this.getEmptyLineNode);
        return top.concat(this.state.content).concat(bottom);
    }
    /**
     * Define a custom renderer. Logs to "stdout" and "stderr"
     * by default
     */
    useRenderer(renderer) {
        this.renderer = renderer;
        return this;
    }
    /**
     * Define heading for instructions
     */
    heading(text) {
        const width = (0, string_width_1.default)(text);
        if (width > this.widestLineLength) {
            this.widestLineLength = width;
        }
        this.state.heading = { text, width };
        return this;
    }
    /**
     * Add new instruction. Each instruction is rendered
     * in a new line inside a box
     */
    add(text) {
        text = this.options.icons ? `${this.dim(Icons_1.icons.pointer)} ${text}` : `${text}`;
        const width = (0, string_width_1.default)(text);
        if (width > this.widestLineLength) {
            this.widestLineLength = width;
        }
        this.state.content.push({ text, width });
        return this;
    }
    /**
     * Render instructions
     */
    render() {
        const renderer = this.getRenderer();
        /**
         * Render content as it is in testing mode
         */
        if (this.testing) {
            this.state.heading && renderer.log(this.state.heading.text);
            this.state.content.forEach(({ text }) => renderer.log(text));
            return;
        }
        const top = this.getTopLine();
        const heading = this.getHeading();
        const body = this.getLinesWithPadding()
            .map((line) => this.getContentLine(line))
            .join('\n');
        const bottom = this.getBottomLine();
        let output = `${top}\n`;
        if (heading) {
            output = `${output}${heading}\n`;
        }
        renderer.log(`${output}${body}\n${bottom}`);
    }
}
exports.Instructions = Instructions;
