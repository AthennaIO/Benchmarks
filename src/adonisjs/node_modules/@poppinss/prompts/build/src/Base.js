"use strict";
/*
 * @poppinss/prompts
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Prompt = exports.icons = void 0;
const events_1 = require("events");
const colors_1 = require("@poppinss/colors");
const ObjectBuilder_1 = require("./ObjectBuilder");
/**
 * Colors and icons to use.
 */
const colors = new colors_1.Colors();
exports.icons = process.platform === 'win32' && !process.env.WT_SESSION ? { pointer: '>' } : { pointer: '❯' };
/**
 * Base class extended by [[Enquirer]] and [[Emitter]] classes to have
 * common interface.
 */
class Prompt extends events_1.EventEmitter {
    on(event, callback) {
        super.on(event, callback);
        return this;
    }
    /**
     * Prompts for text input
     */
    async ask(title, options) {
        options = options || {};
        const builder = new ObjectBuilder_1.ObjectBuilder();
        builder.addProp('type', 'input');
        builder.addProp('name', options.name);
        builder.addProp('message', title);
        builder.addProp('hint', options.hint);
        builder.addProp('initial', options.default);
        builder.addProp('result', options.result);
        builder.addProp('format', options.format);
        builder.addProp('validate', options.validate);
        builder.addProp('prefix', colors.dim(exports.icons.pointer));
        builder.addProp('styles', {
            danger: (value) => colors.red(value),
            submitted: (value) => colors.cyan(value),
        });
        return this.prompt(builder.toJSON());
    }
    /**
     * Prompts for text input
     */
    async enum(title, options) {
        options = options || {};
        const builder = new ObjectBuilder_1.ObjectBuilder();
        builder.addProp('type', 'list');
        builder.addProp('sep', options.seperator || ',');
        builder.addProp('name', options.name);
        builder.addProp('message', title);
        builder.addProp('hint', options.hint);
        builder.addProp('initial', options.default);
        builder.addProp('result', options.result);
        builder.addProp('format', options.format);
        builder.addProp('validate', options.validate);
        builder.addProp('prefix', colors.dim(exports.icons.pointer));
        builder.addProp('styles', {
            danger: (value) => colors.red(value),
        });
        return this.prompt(builder.toJSON());
    }
    /**
     * Prompts for text input but mangles the output (for password)
     */
    async secure(title, options) {
        options = options || {};
        const builder = new ObjectBuilder_1.ObjectBuilder();
        builder.addProp('type', 'password');
        builder.addProp('name', options.name);
        builder.addProp('message', title);
        builder.addProp('initial', options.default);
        builder.addProp('result', options.result);
        builder.addProp('format', options.format);
        builder.addProp('validate', options.validate);
        builder.addProp('prefix', colors.dim(exports.icons.pointer));
        builder.addProp('styles', {
            danger: (value) => colors.red(value),
            submitted: (value) => colors.cyan(value),
        });
        return this.prompt(builder.toJSON());
    }
    /**
     * Asks for `Y/n`
     */
    async confirm(title, options) {
        options = options || {};
        const builder = new ObjectBuilder_1.ObjectBuilder();
        builder.addProp('type', 'confirm');
        builder.addProp('name', options.name);
        builder.addProp('message', title);
        builder.addProp('hint', options.hint);
        builder.addProp('initial', options.default);
        builder.addProp('result', options.result);
        builder.addProp('format', options.format);
        builder.addProp('validate', options.validate);
        builder.addProp('prefix', colors.dim(exports.icons.pointer));
        builder.addProp('styles', {
            danger: (value) => colors.red(value),
            submitted: (value) => colors.cyan(value),
        });
        return this.prompt(builder.toJSON());
    }
    /**
     * Similar to [[this.confirm]] but with custom toggle options
     */
    async toggle(title, choices, options) {
        options = options || {};
        const builder = new ObjectBuilder_1.ObjectBuilder();
        builder.addProp('type', 'toggle');
        builder.addProp('name', options.name);
        builder.addProp('message', title);
        builder.addProp('hint', options.hint);
        builder.addProp('initial', options.default);
        builder.addProp('result', options.result);
        builder.addProp('format', options.format);
        builder.addProp('validate', options.validate);
        builder.addProp('enabled', choices[0]);
        builder.addProp('disabled', choices[1]);
        builder.addProp('prefix', colors.dim(exports.icons.pointer));
        builder.addProp('styles', {
            danger: (value) => colors.red(value),
            submitted: (value) => colors.cyan(value),
        });
        return this.prompt(builder.toJSON());
    }
    /**
     * Prompts for text input
     */
    async choice(title, choices, options) {
        options = options || {};
        const builder = new ObjectBuilder_1.ObjectBuilder();
        builder.addProp('type', 'select');
        builder.addProp('name', options.name);
        builder.addProp('message', title);
        builder.addProp('initial', options.default);
        builder.addProp('hint', options.hint || 'Press <ENTER> to select');
        builder.addProp('result', options.result);
        builder.addProp('format', options.format);
        builder.addProp('validate', options.validate);
        builder.addProp('prefix', colors.dim(exports.icons.pointer));
        builder.addProp('styles', {
            danger: (value) => colors.red(value),
            submitted: (value) => colors.cyan(value),
        });
        builder.addProp('choices', choices.map((choice) => {
            if (typeof choice === 'string') {
                return { name: choice, message: choice, value: choice };
            }
            return choice;
        }));
        return this.prompt(builder.toJSON());
    }
    /**
     * Prompts for text input
     */
    async multiple(title, choices, options) {
        options = options || {};
        const builder = new ObjectBuilder_1.ObjectBuilder();
        builder.addProp('type', 'multiselect');
        builder.addProp('name', options.name);
        builder.addProp('message', title);
        builder.addProp('initial', options.default);
        builder.addProp('result', options.result);
        builder.addProp('format', options.format);
        builder.addProp('hint', options.hint || 'Press <SPACE> to select');
        builder.addProp('validate', options.validate);
        builder.addProp('prefix', colors.dim(exports.icons.pointer));
        builder.addProp('styles', {
            danger: (value) => colors.red(value),
            submitted: (value) => colors.cyan(value),
        });
        builder.addProp('indicator', (state, choice) => {
            if (choice.enabled) {
                return colors.cyan(state.symbols.radio.on);
            }
            return colors.dim(state.symbols.radio.off);
        });
        builder.addProp('choices', choices.map((choice) => {
            if (typeof choice === 'string') {
                return { name: choice, message: choice, value: choice };
            }
            return choice;
        }));
        return this.prompt(builder.toJSON());
    }
    /**
     * Prompts for text input
     */
    async autocomplete(title, choices, options) {
        options = options || {};
        const builder = new ObjectBuilder_1.ObjectBuilder();
        builder.addProp('type', 'autocomplete');
        builder.addProp('name', options.name);
        builder.addProp('message', title);
        builder.addProp('initial', options.default);
        builder.addProp('multiple', options.multiple);
        builder.addProp('result', options.result);
        builder.addProp('hint', options.hint || '(Type to filter) or (Press <ENTER> to select)');
        builder.addProp('format', options.format);
        builder.addProp('validate', options.validate);
        builder.addProp('choices', choices);
        builder.addProp('prefix', colors.dim(exports.icons.pointer));
        builder.addProp('styles', {
            danger: (value) => colors.red(value),
            submitted: (value) => colors.cyan(value),
        });
        return this.prompt(builder.toJSON());
    }
}
exports.Prompt = Prompt;
