{"version":3,"sources":["../src/stack/index.ts","../src/parser/main.ts","../src/parser/stringify.ts","../src/parser/generate_ast.ts","../src/parser/transform_ast.ts","../src/expressions/index.ts","../src/parser/expression_builder/member.ts","../src/expressions/identifier.ts","../src/expressions/member_expression.ts","../src/expressions/expression_statement.ts","../src/expressions/call_expression.ts","../src/expressions/arrow_function_expression.ts","../src/expressions/literal.ts","../src/expressions/template_literal.ts","../src/expressions/binary_expression.ts","../src/expressions/array_expression.ts","../src/expressions/object_expression.ts","../src/expressions/unary_expression.ts","../src/expressions/function_declaration.ts","../src/expressions/conditional_expression.ts","../src/expressions/logical_expression.ts","../src/expressions/sequence_expression.ts","../src/expressions/assignment_expression.ts","../src/expressions/await_expression.ts","../src/expressions/new_expression.ts","../src/expressions/block_statement.ts","../src/expressions/return_statement.ts","../src/expressions/this_expression.ts","../src/expressions/chain_expression.ts","../src/expressions/spread_element.ts","../src/parser/expression_builder/callable.ts","../src/parser/collect_object_expression_properties.ts","../src/edge_buffer/index.ts","../index.ts"],"sourcesContent":["/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**\n * Stack exposes the API to define variables and scopes. This is used by the parser\n * to decide the syntax for resolving variables.\n */\nexport class Stack {\n  #localVariables: string[] = []\n  #scopes: string[][] = []\n\n  /**\n   * Returns the recent scope of the local variables array\n   */\n  #getRecentScope(): string[] {\n    const hasScopes = this.#scopes.length\n    return hasScopes ? this.#scopes[this.#scopes.length - 1] : this.#localVariables\n  }\n\n  /**\n   * Finds item inside the list or `needle in haystack`\n   */\n  #isInList(list: string[], item: string): boolean {\n    return !!list.find((listItem) => listItem === item)\n  }\n\n  /**\n   * Define a new custom scope\n   */\n  defineScope(): void {\n    this.#scopes.push([])\n  }\n\n  /**\n   * Clear recently created scope\n   */\n  clearScope(): void {\n    this.#scopes.pop()\n  }\n\n  /**\n   * Define variable inside the stack.\n   */\n  defineVariable(variableName: string): void {\n    this.#getRecentScope().push(variableName)\n  }\n\n  /**\n   * Returns a boolean telling if a variable is defined inside\n   * the stack\n   */\n  has(variableName: string): boolean {\n    if (this.#isInList(this.#localVariables, variableName)) {\n      return true\n    }\n\n    return !!this.#scopes.find((scope) => this.#isInList(scope, variableName))\n  }\n\n  /**\n   * Returns the state tree for the stack\n   */\n  getState() {\n    return {\n      localVariables: this.#localVariables,\n      scopes: this.#scopes,\n    }\n  }\n\n  /**\n   * Returns a flat list of defined variables\n   */\n  list() {\n    return this.#scopes.flat().concat(this.#localVariables)\n  }\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { EOL } from 'node:os'\nimport { Tokenizer, MustacheTypes, TagTypes } from 'edge-lexer'\nimport type { Token, TagToken, MustacheToken } from 'edge-lexer/types'\n\nimport { Stack } from '../stack/index.js'\nimport { stringify } from './stringify.js'\nimport { generateAST } from './generate_ast.js'\nimport { transformAst } from './transform_ast.js'\nimport { EdgeBuffer } from '../edge_buffer/index.js'\nimport { makeCallable } from './expression_builder/callable.js'\nimport { makeMemberAccessor } from './expression_builder/member.js'\nimport type { ParserTagDefinitionContract, ParserOptions } from '../types.js'\nimport {\n  collectObjectExpressionProperties,\n  collectArrayExpressionProperties,\n} from './collect_object_expression_properties.js'\n\n/**\n * Edge parser converts template strings to an invokable function. This module\n * uses [edge-lexer](https://github.com/edge-js/lexer) to generate a list\n * of tokens and process them against [acorn](https://npm.im/acorn).\n *\n * Edge has concepts of Tags, which are not implemented by this module and must\n * be provided by the consumer.\n *\n * ```js\n * // Tags are optional\n * const tags = {}\n *\n * // File name is required for better error reporting\n * const options = { filename: 'welcome.edge' }\n *\n * const parser = new Parser(tags, options)\n * const template = require('fs').readFileSync('welcome.edge', 'utf-8')\n *\n * const tokens = parser.parse(template)\n * console.log(fn)\n * ```\n */\nexport class Parser {\n  /**\n   * A boolean to know if async mode is enabled\n   */\n  asyncMode: boolean\n\n  constructor(\n    public tags: { [key: string]: ParserTagDefinitionContract },\n    public stack: Stack = new Stack(),\n    public options: ParserOptions\n  ) {\n    this.asyncMode = !!this.options.async\n  }\n\n  /**\n   * Parser utilities work with the AST\n   */\n  utils = {\n    stringify,\n    transformAst,\n    makeCallable,\n    makeMemberAccessor,\n    generateAST: generateAST,\n    makeEscapeCallable: makeCallable,\n    makeStatePropertyAccessor: makeMemberAccessor,\n    collectObjectExpressionProperties,\n    collectArrayExpressionProperties,\n    getExpressionLoc(expression: any): { line: number; col: number } {\n      const loc = expression.loc || expression.property?.loc\n      return {\n        line: loc.start.line,\n        col: loc.start.column,\n      }\n    },\n  }\n\n  /**\n   * Returns the options to be passed to the tokenizer\n   */\n  #getTokenizerOptions(options: { filename: string }) {\n    if (!this.options) {\n      return options\n    }\n\n    return {\n      claimTag: this.options.claimTag,\n      onLine: this.options.onLine,\n      filename: options.filename,\n    }\n  }\n\n  /**\n   * Process escaped tag token by writing it as it is. However, the children\n   * inside a tag are still processed.\n   */\n  #processEscapedTagToken(token: TagToken, buffer: EdgeBuffer) {\n    /**\n     * Since `jsArg` can span over multiple lines, we split it into multiple lines\n     * and write one line at a time to maintain the original shape.\n     */\n    const lines = `@${token.properties.name}(${token.properties.jsArg})`.split('\\n')\n    lines.forEach((line) => buffer.outputRaw(line))\n\n    /**\n     * Process all inner children of the tag\n     */\n    token.children.forEach((child) => this.processToken(child, buffer))\n\n    /**\n     * Close the tag\n     */\n    buffer.outputRaw(`@end${token.properties.name}`)\n  }\n\n  /**\n   * Process escaped muscahe block by writing it as it is.\n   */\n  #processEscapedMustache(token: MustacheToken, buffer: EdgeBuffer) {\n    const lines =\n      token.type === MustacheTypes.EMUSTACHE\n        ? `{{${token.properties.jsArg}}}`.split('\\n')\n        : `{{{${token.properties.jsArg}}}}`.split('\\n')\n\n    lines.forEach((line) => buffer.outputRaw(line))\n  }\n\n  /**\n   * Process mustache token\n   */\n  #processMustache({ properties, loc, filename, type }: MustacheToken, buffer: EdgeBuffer) {\n    const node = transformAst(generateAST(properties.jsArg, loc, filename), filename, this)\n\n    /**\n     * Wrap mustache output to an escape call for preventing XSS attacks\n     */\n    const expression =\n      type === MustacheTypes.MUSTACHE ? makeCallable(this.options.escapeCallPath, [node]) : node\n\n    /**\n     * Template literal, so there is no need to wrap it inside another\n     * template string\n     */\n    if (node.type === 'TemplateLiteral') {\n      buffer.outputExpression(stringify(expression), filename, loc.start.line, false)\n    } else if (node.type === 'FunctionDeclaration') {\n      buffer.outputExpression(stringify(node), filename, loc.start.line, false)\n    } else {\n      buffer.outputExpression(stringify(expression), filename, loc.start.line, true)\n    }\n  }\n\n  /**\n   * Convert template to tokens\n   */\n  tokenize(template: string, options: { filename: string }) {\n    const tokenizer = new Tokenizer(template, this.tags, this.#getTokenizerOptions(options))\n    tokenizer.parse()\n    return tokenizer.tokens\n  }\n\n  /**\n   * Process a lexer token. The output gets written to the buffer\n   */\n  processToken(token: Token, buffer: EdgeBuffer) {\n    switch (token.type) {\n      case 'raw':\n        buffer.outputRaw(token.value)\n        break\n      case 'newline':\n        buffer.outputRaw(EOL === '\\n' ? '\\n' : '\\r\\n')\n        break\n      case TagTypes.TAG:\n        if (typeof this.options.onTag === 'function') {\n          this.options.onTag(token)\n        }\n        this.tags[token.properties.name].compile(this, buffer, token as TagToken)\n        break\n      case TagTypes.ETAG:\n        this.#processEscapedTagToken(token, buffer)\n        break\n      case MustacheTypes.EMUSTACHE:\n      case MustacheTypes.ESMUSTACHE:\n        this.#processEscapedMustache(token, buffer)\n        break\n      case MustacheTypes.SMUSTACHE:\n      case MustacheTypes.MUSTACHE:\n        if (typeof this.options.onMustache === 'function') {\n          this.options.onMustache(token)\n        }\n        this.#processMustache(token, buffer)\n    }\n  }\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { generate } from 'astring'\n\n/**\n * Convert the acorn AST to a Javascript expression string\n */\nexport function stringify(astExpression: any): string {\n  return generate(astExpression)\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { EdgeError } from 'edge-error'\nimport type { LexerLoc } from 'edge-lexer/types'\nimport { parse as acornParse, Token } from 'acorn'\n\nimport { AcornLoc } from '../types.js'\n\n/**\n * Patch the acorn loc to point to the correct line number\n * inside the original template engine\n */\nfunction patchLoc(loc: AcornLoc, lexerLoc: LexerLoc): void {\n  /**\n   * Patch the column also, when it's the first line. The reason we do this, since\n   * the first line in the actual edge file may contain the Javascript expression\n   * at a different column all together\n   */\n  if (loc.start.line === 1) {\n    loc.start.column = loc.start.column + lexerLoc.start.col\n  }\n\n  loc.start.line = loc.start.line + lexerLoc.start.line - 1\n  loc.end.line = loc.end.line + lexerLoc.start.line - 1\n}\n\n/**\n * Generates and returns the acorn AST for a given Javascript expression. Assuming\n * the Javascript expression is embedded into the edge lexer token, this method\n * expects you to pass the token loc and the filename.\n */\nexport function generateAST(jsArg: string, lexerLoc: LexerLoc, filename: string): any {\n  const acornOptions = {\n    locations: true,\n    ecmaVersion: 2020 as const,\n    allowAwaitOutsideFunction: true,\n    onToken: (token: Token) => patchLoc(token.loc!, lexerLoc),\n  }\n\n  try {\n    const ast = acornParse(jsArg, acornOptions)\n    // @ts-ignore\n    return ast['body'][0]\n  } catch (error) {\n    /**\n     * The error loc is not passed via `onToken` event, so need\n     * to patch is here seperately\n     */\n    const line = error.loc.line + lexerLoc.start.line - 1\n    const col = error.loc.line === 1 ? error.loc.column + lexerLoc.start.col : error.loc.column\n    throw new EdgeError(error.message.replace(/\\(\\d+:\\d+\\)/, ''), 'E_ACORN_ERROR', {\n      line,\n      col,\n      filename,\n    })\n  }\n}\n","/*\n * edge-lexer\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { EdgeError } from 'edge-error'\n\nimport { Parser } from './main.js'\nimport * as Expressions from '../expressions/index.js'\n\n/**\n * Transform acorn AST to Edge AST. This must always be performed before\n * writing it to the compiled template buffer.\n */\nexport function transformAst(astExpression: any, filename: string, parser: Parser): any {\n  const Expression = Expressions[astExpression.type as keyof typeof Expressions]\n  if (Expression) {\n    return Expression.toStatement(astExpression, filename, parser)\n  }\n\n  const { type, loc } = astExpression\n  throw new EdgeError(`\"${type}\" is not supported`, 'E_UNALLOWED_EXPRESSION', {\n    line: loc.start.line,\n    col: loc.start.column,\n    filename: filename,\n  })\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nexport { default as Identifier } from './identifier.js'\nexport { default as MemberExpression } from './member_expression.js'\nexport { default as ExpressionStatement } from './expression_statement.js'\nexport { default as CallExpression } from './call_expression.js'\nexport { default as ArrowFunctionExpression } from './arrow_function_expression.js'\nexport { default as Literal } from './literal.js'\nexport { default as TemplateLiteral } from './template_literal.js'\nexport { default as BinaryExpression } from './binary_expression.js'\nexport { default as ArrayExpression } from './array_expression.js'\nexport { default as ObjectExpression } from './object_expression.js'\nexport { default as UnaryExpression } from './unary_expression.js'\nexport { default as FunctionDeclaration } from './function_declaration.js'\nexport { default as ConditionalExpression } from './conditional_expression.js'\nexport { default as LogicalExpression } from './logical_expression.js'\nexport { default as SequenceExpression } from './sequence_expression.js'\nexport { default as AssignmentExpression } from './assignment_expression.js'\nexport { default as AwaitExpression } from './await_expression.js'\nexport { default as NewExpression } from './new_expression.js'\nexport { default as BlockStatement } from './block_statement.js'\nexport { default as ReturnStatement } from './return_statement.js'\nexport { default as ThisExpression } from './this_expression.js'\nexport { default as ChainExpression } from './chain_expression.js'\nexport { default as SpreadElement } from './spread_element.js'\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**\n * Returns Acorn complaint AST for a member expression\n */\nexport function makeMemberAccessor(propertyName: string, args: object): any {\n  return {\n    type: 'MemberExpression',\n    object: {\n      type: 'Identifier',\n      name: propertyName,\n    },\n    computed: false,\n    property: args,\n  }\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { Parser } from '../parser/main.js'\nimport { makeMemberAccessor } from '../parser/expression_builder/member.js'\n\nexport default {\n  toStatement(statement: any, _: string, parser: Parser): object {\n    if (\n      (parser.options.localVariables || []).indexOf(statement.name) > -1 ||\n      parser.stack.has(statement.name) ||\n      global[statement.name as keyof typeof global] !== undefined\n    ) {\n      return statement\n    }\n\n    return makeMemberAccessor(parser.options.statePropertyName, statement)\n  },\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { transformAst } from '../parser/transform_ast.js'\nimport { Parser } from '../parser/main.js'\n\nexport default {\n  toStatement(statement: any, filename: string, parser: Parser) {\n    statement.object = transformAst(statement.object, filename, parser)\n\n    /**\n     * Making the following expressions work\n     *\n     * user[Object.keys(user).find((k) => k === 'id')]\n     * [num1, num2, num3].filter((num) => num % 2 === 0)\n     */\n    if (statement.property.type !== 'Identifier') {\n      statement.property = transformAst(statement.property, filename, parser)\n    }\n    return statement\n  },\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { transformAst } from '../parser/transform_ast.js'\nimport { Parser } from '../parser/main.js'\n\nexport default {\n  toStatement(statement: any, filename: string, parser: Parser) {\n    return transformAst(statement.expression, filename, parser)\n  },\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { transformAst } from '../parser/transform_ast.js'\nimport { Parser } from '../parser/main.js'\n\nexport default {\n  toStatement(statement: any, filename: string, parser: Parser) {\n    statement.callee = transformAst(statement.callee, filename, parser)\n    statement.arguments = statement.arguments.map((node: any) =>\n      transformAst(node, filename, parser)\n    )\n    return statement\n  },\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { EdgeError } from 'edge-error'\nimport { Parser } from '../parser/main.js'\nimport { transformAst } from '../parser/transform_ast.js'\n\nexport default {\n  toStatement(statement: any, filename: string, parser: Parser) {\n    parser.stack.defineScope()\n\n    statement.params.forEach((param: any) => {\n      if (param.type === 'Identifier') {\n        parser.stack.defineVariable(param.name)\n      } else if (param.type === 'ObjectPattern') {\n        parser.utils.collectObjectExpressionProperties(param).forEach((prop) => {\n          parser.stack.defineVariable(prop)\n        })\n      } else if (param.type === 'ArrayPattern') {\n        parser.utils.collectArrayExpressionProperties(param).forEach((prop) => {\n          parser.stack.defineVariable(prop)\n        })\n      } else {\n        const { line, col } = parser.utils.getExpressionLoc(param)\n        throw new EdgeError(\n          `Report this error to the maintainers: Unexpected arrow function property type ${param.type}`,\n          'E_PARSER_ERROR',\n          {\n            line,\n            col,\n            filename,\n          }\n        )\n      }\n    })\n\n    statement.body = transformAst(statement.body, filename, parser)\n\n    parser.stack.clearScope()\n\n    return statement\n  },\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nexport default {\n  toStatement(statement: any) {\n    return statement\n  },\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { transformAst } from '../parser/transform_ast.js'\nimport { Parser } from '../parser/main.js'\n\nexport default {\n  toStatement(statement: any, filename: string, parser: Parser) {\n    statement.expressions = statement.expressions.map((expression: any) => {\n      return transformAst(expression, filename, parser)\n    })\n\n    return statement\n  },\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { transformAst } from '../parser/transform_ast.js'\nimport { Parser } from '../parser/main.js'\n\nexport default {\n  toStatement(statement: any, filename: string, parser: Parser) {\n    statement.left = transformAst(statement.left, filename, parser)\n    statement.right = transformAst(statement.right, filename, parser)\n    return statement\n  },\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { Parser } from '../parser/main.js'\nimport { transformAst } from '../parser/transform_ast.js'\n\nexport default {\n  toStatement(statement: any, filename: string, parser: Parser) {\n    statement.elements = statement.elements.map((element: any) =>\n      transformAst(element, filename, parser)\n    )\n    return statement\n  },\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { transformAst } from '../parser/transform_ast.js'\nimport { Parser } from '../parser/main.js'\nimport { EdgeError } from 'edge-error'\n\nexport default {\n  toStatement(statement: any, filename: string, parser: Parser) {\n    statement.properties = statement.properties.map((node: any) => {\n      if (node.type === 'Property') {\n        /**\n         * Since we change the structure of node.value, we have to\n         * turnoff shorthand objects, so that the astring outputs\n         * the key name explicitly\n         */\n        node.shorthand = false\n\n        if (node.computed === true) {\n          node.key = transformAst(node.key, filename, parser)\n        }\n        node.value = transformAst(node.value, filename, parser)\n        return node\n      }\n\n      if (node.type === 'SpreadElement') {\n        return transformAst(node, filename, parser)\n      }\n\n      const { line, col } = parser.utils.getExpressionLoc(node)\n      throw new EdgeError(\n        `Report this error to the maintainers: Unexpected object property type \"${node.type}\"`,\n        'E_PARSER_ERROR',\n        {\n          line,\n          col,\n          filename,\n        }\n      )\n    })\n\n    return statement\n  },\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { transformAst } from '../parser/transform_ast.js'\nimport { Parser } from '../parser/main.js'\n\nexport default {\n  toStatement(statement: any, filename: string, parser: Parser) {\n    statement.argument = transformAst(statement.argument, filename, parser)\n    return statement\n  },\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nexport default {\n  toStatement(statement: any) {\n    return statement\n  },\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { transformAst } from '../parser/transform_ast.js'\nimport { Parser } from '../parser/main.js'\n\nexport default {\n  toStatement(statement: any, filename: string, parser: Parser) {\n    statement.test = transformAst(statement.test, filename, parser)\n    statement.consequent = transformAst(statement.consequent, filename, parser)\n    statement.alternate = transformAst(statement.alternate, filename, parser)\n    return statement\n  },\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { transformAst } from '../parser/transform_ast.js'\nimport { Parser } from '../parser/main.js'\n\nexport default {\n  toStatement(statement: any, filename: string, parser: Parser) {\n    statement.left = transformAst(statement.left, filename, parser)\n    statement.right = transformAst(statement.right, filename, parser)\n    return statement\n  },\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { transformAst } from '../parser/transform_ast.js'\nimport { Parser } from '../parser/main.js'\n\nexport default {\n  toStatement(statement: any, filename: string, parser: Parser) {\n    statement.expressions = statement.expressions.map((expression: any) => {\n      return transformAst(expression, filename, parser)\n    })\n    return statement\n  },\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { transformAst } from '../parser/transform_ast.js'\nimport { Parser } from '../parser/main.js'\n\nexport default {\n  toStatement(statement: any, filename: string, parser: Parser) {\n    statement.left = transformAst(statement.left, filename, parser)\n    statement.right = transformAst(statement.right, filename, parser)\n    return statement\n  },\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { EdgeError } from 'edge-error'\nimport { transformAst } from '../parser/transform_ast.js'\nimport { Parser } from '../parser/main.js'\n\nconst UNALLOWED_EXPRESSION_MESSAGE =\n  'Make sure to render template in async mode before using await expression'\n\nexport default {\n  toStatement(statement: any, filename: string, parser: Parser) {\n    if (!parser.options.async) {\n      const { line, col } = parser.utils.getExpressionLoc(statement)\n      throw new EdgeError(UNALLOWED_EXPRESSION_MESSAGE, 'E_PARSER_ERROR', {\n        line,\n        col,\n        filename,\n      })\n    }\n\n    statement.argument = transformAst(statement.argument, filename, parser)\n    return statement\n  },\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { transformAst } from '../parser/transform_ast.js'\nimport { Parser } from '../parser/main.js'\n\nexport default {\n  toStatement(statement: any, filename: string, parser: Parser) {\n    statement.arguments = statement.arguments.map((expression: any) => {\n      return transformAst(expression, filename, parser)\n    })\n    return statement\n  },\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { transformAst } from '../parser/transform_ast.js'\nimport { Parser } from '../parser/main.js'\n\nexport default {\n  toStatement(statement: any, filename: string, parser: Parser) {\n    statement.body = statement.body.map((token: any) => {\n      return transformAst(token, filename, parser)\n    })\n\n    return statement\n  },\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { transformAst } from '../parser/transform_ast.js'\nimport { Parser } from '../parser/main.js'\n\nexport default {\n  toStatement(statement: any, filename: string, parser: Parser) {\n    statement.argument = transformAst(statement.argument, filename, parser)\n    return statement\n  },\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nexport default {\n  toStatement(statement: any) {\n    return statement\n  },\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { transformAst } from '../parser/transform_ast.js'\nimport { Parser } from '../parser/main.js'\n\nexport default {\n  toStatement(statement: any, filename: string, parser: Parser) {\n    statement.expression = transformAst(statement.expression, filename, parser)\n    return statement\n  },\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { Parser } from '../parser/main.js'\n\nexport default {\n  toStatement(statement: any, filename: string, parser: Parser): object {\n    statement.argument = parser.utils.transformAst(statement.argument, filename, parser)\n    return statement\n  },\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**\n * Returns Acorn complaint AST for a callable expression\n */\nexport function makeCallable(paths: string | [string, string], args: object[]): any {\n  if (typeof paths === 'string') {\n    return {\n      type: 'CallExpression',\n      callee: {\n        type: 'Identifier',\n        name: paths,\n      },\n      arguments: args,\n    }\n  }\n\n  return {\n    type: 'CallExpression',\n    callee: {\n      type: 'MemberExpression',\n      object: {\n        type: 'Identifier',\n        name: paths[0],\n      },\n      property: {\n        type: 'Identifier',\n        name: paths[1],\n      },\n    },\n    arguments: args,\n  }\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nexport function collectObjectExpressionProperties(expression: any): string[] {\n  return expression.properties.map((prop: any) => {\n    if (prop.value.type !== 'Identifier') {\n      throw new Error('Object destructuring should not reference dynamic properties')\n    }\n    return prop.value.name\n  })\n}\n\nexport function collectArrayExpressionProperties(expression: any): string[] {\n  return expression.elements.map((prop: any) => {\n    if (prop.type !== 'Identifier') {\n      throw new Error('Array destructuring should not reference dynamic properties')\n    }\n    return prop.name\n  })\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { EOL } from 'node:os'\n// @ts-expect-error \"untyped module\"\nimport stringify from 'js-stringify'\n\n/**\n * Buffer class to construct template\n */\nexport class EdgeBuffer {\n  #outputFileAndLineNumber = true\n  #outputOutVariable = true\n  #outputReturnStatement = true\n  #wrapInsideTryCatch = true\n\n  #options = {\n    outputVar: '',\n    rethrowCallPath: '',\n    fileNameVar: '$filename',\n    lineVar: '$lineNumber',\n  }\n\n  /**\n   * Prefixes and suffix to wrap the final output\n   */\n  #prefix: string[] = []\n  #suffix: string[] = []\n\n  /**\n   * Collected lines\n   */\n  #buffer: string[] = []\n\n  /**\n   * Current runtime line number\n   */\n  #currentLineNumber = 1\n\n  /**\n   * Input filename\n   */\n  #filename: string\n\n  /**\n   * Current runtime filename\n   */\n  #currentFileName: string\n\n  /**\n   * Cached compiled output. Once this value is set, the `flush`\n   * method will become a noop\n   */\n  #compiledOutput: string | undefined\n\n  /**\n   * Exposing output variable name\n   */\n  outputVariableName: string\n\n  constructor(\n    filename: string,\n    options: { outputVar: string; rethrowCallPath: string | [string, string] }\n  ) {\n    this.#filename = filename\n    this.#currentFileName = this.#filename\n    this.outputVariableName = options.outputVar\n    this.#options.outputVar = options.outputVar\n    this.#options.rethrowCallPath = Array.isArray(options.rethrowCallPath)\n      ? options.rethrowCallPath.join('.')\n      : options.rethrowCallPath\n  }\n\n  /**\n   * Creates a new buffer instance by merging the options from the existing one\n   */\n  create(\n    filename: string,\n    options: { outputVar?: string; rethrowCallPath?: string | [string, string] }\n  ) {\n    return new EdgeBuffer(filename, Object.assign({}, this.#options, options))\n  }\n\n  /**\n   * Returns the size of buffer text\n   */\n  get size() {\n    return this.#buffer.length\n  }\n\n  /**\n   * Setup template with initial set of lines\n   */\n  #setup(buffer: string[]) {\n    /**\n     * Define output variable\n     */\n    this.#outputOutVariable && buffer.push(`let ${this.outputVariableName} = \"\";`)\n\n    /**\n     * Define line number variable\n     */\n    this.#outputFileAndLineNumber && buffer.push(`let ${this.#options.lineVar} = 1;`)\n\n    /**\n     * Define filename variable\n     */\n    this.#outputFileAndLineNumber &&\n      buffer.push(`let ${this.#options.fileNameVar} = ${stringify(this.#filename)};`)\n\n    /**\n     * Write try block\n     */\n    this.#wrapInsideTryCatch && buffer.push('try {')\n  }\n\n  /**\n   * Tear down template by writing final set of lines\n   */\n  #teardown(buffer: string[]) {\n    if (this.#wrapInsideTryCatch) {\n      /**\n       * Close try and catch block\n       */\n      buffer.push('} catch (error) {')\n\n      /**\n       * Write catch block\n       */\n      buffer.push(\n        `${this.#options.rethrowCallPath}(error, ${this.#options.fileNameVar}, ${this.#options.lineVar});`\n      )\n\n      /**\n       * End catch block\n       */\n      buffer.push('}')\n    }\n\n    /**\n     * Return output variable\n     */\n    this.#outputReturnStatement && buffer.push(`return ${this.outputVariableName};`)\n  }\n\n  /**\n   * Update the filename at runtime\n   */\n  #updateFileName(filename: string) {\n    if (this.#currentFileName !== filename) {\n      this.#currentFileName = filename\n      this.#buffer.push(`${this.#options.fileNameVar} = ${stringify(filename)};`)\n    }\n  }\n\n  /**\n   * Update the line number at runtime\n   */\n  #updateLineNumber(lineNumber: number) {\n    if (lineNumber > 0 && this.#currentLineNumber !== lineNumber) {\n      this.#currentLineNumber = lineNumber\n      this.#buffer.push(`${this.#options.lineVar} = ${lineNumber};`)\n    }\n  }\n\n  /**\n   * Write raw text to the output variable\n   */\n  outputRaw(text: string): this {\n    this.#buffer.push(`${this.outputVariableName} += ${stringify(text)};`)\n    return this\n  }\n\n  /**\n   * Write JS expression to the output variable\n   */\n  outputExpression(\n    text: string,\n    filename: string,\n    lineNumber: number,\n    templateLiteral: boolean\n  ): this {\n    this.#updateFileName(filename)\n    this.#updateLineNumber(lineNumber)\n    text = templateLiteral ? `\\`\\${${text}}\\`` : text\n    this.#buffer.push(`${this.outputVariableName} += ${text};`)\n    return this\n  }\n\n  /**\n   * Write JS expression\n   */\n  writeExpression(text: string, filename: string, lineNumber: number): this {\n    this.#updateFileName(filename)\n    this.#updateLineNumber(lineNumber)\n    this.#buffer.push(`${text};`)\n    return this\n  }\n\n  /**\n   * Write JS statement. Statements are not suffixed with a semi-colon. It\n   * means, they can be used for writing `if/else` statements.\n   */\n  writeStatement(text: string, filename: string, lineNumber: number): this {\n    this.#updateFileName(filename)\n    this.#updateLineNumber(lineNumber)\n    this.#buffer.push(`${text}`)\n    return this\n  }\n\n  /**\n   * Wrap template with a custom prefix and suffix\n   */\n  wrap(prefix: string, suffix: string): this {\n    this.#prefix.push(prefix)\n    this.#suffix.push(suffix)\n    return this\n  }\n\n  /**\n   * Disable instantiation of the file and the line number variables.\n   */\n  disableFileAndLineVariables(): this {\n    this.#outputFileAndLineNumber = false\n    return this\n  }\n\n  /**\n   * Disable instantiation of the out variable.\n   */\n  disableOutVariable(): this {\n    this.#outputOutVariable = false\n    return this\n  }\n\n  /**\n   * Disable outputting the return statement\n   */\n  disableReturnStatement(): this {\n    this.#outputReturnStatement = false\n    return this\n  }\n\n  /**\n   * Disable wrapping buffer output inside try/catch.\n   */\n  disableTryCatchBlock(): this {\n    this.#wrapInsideTryCatch = false\n    return this\n  }\n\n  /**\n   * Return template as a string\n   */\n  flush(): string {\n    if (this.#compiledOutput !== undefined) {\n      return this.#compiledOutput\n    }\n\n    let buffer: string[] = []\n\n    /**\n     * Write prefixes\n     */\n    this.#prefix.forEach((text) => text.split(EOL).forEach((line) => buffer.push(`${line}`)))\n\n    /**\n     * Write setup code\n     */\n    this.#setup(buffer)\n\n    /**\n     * Copy template contents\n     */\n    buffer = buffer.concat(this.#buffer)\n\n    /**\n     * Write teardown code\n     */\n    this.#teardown(buffer)\n\n    /**\n     * Write prefixes\n     */\n    this.#suffix.forEach((text) => text.split(EOL).forEach((line) => buffer.push(`${line}`)))\n\n    this.#compiledOutput = buffer.join(EOL)\n    return this.#compiledOutput\n  }\n}\n","/*\n * edge-parser\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nexport { Stack } from './src/stack/index.js'\nexport { Parser } from './src/parser/main.js'\nexport { EdgeBuffer } from './src/edge_buffer/index.js'\n\nimport * as ExpressionsList from './src/expressions/index.js'\n\n/**\n * Names of supported expressions\n */\nexport const expressions = Object.keys(ExpressionsList).reduce((result, name) => {\n  // @ts-ignore\n  result[name] = name\n  return result\n}, {}) as { [P in keyof typeof ExpressionsList]: P }\n"],"mappings":"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","names":["EdgeError","EdgeError","EdgeError","EdgeError","EdgeError","EdgeError","EdgeError","EOL","stringify"]}