import { Token } from 'edge-lexer';
import { Stack } from '../Stack';
import { stringify } from './stringify';
import { EdgeBuffer } from '../EdgeBuffer';
import { generateAST } from './generateAst';
import { transformAst } from './transformAst';
import { makeEscapeCallable } from './makeEscapeCallable';
import { makeStatePropertyAccessor } from './makeStatePropertyAccessor';
import { ParserTagDefinitionContract, ParserOptions } from '../Contracts';
import { collectObjectExpressionProperties, collectArrayExpressionProperties } from './collectObjectExpressionProperties';
/**
 * Edge parser converts template strings to an invokable function. This module
 * uses [edge-lexer](https://github.com/edge-js/lexer) to generate a list
 * of tokens and process them against [acorn](https://npm.im/acorn).
 *
 * Edge has concepts of Tags, which are not implemented by this module and must
 * be provided by the consumer.
 *
 * ```js
 * // Tags are optional
 * const tags = {}
 *
 * // File name is required for better error reporting
 * const options = { filename: 'welcome.edge' }
 *
 * const parser = new Parser(tags, options)
 * const template = require('fs').readFileSync('welcome.edge', 'utf-8')
 *
 * const tokens = parser.parse(template)
 * console.log(fn)
 * ```
 */
export declare class Parser {
    tags: {
        [key: string]: ParserTagDefinitionContract;
    };
    stack: Stack;
    options: ParserOptions;
    /**
     * A boolean to know if async mode is enabled
     */
    asyncMode: boolean;
    constructor(tags: {
        [key: string]: ParserTagDefinitionContract;
    }, stack: Stack, options: ParserOptions);
    /**
     * Parser utilities work with the AST
     */
    utils: {
        generateAST: typeof generateAST;
        transformAst: typeof transformAst;
        stringify: typeof stringify;
        makeEscapeCallable: typeof makeEscapeCallable;
        makeStatePropertyAccessor: typeof makeStatePropertyAccessor;
        collectObjectExpressionProperties: typeof collectObjectExpressionProperties;
        collectArrayExpressionProperties: typeof collectArrayExpressionProperties;
        getExpressionLoc(expression: any): {
            line: number;
            col: number;
        };
    };
    /**
     * Returns the options to be passed to the tokenizer
     */
    private getTokenizerOptions;
    /**
     * Process escaped tag token by writing it as it is. However, the children
     * inside a tag are still processed.
     */
    private processEscapedTagToken;
    /**
     * Process escaped muscahe block by writing it as it is.
     */
    private processEscapedMustache;
    /**
     * Process mustache token
     */
    private processMustache;
    /**
     * Convert template to tokens
     */
    tokenize(template: string, options: {
        filename: string;
    }): Token[];
    /**
     * Process a lexer token. The output gets written to the buffer
     */
    processToken(token: Token, buffer: EdgeBuffer): void;
}
