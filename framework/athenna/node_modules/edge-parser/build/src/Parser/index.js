"use strict";
/*
 * edge-parser
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parser = void 0;
const os_1 = require("os");
const edge_lexer_1 = require("edge-lexer");
const Stack_1 = require("../Stack");
const stringify_1 = require("./stringify");
const generateAst_1 = require("./generateAst");
const transformAst_1 = require("./transformAst");
const makeEscapeCallable_1 = require("./makeEscapeCallable");
const makeStatePropertyAccessor_1 = require("./makeStatePropertyAccessor");
const collectObjectExpressionProperties_1 = require("./collectObjectExpressionProperties");
/**
 * Edge parser converts template strings to an invokable function. This module
 * uses [edge-lexer](https://github.com/edge-js/lexer) to generate a list
 * of tokens and process them against [acorn](https://npm.im/acorn).
 *
 * Edge has concepts of Tags, which are not implemented by this module and must
 * be provided by the consumer.
 *
 * ```js
 * // Tags are optional
 * const tags = {}
 *
 * // File name is required for better error reporting
 * const options = { filename: 'welcome.edge' }
 *
 * const parser = new Parser(tags, options)
 * const template = require('fs').readFileSync('welcome.edge', 'utf-8')
 *
 * const tokens = parser.parse(template)
 * console.log(fn)
 * ```
 */
class Parser {
    constructor(tags, stack = new Stack_1.Stack(), options) {
        this.tags = tags;
        this.stack = stack;
        this.options = options;
        /**
         * A boolean to know if async mode is enabled
         */
        this.asyncMode = !!this.options.async;
        /**
         * Parser utilities work with the AST
         */
        this.utils = {
            generateAST: generateAst_1.generateAST,
            transformAst: transformAst_1.transformAst,
            stringify: stringify_1.stringify,
            makeEscapeCallable: makeEscapeCallable_1.makeEscapeCallable,
            makeStatePropertyAccessor: makeStatePropertyAccessor_1.makeStatePropertyAccessor,
            collectObjectExpressionProperties: collectObjectExpressionProperties_1.collectObjectExpressionProperties,
            collectArrayExpressionProperties: collectObjectExpressionProperties_1.collectArrayExpressionProperties,
            getExpressionLoc(expression) {
                const loc = expression.loc || expression.property?.loc;
                return {
                    line: loc.start.line,
                    col: loc.start.column,
                };
            },
        };
    }
    /**
     * Returns the options to be passed to the tokenizer
     */
    getTokenizerOptions(options) {
        if (!this.options) {
            return options;
        }
        return {
            claimTag: this.options.claimTag,
            onLine: this.options.onLine,
            filename: options.filename,
        };
    }
    /**
     * Process escaped tag token by writing it as it is. However, the children
     * inside a tag are still processed.
     */
    processEscapedTagToken(token, buffer) {
        /**
         * Since `jsArg` can span over multiple lines, we split it into multiple lines
         * and write one line at a time to maintain the original shape.
         */
        const lines = `@${token.properties.name}(${token.properties.jsArg})`.split('\n');
        lines.forEach((line) => buffer.outputRaw(line));
        /**
         * Process all inner children of the tag
         */
        token.children.forEach((child) => this.processToken(child, buffer));
        /**
         * Close the tag
         */
        buffer.outputRaw(`@end${token.properties.name}`);
    }
    /**
     * Process escaped muscahe block by writing it as it is.
     */
    processEscapedMustache(token, buffer) {
        const lines = token.type === edge_lexer_1.MustacheTypes.EMUSTACHE
            ? `{{${token.properties.jsArg}}}`.split('\n')
            : `{{{${token.properties.jsArg}}}}`.split('\n');
        lines.forEach((line) => buffer.outputRaw(line));
    }
    /**
     * Process mustache token
     */
    processMustache({ properties, loc, filename, type }, buffer) {
        const node = (0, transformAst_1.transformAst)((0, generateAst_1.generateAST)(properties.jsArg, loc, filename), filename, this);
        /**
         * Wrap mustache output to an escape call for preventing XSS attacks
         */
        const expression = type === edge_lexer_1.MustacheTypes.MUSTACHE
            ? (0, makeEscapeCallable_1.makeEscapeCallable)(this.options.escapeCallPath, [node])
            : node;
        /**
         * Template literal, so there is no need to wrap it inside another
         * template string
         */
        if (node.type === 'TemplateLiteral') {
            buffer.outputExpression((0, stringify_1.stringify)(expression), filename, loc.start.line, false);
        }
        else if (node.type === 'FunctionDeclaration') {
            buffer.outputExpression((0, stringify_1.stringify)(node), filename, loc.start.line, false);
        }
        else {
            buffer.outputExpression((0, stringify_1.stringify)(expression), filename, loc.start.line, true);
        }
    }
    /**
     * Convert template to tokens
     */
    tokenize(template, options) {
        const tokenizer = new edge_lexer_1.Tokenizer(template, this.tags, this.getTokenizerOptions(options));
        tokenizer.parse();
        return tokenizer.tokens;
    }
    /**
     * Process a lexer token. The output gets written to the buffer
     */
    processToken(token, buffer) {
        switch (token.type) {
            case 'raw':
                buffer.outputRaw(token.value);
                break;
            case 'newline':
                buffer.outputRaw(os_1.EOL === '\n' ? '\n' : '\r\n');
                break;
            case edge_lexer_1.TagTypes.TAG:
                if (typeof this.options.onTag === 'function') {
                    this.options.onTag(token);
                }
                this.tags[token.properties.name].compile(this, buffer, token);
                break;
            case edge_lexer_1.TagTypes.ETAG:
                this.processEscapedTagToken(token, buffer);
                break;
            case edge_lexer_1.MustacheTypes.EMUSTACHE:
            case edge_lexer_1.MustacheTypes.ESMUSTACHE:
                this.processEscapedMustache(token, buffer);
                break;
            case edge_lexer_1.MustacheTypes.SMUSTACHE:
            case edge_lexer_1.MustacheTypes.MUSTACHE:
                if (typeof this.options.onMustache === 'function') {
                    this.options.onMustache(token);
                }
                this.processMustache(token, buffer);
        }
    }
}
exports.Parser = Parser;
