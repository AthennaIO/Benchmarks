"use strict";
/*
 * edge-parser
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Stack = void 0;
/**
 * Stack exposes the API to define variables and scopes. This is used by the parser
 * to decide the syntax for resolving variables.
 */
class Stack {
    constructor() {
        this.localVariables = [];
        this.scopes = [];
    }
    /**
     * Returns the recent scope of the local variables array
     */
    getRecentScope() {
        const hasScopes = this.scopes.length;
        return hasScopes ? this.scopes[this.scopes.length - 1] : this.localVariables;
    }
    /**
     * Finds item inside the list or `needle in haystack`
     */
    isInList(list, item) {
        return !!list.find((listItem) => listItem === item);
    }
    /**
     * Define a new custom scope
     */
    defineScope() {
        this.scopes.push([]);
    }
    /**
     * Clear recently created scope
     */
    clearScope() {
        this.scopes.pop();
    }
    /**
     * Define variable inside the stack.
     */
    defineVariable(variableName) {
        this.getRecentScope().push(variableName);
    }
    /**
     * Returns a boolean telling if a variable is defined inside
     * the stack
     */
    has(variableName) {
        if (this.isInList(this.localVariables, variableName)) {
            return true;
        }
        return !!this.scopes.find((scope) => this.isInList(scope, variableName));
    }
    /**
     * Returns the state tree for the stack
     */
    getState() {
        return {
            localVariables: this.localVariables,
            scopes: this.scopes,
        };
    }
    /**
     * Returns a flat list of defined variables
     */
    list() {
        return this.scopes.flat().concat(this.localVariables);
    }
}
exports.Stack = Stack;
