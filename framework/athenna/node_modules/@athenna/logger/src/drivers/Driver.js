/**
 * @athenna/logger
 *
 * (c) Jo√£o Lenon <lenon@athenna.io>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
import { Json } from '@athenna/common';
import { FormatterFactory } from '#src/factories/FormatterFactory';
export class Driver {
    constructor(configs = {}) {
        /**
         * Holds the configuration object itself.
         */
        this.configs = {};
        /**
         * Holds the configuration object of a driver.
         */
        this.driverConfig = {};
        /**
         * Holds the formatter string value.
         */
        this.formatter = 'none';
        /**
         * Holds the configuration object of formatter.
         */
        this.formatterConfig = {};
        /**
         * The max log level that this driver can transport.
         */
        this.level = 'info';
        /**
         * The log level order to check if log could
         * be transported or not.
         */
        this.levelOrder = [
            'trace',
            'debug',
            'info',
            'success',
            'warn',
            'error',
            'fatal'
        ];
        this.configs = configs;
        const json = Json.copy(configs);
        delete json.formatter;
        delete json.formatterConfig;
        this.driverConfig = json;
        this.level = json.level || 'info';
        this.formatter = configs.formatter || 'none';
        this.formatterConfig = configs.formatterConfig || {};
    }
    /**
     * Check if message could be transported.
     */
    couldBeTransported(level) {
        const levelIndex = this.levelOrder.indexOf(level);
        const maxLevelIndex = this.levelOrder.indexOf(this.level);
        return levelIndex >= maxLevelIndex;
    }
    /**
     * Call formatter factory to format the message.
     */
    format(level, message, clean = false) {
        const formatterConfig = { level, clean, ...this.formatterConfig };
        return FormatterFactory.fabricate(this.formatter)
            .config(formatterConfig)
            .format(message);
    }
    /**
     * Get the stream type for level.
     */
    getStreamTypeFor(level) {
        if (this.driverConfig.streamType) {
            return this.driverConfig.streamType;
        }
        let streamType = 'stdout';
        if (level === 'error' || level === 'fatal') {
            streamType = 'stderr';
        }
        return streamType;
    }
}
