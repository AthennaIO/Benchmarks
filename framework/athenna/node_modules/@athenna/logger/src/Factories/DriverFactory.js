/**
 * @athenna/logger
 *
 * (c) Jo√£o Lenon <lenon@athenna.io>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
import { Config } from '@athenna/config';
import { Options } from '@athenna/common';
import { Driver } from '#src/drivers/Driver';
import { FileDriver } from '#src/drivers/FileDriver';
import { NullDriver } from '#src/drivers/NullDriver';
import { SlackDriver } from '#src/drivers/SlackDriver';
import { StackDriver } from '#src/drivers/StackDriver';
import { ConsoleDriver } from '#src/drivers/ConsoleDriver';
import { DiscordDriver } from '#src/drivers/DiscordDriver';
import { FactoryHelper } from '#src/helpers/FactoryHelper';
import { TelegramDriver } from '#src/drivers/TelegramDriver';
import { DriverExistException } from '#src/exceptions/DriverExistException';
import { NotFoundDriverException } from '#src/exceptions/NotFoundDriverException';
import { NotImplementedConfigException } from '#src/exceptions/NotImplementedConfigException';
export class DriverFactory {
    /**
     * Drivers of DriverFactory.
     */
    static { this.drivers = new Map()
        .set('file', { Driver: FileDriver })
        .set('null', { Driver: NullDriver })
        .set('slack', { Driver: SlackDriver })
        .set('stack', { Driver: StackDriver })
        .set('console', { Driver: ConsoleDriver })
        .set('discord', { Driver: DiscordDriver })
        .set('telegram', { Driver: TelegramDriver }); }
    /**
     * Return an array with all available drivers.
     */
    static availableDrivers() {
        const availableDrivers = [];
        for (const key of this.drivers.keys()) {
            availableDrivers.push(key);
        }
        return availableDrivers;
    }
    /**
     * Fabricate a new instance of a driver based on
     * channel configurations.
     */
    static fabricate(channelName, configs = {}) {
        const channelConfig = this.getChannelConfig(channelName);
        const { Driver } = this.drivers.get(channelConfig.driver);
        return new Driver(FactoryHelper.groupConfigs(configs, channelConfig));
    }
    /**
     * Fabricate a new instance of a driver with vanilla
     * configurations.
     */
    static fabricateVanilla(configs = {}) {
        configs = Options.create(configs, {
            driver: 'console',
            formatter: 'none'
        });
        if (!this.drivers.has(configs.driver)) {
            throw new NotFoundDriverException(configs.driver);
        }
        const { Driver } = this.drivers.get(configs.driver);
        return new Driver(configs);
    }
    /**
     * Creates a new driver implementation.
     */
    static createDriver(name, driver) {
        if (this.drivers.has(name)) {
            throw new DriverExistException(name);
        }
        this.drivers.set(name, { Driver: driver });
    }
    /**
     * Get all the configuration of a channel.
     */
    static getChannelConfig(channelName) {
        if (channelName === 'default') {
            channelName = Config.get('logging.default', channelName);
        }
        const channelConfig = Config.get(`logging.channels.${channelName}`);
        if (!channelConfig) {
            throw new NotImplementedConfigException(channelName);
        }
        if (!this.drivers.has(channelConfig.driver)) {
            throw new NotFoundDriverException(channelConfig.driver);
        }
        return channelConfig;
    }
}
