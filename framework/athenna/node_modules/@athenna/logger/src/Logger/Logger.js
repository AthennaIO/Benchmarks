/**
 * @athenna/logger
 *
 * (c) Jo√£o Lenon <lenon@athenna.io>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
import { Color } from '@athenna/common';
import { Config } from '@athenna/config';
import { Driver } from '#src/drivers/Driver';
import { DriverFactory } from '#src/factories/DriverFactory';
import { VANILLA_CHANNELS } from '#src/constants/VanillaChannels';
export class Logger {
    constructor() {
        /**
         * The drivers responsible for transporting the logs.
         */
        this.drivers = [];
        /**
         * Runtime configurations to be used inside the Drivers and Formatters.
         */
        this.runtimeConfigs = {};
        this.channelOrVanilla(Config.get('logging.default'));
    }
    /**
     * Create a new standalone logger instance. Very
     * useful to create new loggers without changing the
     * channels that are already defined in the main instance.
     */
    static standalone(...configs) {
        const logger = new Logger();
        logger.vanilla(...configs);
        return logger;
    }
    /**
     * Set runtime configurations for drivers and
     * formatters.
     */
    config(runtimeConfigs) {
        this.runtimeConfigs = runtimeConfigs;
        return this;
    }
    /**
     * Change the log channel.
     */
    channel(...channels) {
        this.drivers = [];
        channels.forEach(channel => {
            this.drivers.push(DriverFactory.fabricate(channel, this.runtimeConfigs));
        });
        return this;
    }
    /**
     * Change the log drivers using vanilla configurations.
     * This method does not depend in Athenna configuration
     * files to be executed.
     */
    vanilla(...configs) {
        this.drivers = [];
        if (!configs.length) {
            this.drivers.push(DriverFactory.fabricateVanilla());
            return this;
        }
        configs.forEach(config => {
            this.drivers.push(DriverFactory.fabricateVanilla(config));
        });
        return this;
    }
    /**
     * Verify if channel configuration exists. If not, Athenna will
     * use the default vanilla configurations as drivers.
     */
    channelOrVanilla(channel, configs = {}) {
        if (Config.exists(`logging.channels.${channel}`)) {
            return this.channel(channel);
        }
        return this.vanilla({
            ...VANILLA_CHANNELS[channel],
            ...configs,
        });
    }
    /**
     * Create a new standalone logger instance. Very
     * useful to create new loggers without changing the
     * channels that are already defined in the main instance.
     */
    standalone(...configs) {
        return Logger.standalone(...configs);
    }
    /**
     * Creates a log of type trace in channel.
     */
    trace(...args) {
        return this.log('trace', ...args);
    }
    /**
     * Creates a log of type debug in channel.
     */
    debug(...args) {
        return this.log('debug', ...args);
    }
    /**
     * Creates a log of type info in channel.
     */
    info(...args) {
        return this.log('info', ...args);
    }
    /**
     * Creates a log of type success in channel.
     */
    success(...args) {
        return this.log('success', ...args);
    }
    /**
     * Creates a log of type warn in channel.
     */
    warn(...args) {
        return this.log('warn', ...args);
    }
    /**
     * Creates a log of type error in channel.
     */
    error(...args) {
        return this.log('error', ...args);
    }
    /**
     * Creates a log of type fatal in channel.
     */
    fatal(...args) {
        return this.log('fatal', ...args);
    }
    /**
     * Call drivers to transport the log.
     */
    async log(level, ...args) {
        const message = Color.apply(...args);
        const promises = this.drivers.map((driver) => driver.transport(level, message));
        return Promise.all(promises);
    }
}
