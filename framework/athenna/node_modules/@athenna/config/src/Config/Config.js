/**
 * @athenna/config
 *
 * (c) Victor Tesoura JÃºnior <txsoura@athenna.io>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
import { sep, parse } from 'node:path';
import { loadFile, writeFile } from 'magicast';
import { File, Json, Path, Exec, Module } from '@athenna/common';
import { RecursiveConfigException } from '#src/Exceptions/RecursiveConfigException';
import { NotSupportedKeyException } from '#src/Exceptions/NotSupportedKeyException';
class Config {
    /**
     * Object to save all the configurations.
     */
    static configs = Json.builder({
        ignoreNull: false,
        ignoreUndefined: true,
        referencedValues: false,
    });
    /**
     * Object to save all the paths of the configuration files.
     */
    static paths = Json.builder({
        ignoreNull: false,
        ignoreUndefined: true,
        referencedValues: false,
    });
    static fatherConfigPath = null;
    /**
     * Clear all the configurations of configs object.
     */
    static clear() {
        this.configs = Json.builder({
            ignoreNull: false,
            ignoreUndefined: true,
            referencedValues: false,
        });
        return this;
    }
    /**
     * Verify if configuration key has the same value.
     */
    static is(key, ...values) {
        return this.configs.is(key, ...values);
    }
    /**
     * Verify if configuration key does not have the same value.
     */
    static isNot(key, ...values) {
        return this.configs.isNot(key, ...values);
    }
    /**
     * Verify if configuration key exists.
     */
    static exists(key) {
        return this.configs.exists(key);
    }
    /**
     * Verify if configuration key does not exist.
     */
    static notExists(key) {
        return this.configs.notExists(key);
    }
    /**
     * Verify if configuration keys exists.
     */
    static existsAll(...keys) {
        return this.configs.existsAll(...keys);
    }
    /**
     * Verify if configuration keys not exists.
     */
    static notExistsAll(...keys) {
        return this.configs.notExistsAll(...keys);
    }
    /**
     * Set a value in the configuration key.
     */
    static set(key, value) {
        this.configs.set(key, value);
        return this;
    }
    /**
     * Set a value in the configuration key if value is not defined.
     */
    static safeSet(key, value) {
        if (this.configs.exists(key)) {
            return this;
        }
        this.configs.set(key, value);
        return this;
    }
    /**
     * Delete the configuration key.
     */
    static delete(key) {
        this.configs.delete(key);
        return this;
    }
    /**
     * Get the value from Config file by key. If not
     * found, defaultValue will be used.
     */
    static get(key, defaultValue = undefined) {
        return this.configs.get(key, defaultValue);
    }
    /**
     * Rewrite the configuration file. All values
     * set in the configuration using the Config
     * class will be saved in the file.
     *
     * @example
     * ```ts
     * Config.set('app.foo', 'bar')
     *
     * await Config.rewrite('app')
     * ```
     */
    static async rewrite(key) {
        if (!this.paths.exists(key)) {
            throw new NotSupportedKeyException(key);
        }
        const path = this.paths.get(key);
        const mod = await loadFile(path);
        const config = this.configs.get(key);
        mod.exports.default = config;
        await writeFile(mod.$ast, path, {
            quote: 'single',
            tabWidth: 2,
            trailingComma: {
                objects: true,
            },
        });
    }
    /**
     * Load all configuration files in path.
     */
    static async loadAll(path = Path.config(), safe = false) {
        const files = await Module.getAllJSFilesFrom(path);
        this.fatherConfigPath = path;
        await Exec.concurrently(files, file => safe ? this.safeLoad(file.path) : this.load(file.path));
    }
    /**
     * Load the configuration file only if it has
     * not been loaded yet.
     */
    static async safeLoad(path, callNumber) {
        if (!(await File.exists(path))) {
            return;
        }
        const { name } = parse(path);
        if (this.exists(name)) {
            return;
        }
        return this.load(path, callNumber);
    }
    /**
     * Load the configuration file.
     */
    static async load(path, callNumber = 0) {
        if (!(await File.exists(path))) {
            return;
        }
        const { dir, name, base, ext } = parse(path);
        if (callNumber > 500) {
            throw new RecursiveConfigException(path, name);
        }
        if (base.includes('.js.map') || base.includes('.d.ts')) {
            return;
        }
        if (base.includes('.ts') && Env('IS_TS') === false) {
            return;
        }
        const file = new File(path).loadSync();
        const fileContent = file.getContentSync().toString();
        if (fileContent.includes('Config.get')) {
            const matches = fileContent.match(/Config.get\(([^)]+)\)/g);
            for (let match of matches) {
                match = match.replace('Config.get', '').replace(/[(^)'"]/g, '');
                const fileName = `${match.split('.')[0]}`;
                const fileBase = `${fileName}${ext}`;
                const filePath = `${dir}/${fileBase}`;
                await this.safeLoad(filePath, callNumber + 1);
            }
        }
        let configKey = name;
        if (this.fatherConfigPath) {
            configKey = path
                .replace(`${this.fatherConfigPath}${sep}`, '')
                .replace(ext, '');
            let pattern = `${sep}`;
            if (sep === '\\') {
                pattern = `\\\\`;
            }
            configKey = configKey.replace(new RegExp(pattern, 'g'), '.');
        }
        /**
         * Add random number to file import path so
         * Node.js will not cache the imported file.
         */
        file.href = `${file.href}?version=${Math.random()}`;
        this.configs.set(configKey, await file.import());
        this.paths.set(configKey, file.path);
    }
}
export { Config };
