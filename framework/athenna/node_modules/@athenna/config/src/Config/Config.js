/**
 * @athenna/config
 *
 * (c) Victor Tesoura JÃºnior <txsoura@athenna.io>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
import { File, Json, Path, ObjectBuilder, Exec, Module, Is, } from '@athenna/common';
import { debug } from '#src/debug';
import { loadFile, writeFile } from 'magicast';
import { sep, parse, extname } from 'node:path';
import { RecursiveConfigException } from '#src/exceptions/RecursiveConfigException';
import { NotSupportedKeyException } from '#src/exceptions/NotSupportedKeyException';
import { NotValidArrayConfigException } from '#src/exceptions/NotValidArrayConfigException';
class Config {
    /**
     * Object to save all the configurations.
     */
    static { this.configs = Json.builder({
        ignoreNull: false,
        ignoreUndefined: true,
        referencedValues: false,
    }); }
    /**
     * Object to save all the paths of the configuration files.
     */
    static { this.paths = Json.builder({
        ignoreNull: false,
        ignoreUndefined: true,
        referencedValues: false,
    }); }
    static { this.fatherConfigPath = null; }
    /**
     * Clear all the configurations of config object.
     */
    static clear() {
        this.configs = Json.builder({
            ignoreNull: false,
            ignoreUndefined: true,
            referencedValues: false,
        });
        return this;
    }
    /**
     * Verify if configuration key has the same value.
     */
    static is(key, ...values) {
        return this.configs.is(key, ...values);
    }
    /**
     * Verify if configuration key does not have the same value.
     */
    static isNot(key, ...values) {
        return this.configs.isNot(key, ...values);
    }
    /**
     * Verify if a configuration key exists.
     */
    static exists(key) {
        return this.configs.exists(key);
    }
    /**
     * Verify if a configuration key does not exist.
     */
    static notExists(key) {
        return this.configs.notExists(key);
    }
    /**
     * Verify if configuration keys exist.
     */
    static existsAll(...keys) {
        return this.configs.existsAll(...keys);
    }
    /**
     * Verify if configuration keys not exist.
     */
    static notExistsAll(...keys) {
        return this.configs.notExistsAll(...keys);
    }
    /**
     * Set a value in the configuration key.
     */
    static set(key, value) {
        this.configs.set(key, value);
        return this;
    }
    /**
     * Set a value in the configuration key if the value is not defined.
     */
    static safeSet(key, value) {
        if (this.configs.exists(key)) {
            return this;
        }
        this.configs.set(key, value);
        return this;
    }
    /**
     * Push a value to a configuration key that is a valid array.
     * If the configuration is not an array, an exception will be thrown.
     */
    static push(key, value) {
        const config = this.configs.get(key, []);
        if (!Is.Array(config)) {
            throw new NotValidArrayConfigException(key);
        }
        if (Is.Array(value)) {
            config.push(...value);
        }
        else {
            config.push(value);
        }
        this.configs.set(key, config);
        return this;
    }
    /**
     * Delete the configuration key.
     */
    static delete(key) {
        this.configs.delete(key);
        return this;
    }
    /**
     * Get the value from Config file by key. If not
     * found, defaultValue will be used.
     */
    static get(key, defaultValue = undefined) {
        return this.configs.get(key, defaultValue);
    }
    /**
     * Rewrite the configuration file. All values
     * set in the configuration using the Config
     * class will be saved in the file.
     *
     * @example
     * ```ts
     * Config.set('app.foo', 'bar')
     *
     * await Config.rewrite('app')
     * ```
     */
    static async rewrite(key) {
        if (!this.paths.exists(key)) {
            throw new NotSupportedKeyException(key);
        }
        const path = this.paths.get(key);
        const mod = await loadFile(path);
        const config = this.configs.get(key);
        mod.exports.default = config;
        await writeFile(mod.$ast, path, {
            quote: 'single',
            tabWidth: 2,
            trailingComma: {
                objects: true,
            },
        });
    }
    /**
     * Load all configuration files in path.
     */
    static async loadAll(path = Path.config(), safe = false) {
        if (extname(path)) {
            safe ? await this.safeLoad(path) : await this.load(path);
            return;
        }
        const files = await Module.getAllJSFilesFrom(path);
        this.fatherConfigPath = path;
        await Exec.concurrently(files, file => safe ? this.safeLoad(file.path) : this.load(file.path));
    }
    /**
     * Load the configuration file only if it has
     * not been loaded yet.
     */
    static async safeLoad(path, callNumber) {
        if (!(await File.exists(path))) {
            return;
        }
        const { name } = parse(path);
        if (this.exists(name)) {
            return;
        }
        return this.load(path, callNumber);
    }
    /**
     * Load the configuration file.
     */
    static async load(path, callNumber = 0) {
        if (!(await File.exists(path))) {
            debug('Configuration file path %s does not exist, and will be skipped.', path);
            return;
        }
        const { dir, name, base, ext } = parse(path);
        if (callNumber > 500) {
            throw new RecursiveConfigException(path, name);
        }
        if (base.includes('.js.map') || base.includes('.d.ts')) {
            debug('Configuration file %s being skipped since its extension is not valid.', base);
            return;
        }
        if (base.includes('.ts') && Env('IS_TS') === false) {
            debug('Configuration file %s being skipped since its a TypeScript file and the application is not running in a TypeScript environment.', base);
            return;
        }
        const file = new File(path).loadSync();
        const fileContent = file.getContentSync().toString();
        if (fileContent.includes('Config.get')) {
            const matches = fileContent.match(/Config.get\(([^)]+)\)/g);
            for (let match of matches) {
                match = match.replace('Config.get', '').replace(/[(^)'"]/g, '');
                const fileName = `${match.split('.')[0]}`;
                const fileBase = `${fileName}${ext}`;
                const filePath = `${dir}/${fileBase}`;
                debug('Nested configuration found, loading file %s first.', fileBase);
                await this.safeLoad(filePath, callNumber + 1);
            }
        }
        let configKey = name;
        if (this.fatherConfigPath) {
            configKey = path
                .replace(`${this.fatherConfigPath}${sep}`, '')
                .replace(ext, '');
            let pattern = `${sep}`;
            if (sep === '\\') {
                pattern = `\\\\`;
            }
            configKey = configKey.replace(new RegExp(pattern, 'g'), '.');
        }
        /**
         * Add random number to file an import path so
         * Node.js will not cache the imported file.
         */
        file.href = `${file.href}?version=${Math.random()}`;
        debug('Loading configuration file %s with configuration key as %s.', file.href, configKey);
        this.configs.set(configKey, await file.import());
        this.paths.set(configKey, file.path);
    }
}
export { Config };
