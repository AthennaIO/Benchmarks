/**
 * @athenna/common
 *
 * (c) Jo√£o Lenon <lenon@athenna.io>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
import ms from 'ms';
import bytes from 'bytes';
import yaml from 'js-yaml';
import csvParser from 'csv-parser';
import { Is } from '#src/helpers/Is';
import { String } from '#src/helpers/String';
import { Options } from '#src/helpers/Options';
import { ObjectBuilder } from '#src/helpers/Json';
import { getReasonPhrase, getStatusCode } from 'http-status-codes';
import { InvalidNumberException } from '#src/exceptions/InvalidNumberException';
import { json2csv, csv2json } from 'json-2-csv';
export class Parser {
    /**
     * Parse using Node.js streams, useful for
     * parsing multiple values in files.
     */
    static stream() {
        return {
            /**
             * Parse a csv chunk to an array of json objects.
             */
            csvToArray: (options) => {
                return csvParser(options);
            }
        };
    }
    /**
     * Parse a string to array.
     */
    static stringToArray(string, separator) {
        return string.split(separator).map(index => index.trim());
    }
    /**
     * Parse an array of strings to a string.
     */
    static arrayToString(values, options) {
        if (values.length === 0) {
            return '';
        }
        if (values.length === 1) {
            return values[0];
        }
        if (values.length === 2) {
            return `${values[0]}${options?.pairSeparator || ' and '}${values[1]}`;
        }
        options = Options.create(options, {
            separator: ', ',
            lastSeparator: ' and '
        });
        return (values.slice(0, -1).join(options.separator) +
            options.lastSeparator +
            values[values.length - 1]);
    }
    /**
     * Parse a string to number or Coordinate.
     */
    static stringToNumber(string, isCoordinate = false) {
        if (!string.replace(/\D/g, '')) {
            throw new InvalidNumberException(string);
        }
        string = string.replace(/\D/g, '');
        if (string.length >= 9 || isCoordinate) {
            return parseFloat(string);
        }
        return parseInt(string);
    }
    /**
     * Parse an object to form data.
     */
    static jsonToFormData(object) {
        return Object.keys(object)
            .reduce((previous, current) => {
            return previous + `&${current}=${encodeURIComponent(object[current])}`;
        }, '')
            .substring(1);
    }
    /**
     * Parse form data to json.
     */
    static formDataToJson(formData) {
        const object = {};
        if (formData.startsWith('?'))
            formData = formData.replace('?', '');
        formData.split('&').forEach(queries => {
            const query = queries.split('=');
            object[decodeURIComponent(query[0])] = decodeURIComponent(query[1]);
        });
        return object;
    }
    /**
     * Parse object to yaml string.
     */
    static objectToYamlString(object) {
        return yaml.dump(object);
    }
    /**
     * Parse yaml string to object.
     */
    static yamlStringToObject(text) {
        return yaml.load(text);
    }
    /**
     * Parses all links inside the string to HTML link
     * with <a href= .../>.
     */
    static linkToHref(string) {
        const regex = /(https?:\/\/[^\s]+)/g;
        return string.replace(regex, '<a href="$1">$1</a>');
    }
    /**
     * Parses a number to Byte format.
     */
    static sizeToByte(value, options) {
        return bytes.format(value, options);
    }
    /**
     * Parses a byte format to number.
     */
    static byteToSize(byte) {
        return bytes.parse(byte);
    }
    /**
     * Parses a string to MS format.
     */
    static timeToMs(value) {
        return ms(value);
    }
    /**
     * Parses an MS number to time format.
     */
    static msToTime(value, long = false) {
        return ms(value, { long });
    }
    /**
     * Parses a json to a csv string.
     */
    static arrayToCsv(values, options = {}) {
        return json2csv(values, options);
    }
    /**
     * Parses a csv string to an array of json objects.
     */
    static csvToArray(value, options = {}) {
        return csv2json(value, options);
    }
    /**
     * Parses the status code number to it reason in string.
     */
    static statusCodeToReason(status) {
        return String.toConstantCase(getReasonPhrase(status));
    }
    /**
     * Parses the reason in string to it status code number
     */
    static reasonToStatusCode(reason) {
        reason = String.toSentenceCase(reason, true);
        if (reason === 'Ok')
            reason = 'OK';
        return getStatusCode(reason);
    }
    /**
     * Parses the database connection url to connection object.
     */
    static dbUrlToConnectionObj(url) {
        const urlRegexp = /^([^:\\/\s]+):\/\/((.*):(.*)@|)(.*)(:(.*)|)\/(.*)(\?(.+))?/;
        /** @type {any[]} */
        const matcher = url.match(urlRegexp);
        const connectionObject = {
            protocol: matcher[1],
            user: null,
            password: null,
            host: null,
            port: null,
            database: matcher[8],
            options: {}
        };
        if (matcher[5].includes(',')) {
            connectionObject.host = matcher[5].split(',');
        }
        else {
            connectionObject.host = matcher[5];
            if (matcher[5].includes(':')) {
                const [h, p] = matcher[5].split(':');
                connectionObject.host = h;
                connectionObject.port = parseInt(p);
            }
        }
        if (connectionObject.database.includes('?')) {
            const [database, options] = connectionObject.database.split('?');
            connectionObject.database = database;
            connectionObject.options = this.formDataToJson(options);
        }
        if (matcher[3])
            connectionObject.user = matcher[3];
        if (matcher[4])
            connectionObject.password = matcher[4];
        return connectionObject;
    }
    /**
     * Parses the database connection object to connection url.
     */
    static connectionObjToDbUrl(object) {
        if (Is.Defined(object.url)) {
            return object.url;
        }
        const { protocol, user, password, host, port, database, options } = object;
        let url = `${protocol}://`;
        if (user && password) {
            url = url.concat(user).concat(`:${password}`).concat('@');
        }
        if (Is.Array(host)) {
            url = url.concat(host.join(','));
        }
        else {
            url = url.concat(host);
            /**
             * If port exists and host does not include more than one host
             */
            if (port && !host.includes(','))
                url = url.concat(`:${port}`);
        }
        url = url.concat(`/${database}`);
        if (!Is.Empty(options))
            url = url.concat(`?${this.jsonToFormData(options)}`);
        return url;
    }
    /**
     * Parse an object to an ObjectBuilder.
     */
    static objectToBuilder(object, options = {}) {
        const objectBuilder = new ObjectBuilder(options);
        Object.keys(object).forEach(key => {
            objectBuilder.set(key, object[key]);
        });
        return objectBuilder;
    }
    /**
     * Parse an entire array of objects to an array of ObjectBuilder.
     */
    static arrayObjectToArrayBuilder(objects, options = {}) {
        return objects.map(object => Parser.objectToBuilder(object, options));
    }
}
