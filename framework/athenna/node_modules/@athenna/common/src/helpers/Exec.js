/**
 * @athenna/common
 *
 * (c) Jo√£o Lenon <lenon@athenna.io>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
import { Is } from '#src/helpers/Is';
import { Transform } from 'node:stream';
import { File } from '#src/helpers/File';
import { Path } from '#src/helpers/Path';
import { Options } from '#src/helpers/Options';
import { request as requestHttp } from 'node:http';
import { request as requestHttps } from 'node:https';
import { execa, execaNode, execaCommand } from 'execa';
export class Exec {
    /**
     * Sleep the code in the line that this function
     * is being called.
     */
    static async sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    /**
     * Execute some callback concurrently in all values of the array.
     */
    static async concurrently(array, callback) {
        return Promise.all(array.map(callback));
    }
    /**
     * Execute a shell command as a child process.
     */
    static async shell(command, options = {}) {
        return execa('sh', ['-c', command], options);
    }
    /**
     * Install libraries into a path using a registry as a child process.
     */
    static async install(libraries, options = {}) {
        options = Options.create(options, {
            args: [],
            dev: false,
            reject: true,
            silent: true,
            cached: false,
            registry: 'npm',
            cwd: Path.pwd()
        });
        if (Is.String(libraries)) {
            libraries = [libraries];
        }
        const args = ['install'];
        if (options.registry === 'yarn') {
            args[0] = 'add';
        }
        if (options.dev) {
            args.push('-D');
        }
        if (options.cached) {
            args.push('--prefer-offline');
        }
        args.push(...options.args);
        args.push(...libraries);
        return execa(options.registry, args, {
            reject: options.reject,
            stdio: options.silent ? 'ignore' : 'inherit',
            cwd: options.cwd
        });
    }
    /**
     * Link libraries into a path using a registry as a child process.
     */
    static async link(libraries, options = {}) {
        options = Options.create(options, {
            args: [],
            reject: true,
            silent: true,
            registry: 'npm',
            cwd: Path.pwd()
        });
        if (Is.String(libraries)) {
            libraries = [libraries];
        }
        const args = ['link'];
        args.push(...options.args);
        args.push(...libraries);
        return execa(options.registry, args, {
            reject: options.reject,
            stdio: options.silent ? 'ignore' : 'inherit',
            cwd: options.cwd
        });
    }
    /**
     * Execute one specific command as a child process.
     */
    static command(command, options = {}) {
        return execaCommand(command, options);
    }
    /**
     * Execute a node script as a child process.
     */
    static node(path, argv = [], options = {}) {
        return execaNode(path, argv, options);
    }
    /**
     * Execute an Artisan file in a child process.
     */
    static async artisan(path, options = {}) {
        options = Options.create(options, {
            preferLocal: true,
            windowsHide: false,
            localDir: Path.pwd(),
            cwd: Path.pwd(),
            buffer: false,
            stdio: 'inherit'
        });
        const child = Exec.node(path, process.argv.slice(2), options);
        try {
            const result = await child;
            process.exitCode = result.exitCode;
        }
        catch (error) {
            process.exitCode = 1;
        }
    }
    /**
     * Download an archive to a determined path.
     */
    static async download(path, url) {
        return new Promise((resolve, reject) => {
            const callback = response => {
                const data = new Transform();
                response.on('data', chunk => data.push(chunk));
                response.on('end', function () {
                    resolve(new File(path, data.read()).loadSync());
                });
                response.on('error', error => reject(error));
            };
            if (url.includes('https')) {
                requestHttps(url, callback).end();
                return;
            }
            requestHttp(url, callback).end();
        });
    }
    /**
     * Paginate a collection of data.
     */
    static pagination(data, total, pagination) {
        pagination = Options.create(pagination, {
            page: 0,
            limit: 10,
            resourceUrl: '/'
        });
        const totalPages = Math.ceil(total / pagination.limit);
        const meta = {
            itemCount: data.length,
            totalItems: total,
            totalPages,
            currentPage: pagination.page,
            itemsPerPage: pagination.limit
        };
        let nextPage = 1;
        let previousPage = 0;
        if (meta.currentPage && meta.currentPage < meta.totalPages) {
            nextPage = meta.currentPage + 1;
            previousPage = meta.currentPage - 1;
        }
        const links = {
            first: `${pagination.resourceUrl}?limit=${meta.itemsPerPage}`,
            previous: `${pagination.resourceUrl}?page=${previousPage}&limit=${meta.itemsPerPage}`,
            next: `${pagination.resourceUrl}?page=${nextPage}&limit=${meta.itemsPerPage}`,
            last: `${pagination.resourceUrl}?page=${totalPages}&limit=${meta.itemsPerPage}`
        };
        return { meta, links, data };
    }
}
