/**
 * @athenna/common
 *
 * (c) Robson Trasel <robson.trasel@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import CacheableLookup from 'cacheable-lookup';
import type { URL } from 'node:url';
import type { Store } from 'keyv';
import type { ClientHttp2Session } from 'http2';
import type { Body, Query, Request, Response, RetryStrategyCallback } from '#src/types';
import type { Hooks, Delays, Agents, Method, InitHook, Request as GotRequest, RetryOptions, ResponseType, HttpsOptions, CacheOptions, ToughCookieJar, BeforeRetryHook, BeforeErrorHook, PromiseCookieJar, PaginationOptions, AfterResponseHook, BeforeRequestHook, ParseJsonFunction, DnsLookupIpVersion, BeforeRedirectHook, StringifyJsonFunction, CreateConnectionFunction } from 'got';
export declare class HttpClientBuilder {
    /**
     * Got options used to make the request.
     */
    private options;
    constructor(options?: Request);
    /**
     * Return the options of the client builder.
     */
    getOptions(): Request;
    /**
     * From `http-cache-semantics`
     */
    cacheOptions(cacheOptions: CacheOptions): HttpClientBuilder;
    /**
     * Called with the plain request options, right before their normalization.
     *
     * The second argument represents the current `Options` instance.
     *
     * **Note:**
     * > - This hook must be synchronous.
     *
     * **Note:**
     * > - This is called every time options are merged.
     *
     * **Note:**
     * > - The `options` object may not have the `url` property. To modify it, use a `beforeRequest` hook instead.
     *
     * **Note:**
     * > - This hook is called when a new instance of `Options` is created.
     * > - Do not confuse this with the creation of `Request` or `got(â€¦)`.
     *
     * **Note:**
     * > - When using `got(url)` or `got(url, undefined, defaults)` this hook will **not** be called.
     *
     * This is especially useful in conjunction with `got.extend()` when the input needs custom handling.
     *
     * For example, this can be used to fix typos to migrate from older versions faster.
     *
     * @example
     * ```
     * await HttpClient.builder()
     *    .setInitHook(plain => {
     *       if ('followRedirects' in plain) {
     *           plain.followRedirect = plain.followRedirects
     *           delete plain.followRedirects
     *       }
     *    })
     *    .mergeOptions({ followRedirects: true })
     *    .get('https://example.com')
     *
     * // There is no option named `followRedirects` in got, but we correct it
     * // in an `init` hook.
     * ```
     */
    setInitHook(initHook: InitHook): HttpClientBuilder;
    /**
     * Called right before making the request with `options.createNativeRequestOptions()`.
     *
     * This hook is especially useful in conjunction with `HttpClient.setBuilder(customBuilder)` when you want to sign your request.
     *
     * *Note:**
     * > - Got will make no further changes to the request before it is sent.
     *
     * *Note:**
     * > - Changing `options.json` or `options.form` has no effect on the request. You should change `options.body` instead. If needed, update the `options.headers` accordingly.
     *
     * @example
     * ```
     * const response = await HttpClient.builder()
     *    .setBeforeRequestHook(options => {
     *        options.body = JSON.stringify({ payload: 'new' })
     *        options.headers['content-length'] = options.body.length.toString()
     *    })
     *    .post('https://httpbin.org/anything', { payload: 'old' })
     * ```
     */
    setBeforeRequestHook(hook: BeforeRequestHook): HttpClientBuilder;
    /**
     * The equivalent of `setBeforeRequestHook` but when redirecting.
     *
     * *Tip:**
     * > - This is especially useful when you want to avoid dead sites.
     *
     * @example
     * ```
     * const response = await HttpClient.builder()
     *    .setBeforeRedirectHook((options, response) => {
     *        if (options.hostname === 'deadSite') {
     *            options.hostname = 'fallbackSite'
     *        }
     *    })
     *    .get('https://example.com')
     * ```
     */
    setBeforeRedirectHook(hook: BeforeRedirectHook): HttpClientBuilder;
    /**
     * Called with a `RequestError` instance. The error is passed to the hook right before it's thrown.
     *
     * This is especially useful when you want to have more detailed errors.
     *
     * @example
     * ```
     * await HttpClient.builder()
     *    .responseType('json')
     *    .setBeforeErrorHook(error => {
     *        const { response } = error
     *
     *        if (response && response.body) {
     *            error.name = 'GitHubError'
     *            error.message = `${response.body.message} (${response.statusCode})`
     *       }
     *
     *       return error
     *    })
     *    .get('https://api.github.com/repos/AthennaIO/Common/commits')
     * ```
     */
    setBeforeErrorHook(hook: BeforeErrorHook): HttpClientBuilder;
    /**
     * The equivalent of `setBeforeErrorHook` but when retrying. Additionally,
     * there is a second argument `retryCount`, the current retry number.
     *
     * *Note:**
     * > - When using the Stream API, this hook is ignored.
     *
     * *Note:**
     * > - When retrying, the `beforeRequest` hook is called afterwards.
     *
     * *Note:**
     * > - If no retry occurs, the `beforeError` hook is called instead.
     *
     * This hook is especially useful when you want to retrieve the cause of a retry.
     *
     * @example
     * ```
     * await HttpClient.builder()
     *    .setBeforeRetryHook((error, retryCount) => {
     *        console.log(`Retrying [${retryCount}]: ${error.code}`)
     *        // Retrying [1]: ERR_NON_2XX_3XX_RESPONSE
     *    })
     *    .get('https://httpbin.org/status/500')
     * ```
     */
    setBeforeRetryHook(hook: BeforeRetryHook): HttpClientBuilder;
    /**
     * Each function should return the response. This is especially useful when you want to refresh an access token.
     *
     * *Note:**
     * > - When using the Stream API, this hook is ignored.
     *
     * *Note:**
     * > - Calling the `retryWithMergedOptions` function will trigger `beforeRetry` hooks. If the retry is successful, all remaining `afterResponse` hooks will be called. In case of an error, `beforeRetry` hooks will be called instead.
     * Meanwhile, the `init`, `beforeRequest` , `beforeRedirect` as well as already executed `afterResponse` hooks will be skipped.
     *
     * @example
     * ```
     * const builder = HttpClient.builder()
     *    .mutableDefaults(true)
     *    .setBeforeRetry(error => {
     *        // This will be called on `retryWithMergedOptions(...)`
     *    })
     *    .setAfterResponseHook((response, retryWithMergedOptions) => {
     *        // Unauthorized
     *        if (response.statusCode === 401) {
     *            // Refresh the access token
     *            const updatedOptions = {
     *                headers: {
     *                    token: getNewToken()
     *                }
     *           };
     *
     *           // Update the defaults
     *           instance.defaults.options.merge(updatedOptions)
     *
     *           // Make a new retry
     *           return retryWithMergedOptions(updatedOptions)
     *       }
     *
     *       // No changes otherwise
     *       return response
     * })
     * ```
     */
    setAfterResponseHook(hook: AfterResponseHook): HttpClientBuilder;
    /**
     * An object representing `http`, `https` and `http2` keys for [`http.Agent`](https://nodejs.org/api/http.html#http_class_http_agent), [`https.Agent`](https://nodejs.org/api/https.html#https_class_https_agent) and [`http2wrapper.Agent`](https://github.com/szmarczak/http2-wrapper#new-http2agentoptions) instance.
     * This is necessary because a request to one protocol might redirect to another.
     * In such a scenario, Got will switch over to the right protocol agent for you.
     *
     * If a key is not present, it will default to a global agent.
     *
     * @example
     * ```
     * import HttpAgent from 'agentkeepalive'
     *
     * const { HttpsAgent } = HttpAgent
     *
     * await HttpClient.builder()
     *    .agent({ http: new HttpAgent(), https: new HttpsAgent() })
     *    .get('https://sindresorhus.com')
     * ```
     */
    agent(agents: Agents): HttpClientBuilder;
    /**
     * Set the http2 session.
     */
    h2session(h2session: ClientHttp2Session): HttpClientBuilder;
    /**
     * Decompress the response automatically.
     *
     * This will set the `accept-encoding` header to `gzip, deflate, br` unless you set it yourself.
     *
     * If this is disabled, a compressed response is returned as a `Buffer`.
     * This may be useful if you want to handle decompression yourself or stream the raw compressed data.
     */
    decompress(decompress: boolean): HttpClientBuilder;
    /**
     * Milliseconds to wait for the server to end the response before aborting the request with `got.TimeoutError` error (a.k.a. `request` property).
     *
     * By default, there's no timeout.
     *
     * This also accepts an `object` with the following fields to constrain the duration of each phase of the request lifecycle:
     *
     * - `lookup` starts when a socket is assigned and ends when the hostname has been resolved.
     *     Does not apply when using a Unix domain socket.
     * - `connect` starts when `lookup` completes (or when the socket is assigned if lookup does not apply to the request) and ends when the socket is connected.
     * - `secureConnect` starts when `connect` completes and ends when the handshaking process completes (HTTPS only).
     * - `socket` starts when the socket is connected. See [request.setTimeout](https://nodejs.org/api/http.html#http_request_settimeout_timeout_callback).
     * - `response` starts when the request has been written to the socket and ends when the response headers are received.
     * - `send` starts when the socket is connected and ends with the request has been written to the socket.
     * - `request` starts when the request is initiated and ends when the response's end event fires.
     */
    timeout(delays: number | Delays): HttpClientBuilder;
    /**
     * Set the request body.
     */
    body(body: Body): HttpClientBuilder;
    /**
     * Set the request form.
     */
    form(form: any | Record<string, any>): HttpClientBuilder;
    /**
     * Set a header at the request.
     */
    header(key: string, value: string): HttpClientBuilder;
    /**
     * Set a header at the request only if is not already
     * defined.
     */
    safeHeader(key: string, value: string): HttpClientBuilder;
    /**
     * Remove a header from the request.
     */
    removeHeader(key: string): HttpClientBuilder;
    /**
     * When specified, `prefixUrl` will be prepended to `url`.
     * The prefix can be any valid URL, either relative or absolute.
     * A trailing slash `/` is optional - one will be added automatically.
     *
     * __Note__: `prefixUrl` will be ignored if the `url` argument is a URL instance.
     *
     * __Note__: Leading slashes in `input` are disallowed when using this option to enforce consistency and avoid confusion.
     * For example, when the prefix URL is `https://example.com/foo` and the input is `/bar`, there's ambiguity whether the resulting URL would become `https://example.com/foo/bar` or `https://example.com/bar`.
     * The latter is used by browsers.
     *
     * __Tip__: Useful when used with `got.extend()` to create niche-specific Got instances.
     *
     * __Tip__: You can change `prefixUrl` using hooks as long as the URL still includes the `prefixUrl`.
     * If the URL doesn't include it anymore, it will throw.
     *
     * @example
     * ```
     * await HttpClient.builder()
     *    .prefixUrl('https://cats.com')
     *    .get('unicorn')
     *    .json()
     * //=> 'https://cats.com/unicorn'
     * ```
     */
    prefixUrl(prefixUrl: string): HttpClientBuilder;
    /**
     * Set the request method.
     */
    method(method: Method): HttpClientBuilder;
    /**
     * Set the request url.
     */
    url(url: string | URL): HttpClientBuilder;
    /**
     * Cookie support. You don't have to care about parsing or how to store them.
     *
     * __Note__: If you provide this option, `options.headers.cookie` will be overridden.
     */
    cookieJar(jar: PromiseCookieJar | ToughCookieJar): HttpClientBuilder;
    /**
     * You can abort the `request` using [`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController).
     *
     * Requires Node.js 16 or later.*
     *
     * @example
     * ```
     * const abortController = new AbortController();
     *
     * const request = HttpClient.builder()
     *   .signal(abortController.signal)
     *   .get('https://httpbin.org/anything')
     *
     * setTimeout(() => {
     *     abortController.abort();
     * }, 100);
     * ```
     */
    signal(signal: any): HttpClientBuilder;
    /**
     * Ignore invalid cookies instead of throwing an error.
     * Only useful when the `cookieJar` option has been set. Not recommended.
     */
    ignoreInvalidCookies(ignore: boolean): HttpClientBuilder;
    /**
     * Query string that will be added to the request URL.
     * This will override the query string in `url`.
     *
     * If you need to pass in an array, you can do it using a `URLSearchParams` instance.
     *
     * @example
     * ```
     * await HttpClient.builder()
     *    .searchParams(new URLSearchParams([['key', 'a'], ['key', 'b']]))
     *    .get('https://example.com')
     *
     * console.log(searchParams.toString());
     * //=> 'key=a&key=b'
     * ```
     */
    searchParams(value: Query): HttpClientBuilder;
    /**
     * Alias for the searchParams method.
     */
    queryParams(value: Query): HttpClientBuilder;
    /**
     * Set the dnsLookup parameter.
     */
    dnsLookup(lookup: CacheableLookup['lookup']): HttpClientBuilder;
    /**
     * An instance of [`CacheableLookup`](https://github.com/szmarczak/cacheable-lookup) used for making DNS lookups.
     * Useful when making lots of requests to different *public* hostnames.
     *
     * `CacheableLookup` uses `dns.resolver4(..)` and `dns.resolver6(...)` under the hood and fall backs to `dns.lookup(...)` when the first two fail, which may lead to additional delay.
     *
     * __Note__: This should stay disabled when making requests to internal hostnames such as `localhost`, `database.local` etc.
     */
    dnsCache(cache: CacheableLookup | boolean): HttpClientBuilder;
    /**
     * User data. `context` is shallow merged and enumerable. If it contains non-enumerable properties they will NOT be merged.
     *
     * @example
     * ```
     * HttpClient.builder()
     *    .setBeforeRequestHook(options => {
     *      if (!options.context || !options.context.token) {
     *          throw new Error('Token required')
     *      }
     *
     *     options.headers.token = options.context.token
     *    })
     *
     * const response = await HttpClient.builder()
     *     .context({ token: 'secret' })
     *     .get('https://httpbin.org/headers')
     *
     * // Let's see the headers
     * console.log(response.body)
     * ```
     */
    context(context: any | Record<string, unknown>): HttpClientBuilder;
    /**
     * Hooks allow modifications during the request lifecycle.
     * Hook functions may be async and are run serially.
     */
    hooks(hooks: Hooks): HttpClientBuilder;
    /**
     * Defines if redirect responses should be followed automatically.
     *
     * Note that if a `303` is sent by the server in response to any request type (`POST`, `DELETE`, etc.), Got will automatically request the resource pointed to in the location header via `GET`.
     * This is in accordance with [the spec](https://tools.ietf.org/html/rfc7231#section-6.4.4). You can optionally turn on this behavior also for other redirect codes - see `methodRewriting`.
     */
    followRedirect(followRedirect: boolean): HttpClientBuilder;
    /**
     * Defines if redirect responses should be followed automatically.
     *
     * Note that if a `303` is sent by the server in response to any request type (`POST`, `DELETE`, etc.), Got will automatically request the resource pointed to in the location header via `GET`.
     * This is in accordance with [the spec](https://tools.ietf.org/html/rfc7231#section-6.4.4). You can optionally turn on this behavior also for other redirect codes - see `methodRewriting`.
     */
    followRedirects(followRedirect: boolean): HttpClientBuilder;
    /**
     * If exceeded, the request will be aborted and a `MaxRedirectsError` will be thrown.
     */
    maxRedirects(maxRedirects: number): HttpClientBuilder;
    /**
     * A cache adapter instance for storing cached response data.
     */
    cache(cache: string | Store<any> | boolean): HttpClientBuilder;
    /**
     * Determines if a `got.HTTPError` is thrown for unsuccessful responses.
     *
     * If this is disabled, requests that encounter an error status code will be resolved with the `response` instead of throwing.
     * This may be useful if you are checking for resource availability and are expecting error responses.
     */
    throwHttpErrors(throwHttpErrors: boolean): HttpClientBuilder;
    /**
     * Set the username.
     */
    username(value: string): HttpClientBuilder;
    /**
     * Set the password.
     */
    password(value: string): HttpClientBuilder;
    /**
     * If set to `true`, Got will additionally accept HTTP2 requests.
     *
     * It will choose either HTTP/1.1 or HTTP/2 depending on the ALPN protocol.
     *
     * __Note__: This option requires Node.js 15.10.0 or newer as HTTP/2 support on older Node.js versions is very buggy.
     *
     * __Note__: Overriding `options.request` will disable HTTP2 support.
     *
     * @example
     * ```
     * const {headers} = await HttpClient.builder()
     *    .http2(true)
     *    .get('https://nghttp2.org/httpbin/anything')
     *
     * console.log(headers.via)
     * //=> '2 nghttpx'
     * ```
     */
    http2(value: boolean): HttpClientBuilder;
    /**
     * Set this to `true` to allow sending body for the `GET` method.
     * However, the [HTTP/2 specification](https://tools.ietf.org/html/rfc7540#section-8.1.3) says that `An HTTP GET request includes request header fields and no payload body`, therefore when using the HTTP/2 protocol this option will have no effect.
     * This option is only meant to interact with non-compliant servers when you have no other choice.
     *
     * __Note__: The [RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.3.1) doesn't specify any particular behavior for the GET method having a payload, therefore __it's considered an [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern)__.
     */
    allowGetBody(value: boolean): HttpClientBuilder;
    /**
     * Specifies if the HTTP request method should be [rewritten as `GET`](https://tools.ietf.org/html/rfc7231#section-6.4) on redirects.
     *
     * As the [specification](https://tools.ietf.org/html/rfc7231#section-6.4) prefers to rewrite the HTTP method only on `303` responses, this is Got's default behavior.
     * Setting `methodRewriting` to `true` will also rewrite `301` and `302` responses, as allowed by the spec. This is the behavior followed by `curl` and browsers.
     *
     * __Note__: Got never performs method rewriting on `307` and `308` responses, as this is [explicitly prohibited by the specification](https://www.rfc-editor.org/rfc/rfc7231#section-6.4.7).
     */
    methodRewriting(value: boolean): HttpClientBuilder;
    /**
     * Indicates which DNS record family to use.
     *
     * Values:
     * - `undefined`: IPv4 (if present) or IPv6
     * - `4`: Only IPv4
     * - `6`: Only IPv6
     */
    dnsLookupIpVersion(dns: DnsLookupIpVersion): HttpClientBuilder;
    /**
     * A function used to parse JSON responses.
     *
     * @example
     * ```
     * import Bourne from '@hapi/bourne'
     *
     * const parsed = await HttpClient.builder()
     *    .url('https://example.com')
     *    .parseJson(text => Bourne.parse(text))
     *    .request()
     *    .json()
     *
     * console.log(parsed)
     * ```
     */
    parseJson(fn: ParseJsonFunction): HttpClientBuilder;
    /**
     * A function used to stringify the body of JSON requests.
     *
     * @example
     * ```
     * await HttpClient.builder()
     *  .method('POST')
     *  .url('https://example.com')
     *  .body({ some: 'payload', _ignoreMe: 1234 })
     *  .stringifyJson(object => JSON.stringify(object, (key, value) => {
     *     if (key.startsWith('_')) {
     *         return
     *     }
     *
     *     return value
     *  }))
     *  .request()
     * ```
     */
    stringifyJson(fn: StringifyJsonFunction): HttpClientBuilder;
    /**
     * An object representing `limit`, `calculateDelay`, `methods`, `statusCodes`, `maxRetryAfter` and `errorCodes` fields for maximum retry count, retry handler, allowed methods, allowed status codes, maximum [`Retry-After`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After) time and allowed error codes.
     *
     * Delays between retries counts with function `1000 * Math.pow(2, retry) + Math.random() * 100`, where `retry` is attempt number (starts from 1).
     *
     * The `calculateDelay` property is a `function` that receives an object with `attemptCount`, `retryOptions`, `error` and `computedValue` properties for current retry count, the retry options, error and default computed value.
     * The function must return a delay in milliseconds (or a Promise resolving with it) (`0` return value cancels retry).
     *
     * By default, it retries *only* on the specified methods, status codes, and on these network errors:
     *
     * - `ETIMEDOUT`: One of the [timeout](#timeout) limits were reached.
     * - `ECONNRESET`: Connection was forcibly closed by a peer.
     * - `EADDRINUSE`: Could not bind to any free port.
     * - `ECONNREFUSED`: Connection was refused by the server.
     * - `EPIPE`: The remote side of the stream being written has been closed.
     * - `ENOTFOUND`: Couldn't resolve the hostname to an IP address.
     * - `ENETUNREACH`: No internet connection.
     * - `EAI_AGAIN`: DNS lookup timed out.
     *
     * __Note__: If `maxRetryAfter` is set to `undefined`, it will use `options.timeout`.
     * __Note__: If [`Retry-After`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After) header is greater than `maxRetryAfter`, it will cancel the request.
     */
    retry(retry: Partial<RetryOptions>): HttpClientBuilder;
    /**
     * This method is just an alias to configure your own retry strategy.
     *
     * The strategy function needs to return the delay between the execution count
     * of each request, if the strategy function returns 0, the retry is canceled.
     */
    retryStrategy(strategy: RetryStrategyCallback): HttpClientBuilder;
    /**
     * From `http.RequestOptions`.
     *
     * The IP address used to send the request from.
     */
    localAddress(localAddress: string): HttpClientBuilder;
    /**
     * Set the createConnection options.
     */
    createConnection(value: CreateConnectionFunction): HttpClientBuilder;
    /**
     * Options for the advanced HTTPS API.
     */
    https(https: HttpsOptions): HttpClientBuilder;
    /**
     * [Encoding](https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings) to be used on `setEncoding` of the response data.
     *
     * To get a [`Buffer`](https://nodejs.org/api/buffer.html), you need to set `responseType` to `buffer` instead.
     * Don't set this option to `null`.
     *
     * __Note__: This doesn't affect streams! Instead, you need to do `got.stream(...).setEncoding(encoding)`.
     */
    encoding(encoding: BufferEncoding): HttpClientBuilder;
    /**
     *  When set to `true` the promise will return the
     *  Response body instead of the Response object.
     */
    resolveBodyOnly(resolveBodyOnly: boolean): HttpClientBuilder;
    /**
     * The parsing method.
     *
     * The promise also has `.text()`, `.json()` and `.buffer()` methods which return another Got promise for the parsed body.
     *
     * It's like setting the options to `{responseType: 'json', resolveBodyOnly: true}` but without affecting the main Got promise.
     *
     * __Note__: When using streams, this option is ignored.
     *
     * @example
     * ```
     * const responsePromise = HttpClient.get(url);
     * const bufferPromise = responsePromise.buffer();
     * const jsonPromise = responsePromise.json();
     *
     * const [response, buffer, json] = Promise.all([responsePromise, bufferPromise, jsonPromise]);
     * // `response` is an instance of Got Response
     * // `buffer` is an instance of Buffer
     * // `json` is an object
     * ```
     *
     * @example
     * ```
     * // This
     * const body = await HttpClient.get(url).json();
     *
     * // is semantically the same as this
     * const body = await HttpClient.get(url, { responseType: 'json', resolveBodyOnly: true })
     * ```
     */
    responseType(type: ResponseType): HttpClientBuilder;
    /**
     * Set pagination options.
     */
    pagination<ElementType = any, BodyType = any>(options: PaginationOptions<ElementType, BodyType>): HttpClientBuilder;
    /**
     * Set the host option.
     */
    setHost(value: boolean): HttpClientBuilder;
    /**
     * Set the maxHeaderSize option.
     */
    maxHeaderSize(maxHeaderSize: number): HttpClientBuilder;
    /**
     * Set the enableUnixSockets option.
     */
    enableUnixSockets(enableUnixSockets: boolean): HttpClientBuilder;
    /**
     * Set the merge options.
     */
    mergeOptions(options: Request): HttpClientBuilder;
    /**
     * Execute the request and return as stream.
     */
    stream(options?: Request): GotRequest;
    /**
     * Execute the request and return paginated data.
     */
    paginate<T = any>(options?: Request): AsyncIterableIterator<T>;
    /**
     * Execute the request using all the options defined.
     */
    request<T = any>(options?: Request): Response<T>;
    /**
     * Make a GET request.
     */
    get<T = any>(url?: string | URL, options?: Request): Response<T>;
    /**
     * Make a POST request.
     */
    post<T = any>(url?: string | URL, body?: Body, options?: Request): Response<T>;
    /**
     * Make a PUT request.
     */
    put<T = any>(url?: string | URL, body?: Body, options?: Request): Response<T>;
    /**
     * Make a PATCH request.
     */
    patch<T = any>(url?: string | URL, body?: Response, options?: Request): Response<T>;
    /**
     * Make a DELETE request.
     */
    delete<T = any>(url?: string | URL, options?: Request): Response<T>;
    /**
     * Make a HEAD request.
     */
    head<T = any>(url?: string | URL, options?: Request): Response<T>;
}
export declare class HttpClient {
    /**
     * The global builder used in all HttpClient static requests.
     */
    private static _builder;
    /**
     * Set the global builder for HttpClient.
     */
    static setBuilder(builder: HttpClientBuilder): typeof HttpClient;
    /**
     * Uses the instance of HttpClientBuilder or creates
     * a new one.
     */
    static builder(newBuilder?: boolean): HttpClientBuilder;
    /**
     * Make a GET request.
     */
    static get<T = any>(url?: string | URL, options?: Request): Response<T>;
    /**
     * Make a POST request.
     */
    static post<T = any>(url?: string | URL, body?: Body, options?: Request): Response<T>;
    /**
     * Make a PUT request.
     */
    static put<T = any>(url?: string | URL, body?: Body, options?: Request): Response<T>;
    /**
     * Make a PATCH request.
     */
    static patch<T = any>(url?: string | URL, body?: Body, options?: Request): Response<T>;
    /**
     * Make a DELETE request.
     */
    static delete<T = any>(url?: string | URL, options?: Request): Response<T>;
    /**
     * Make a HEAD request.
     */
    static head<T = any>(url?: string | URL, options?: Request): Response<T>;
}
