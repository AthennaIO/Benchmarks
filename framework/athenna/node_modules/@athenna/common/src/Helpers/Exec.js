/**
 * @athenna/common
 *
 * (c) Jo√£o Lenon <lenon@athenna.io>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
import { promisify } from 'node:util';
import { Transform } from 'node:stream';
import { File } from '#src/Helpers/File';
import { Uuid } from '#src/Helpers/Uuid';
import { Options } from '#src/Helpers/Options';
import { request as requestHttp } from 'node:http';
import { request as requestHttps } from 'node:https';
import { exec as childProcessExec } from 'node:child_process';
import { NodeCommandException } from '#src/Exceptions/NodeCommandException';
const exec = promisify(childProcessExec);
export class Exec {
    /**
     * Sleep the code in the line that this function
     * is being called.
     */
    static async sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    /**
     * Execute some callback concurrently in all values of the array.
     */
    static async concurrently(array, callback) {
        return Promise.all(array.map(callback));
    }
    /**
     * Execute a command of child process exec as promise.
     */
    static async command(command, options) {
        options = Options.create(options, {
            ignoreErrors: false,
        });
        try {
            const execOptions = {};
            if (process.platform === 'win32' && Uuid.verify(process.env.WT_SESSION)) {
                execOptions.shell = 'powershell';
            }
            // Needs to await explicit because of try catch
            return await exec(command, execOptions);
        }
        catch (error) {
            if (options.ignoreErrors) {
                return { stdout: error.stdout, stderr: error.stderr };
            }
            throw new NodeCommandException(command, error);
        }
    }
    /**
     * Download an archive to determined path.
     */
    static async download(name, path, url) {
        return new Promise((resolve, reject) => {
            const callback = response => {
                const data = new Transform();
                response.on('data', chunk => data.push(chunk));
                response.on('end', function () {
                    resolve(new File(`${path}/${name}`, data.read()).loadSync());
                });
                response.on('error', error => reject(error));
            };
            if (url.includes('https')) {
                requestHttps(url, callback).end();
                return;
            }
            requestHttp(url, callback).end();
        });
    }
    /**
     * Paginate a collection of data.
     */
    static pagination(data, total, pagination) {
        pagination = Options.create(pagination, {
            page: 0,
            limit: 10,
            resourceUrl: '/',
        });
        const totalPages = Math.ceil(total / pagination.limit);
        const meta = {
            itemCount: data.length,
            totalItems: total,
            totalPages,
            currentPage: pagination.page,
            itemsPerPage: pagination.limit,
        };
        let nextPage = 1;
        let previousPage = 0;
        if (meta.currentPage && meta.currentPage < meta.totalPages) {
            nextPage = meta.currentPage + 1;
            previousPage = meta.currentPage - 1;
        }
        const links = {
            first: `${pagination.resourceUrl}?limit=${meta.itemsPerPage}`,
            previous: `${pagination.resourceUrl}?page=${previousPage}&limit=${meta.itemsPerPage}`,
            next: `${pagination.resourceUrl}?page=${nextPage}&limit=${meta.itemsPerPage}`,
            last: `${pagination.resourceUrl}?page=${totalPages}&limit=${meta.itemsPerPage}`,
        };
        return { meta, links, data };
    }
}
