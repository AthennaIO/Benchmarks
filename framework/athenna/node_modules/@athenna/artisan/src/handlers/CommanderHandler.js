/**
 * @athenna/artisan
 *
 * (c) Jo√£o Lenon <lenon@athenna.io>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
import { Commander } from '#src/artisan/Commander';
import { Formatter } from '#src/helpers/Formatter';
export class CommanderHandler {
    /**
     * The commander instance.
     */
    static { this.commander = this.instantiate(); }
    /**
     * Get a new commander instance with default options.
     */
    static instantiate() {
        return new Commander()
            .addHelpCommand('help [command]', 'Display help for [command]')
            .usage('[command] [arguments] [options]')
            .option('--env <env>', 'The environment the command should run under.', Env('APP_ENV') || Env('NODE_ENV'))
            .configureHelp({
            sortSubcommands: true,
            showGlobalOptions: true,
            formatHelp: (cmd, helper) => Formatter.builder(cmd, helper)
                .setUsage()
                .setDescription()
                .setArguments()
                .setOptions()
                .setCommands()
                .setGlobalOptions()
                .getOutput()
        });
    }
    /**
     * Simple helper to reconstruct the commander instance.
     */
    static reconstruct() {
        CommanderHandler.commander = this.instantiate();
    }
    /**
     * Parse the command called in the console and execute.
     */
    static async parse(argv) {
        return CommanderHandler.commander.parseAsync(argv);
    }
    /**
     * Bind the exception handler if exists inside the action.
     */
    static bindHandler(target) {
        if (!CommanderHandler.exceptionHandler) {
            return (...args) => target.__exec.bind(target)(...args);
        }
        return (...args) => target.__exec
            .bind(target)(...args)
            .catch(CommanderHandler.exceptionHandler);
    }
    /**
     * Set the CLI version. By default, the version set will be of the Athenna.
     */
    static setVersion(version) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        if (CommanderHandler.commander._events['option:version']) {
            return this;
        }
        if (version) {
            CommanderHandler.commander.version(version, '-v, --version', 'Output the application version.');
            return this;
        }
        CommanderHandler.commander.version('Athenna Framework v3.0.0', '-v, --version', 'Output the framework version.');
        return this;
    }
    /**
     * Get the arguments of a command.
     */
    static getCommandArgs(name) {
        const commander = this.getCommand(name);
        return commander._args;
    }
    /**
     * Get the options of a command.
     */
    static getCommandOpts(name) {
        const commander = this.getCommand(name);
        return commander.options;
    }
    /**
     * Get the option values of a command.
     */
    static getCommandOptsValues(name) {
        const commander = this.getCommand(name);
        return commander.optsWithGlobals();
    }
    /**
     * Get specific command my signature.
     */
    static getCommand(signature) {
        return CommanderHandler.getCommands().find((command) => command._name === signature);
    }
    /**
     * Get all commands registered inside commander.
     */
    static getCommands() {
        return CommanderHandler.commander.commands;
    }
    /**
     * Verify if the actual commander instance has a command
     * with the given signature.
     */
    static hasCommand(signature) {
        return !!CommanderHandler.commander.commands.find((command) => command._name === signature);
    }
    /**
     * Get commands with arguments and descriptions registered inside commander.
     */
    static getCommandsInfo(alias) {
        const commands = {};
        CommanderHandler.getCommands().forEach((command) => {
            if (alias && !command._name.startsWith(`${alias}:`)) {
                return;
            }
            let name = command._name;
            if (command.options.length) {
                name = `${name} [options]`;
            }
            command._args.forEach(arg => {
                if (arg.required) {
                    name = name.concat(` <${arg._name}>`);
                    return;
                }
                name = name.concat(` [${arg._name}]`);
            });
            commands[name] = command._description;
        });
        return commands;
    }
}
