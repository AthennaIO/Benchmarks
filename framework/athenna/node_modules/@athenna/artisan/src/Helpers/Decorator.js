/**
 * @athenna/artisan
 *
 * (c) Jo√£o Lenon <lenon@athenna.io>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
import 'reflect-metadata';
import { String } from '@athenna/common';
import { Commander } from '#src/artisan/Commander';
import { CommanderHandler } from '#src/handlers/CommanderHandler';
class Decorator {
    static { this.OPTIONS_KEY = 'artisan:options'; }
    static { this.ARGUMENTS_KEY = 'artisan:arguments'; }
    static { this.COMMANDER_KEY = 'artisan:commander'; }
    static getCommander(target) {
        if (Reflect.hasMetadata(this.COMMANDER_KEY, target)) {
            return Reflect.getMetadata(this.COMMANDER_KEY, target);
        }
        const Target = target.constructor;
        const commander = CommanderHandler.getCommander();
        const command = commander
            .command(Target.signature())
            .description(Target.description());
        Reflect.defineMetadata(this.COMMANDER_KEY, command, target);
        return Reflect.getMetadata(this.COMMANDER_KEY, target);
    }
    static setOption(target, key, options) {
        let signatureOption = '';
        if (options.signature.includes('--')) {
            signatureOption = options.signature.split('--')[1];
        }
        if (signatureOption.startsWith('no-')) {
            signatureOption = signatureOption.split('no-')[1];
        }
        signatureOption = signatureOption
            .replace(/<([^)]+)>/g, '')
            .replace(/\[([^)]+)]/g, '')
            .replace(/ /g, '');
        signatureOption = String.toCamelCase(signatureOption);
        if (!Reflect.hasMetadata(this.OPTIONS_KEY, target)) {
            Reflect.defineMetadata(this.OPTIONS_KEY, { [signatureOption]: key }, target);
        }
        const metaOptions = Reflect.getMetadata(this.OPTIONS_KEY, target);
        if (metaOptions.signature === signatureOption) {
            return this;
        }
        metaOptions[signatureOption] = key;
        Reflect.defineMetadata(key, metaOptions, target);
        this.getCommander(target).option(options.signature, options.description, options.default);
        return this;
    }
    static setArgument(target, argument, options) {
        if (!Reflect.hasMetadata(this.ARGUMENTS_KEY, target)) {
            Reflect.defineMetadata(this.ARGUMENTS_KEY, [], target);
        }
        const args = Reflect.getMetadata(this.ARGUMENTS_KEY, target);
        if (args.includes(argument)) {
            return this;
        }
        args.push(argument);
        Reflect.defineMetadata(this.ARGUMENTS_KEY, args, target);
        this.getCommander(target).argument(options.signature, options.description, options.default);
        return this;
    }
    static getOptions(target) {
        return Reflect.getMetadata(this.OPTIONS_KEY, target) || {};
    }
    static getArguments(target) {
        return Reflect.getMetadata(this.ARGUMENTS_KEY, target) || [];
    }
}
export { Decorator };
