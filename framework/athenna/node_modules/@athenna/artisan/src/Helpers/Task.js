/**
 * @athenna/artisan
 *
 * (c) João Lenon <lenon@athenna.io>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
import ora, {} from 'ora';
import { Is, Color } from '@athenna/common';
import { RunningTaskException } from '#src/exceptions/RunningTaskException';
export class Task {
    constructor() {
        /**
         * The tasks saved by "add" method.
         */
        this.tasks = [];
    }
    /**
     * Add a new task to be executed.
     *
     * @example
     * ```ts
     * await this.logger
     *    .task()
     *    .add('hello', async task => {
     *      await Exec.sleep(1000)
     *      await task.complete('world')
     *    })
     *    .run()
     * ```
     * Output:
     * ```bash
     * → hello 1005ms
     *   world
     * ```
     */
    add(title, cb) {
        this.tasks.push({ title, cb });
        return this;
    }
    /**
     * Run all the tasks added.
     *
     * @example
     * ```ts
     * await this.logger
     *    .task()
     *    .add('hello', async task => {
     *      await Exec.sleep(1000)
     *      await task.fail('Something went wrong')
     *    })
     *    .run()
     * ```
     * Output:
     * ```bash
     * → hello 1005ms
     *   Something went wrong
     * ```
     */
    async run() {
        for (const task of this.tasks) {
            const nextTasksTitle = [];
            for (let i = this.tasks.indexOf(task) + 1; i <= this.tasks.length; i++) {
                const task = this.tasks[i];
                if (!task) {
                    break;
                }
                nextTasksTitle.push(task.title);
            }
            const status = await new TaskManager(task, nextTasksTitle).run();
            if (status === 'fail') {
                break;
            }
        }
    }
}
export class TaskManager {
    constructor(task, nextTasksTitle) {
        /**
         * The status of the task.
         */
        this.status = 'idle';
        this.task = task;
        this.time = Date.now();
        this.spinner = ora({
            spinner: 'arrow',
            isSilent: Config.is('logging.channels.console.driver', 'null'),
        });
        this.nextTasksTitle = nextTasksTitle
            .map(nextTaskTitle => Color.dim(`→ ${nextTaskTitle}`))
            .join('\n');
    }
    /**
     * Run the the task and return if the status was fail or
     * complete.
     */
    async run() {
        this.status = 'running';
        this.spinner.start(`${this.task.title}\n${this.nextTasksTitle}`);
        await this.task.cb(this);
        if (this.status === 'running') {
            throw new RunningTaskException(this.task.title);
        }
        return this.status;
    }
    /**
     * Complete the task by setting a red arrow and
     * persisting the task name with an error message.
     *
     * @example
     * ```ts
     * await task.fail('Something went wrong')
     * ```
     */
    async fail(error) {
        const ms = this.getMs();
        const icon = Color.red('→');
        const msg = this.getMessage(error, Color.red);
        this.spinner.stopAndPersist({
            symbol: icon,
            text: `${this.task.title} ${ms} ${msg}\n${this.nextTasksTitle}`,
        });
        this.status = 'fail';
    }
    /**
     * Complete the task by setting a green arrow and
     * persisting the task name with or without a message.
     *
     * @example
     * ```ts
     * await task.complete('Finished')
     * ```
     */
    async complete(message) {
        const ms = this.getMs();
        const icon = Color.green('→');
        const msg = this.getMessage(message, Color.dim);
        this.spinner.stopAndPersist({
            symbol: icon,
            text: `${this.task.title} ${ms}${msg}`,
        });
        this.status = 'complete';
    }
    /**
     * Get the time in MS that has been required to run the
     * task.
     */
    getMs() {
        return Color.dim(`${Date.now() - this.time}ms`);
    }
    /**
     * Get the message value painted if it exists.
     */
    getMessage(message, color) {
        if (!message) {
            return '';
        }
        if (Is.Object(message) && message.message) {
            return '\n  '.concat(color(message.message));
        }
        return '\n  '.concat(color(message));
    }
}
