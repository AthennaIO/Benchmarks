/**
 * @athenna/artisan
 *
 * (c) Jo√£o Lenon <lenon@athenna.io>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
import { Command as Commander } from 'commander';
class CommanderHandler {
    /**
     * The commander instance.
     */
    static { this.commander = new Commander(); }
    /**
     * Get the commander instance.
     */
    static getCommander() {
        return this.commander;
    }
    /**
     * Parse the command called in the console and execute.
     */
    static async parse(argv) {
        return this.commander.parseAsync(argv);
    }
    /**
     * Set the exception handler for commander action method.
     */
    static setExceptionHandler(handler) {
        this.exceptionHandler = handler;
    }
    /**
     * Bind the exception handler if exists inside the action.
     */
    static bindHandler(target) {
        if (!this.exceptionHandler) {
            return target.__exec.bind(target);
        }
        return (...args) => target.__exec
            .bind(target)(...args)
            .catch(this.exceptionHandler);
    }
    /**
     * Set the CLI version. By default, the version set will be of the Athenna.
     */
    static setVersion(version) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        if (this.commander._events['option:version']) {
            return this;
        }
        if (version) {
            this.commander.version(version, '-v, --version');
            return this;
        }
        this.commander.version('Athenna Framework v3.0.0', '-v, --version');
        return this;
    }
    /**
     * Get all commands registered inside commander or by alias.
     */
    static getCommands(alias) {
        const commands = {};
        this.commander.commands.forEach((command) => {
            if (alias && !command._name.startsWith(`${alias}:`)) {
                return;
            }
            let name = command._name;
            if (command.options.length) {
                name = `${name} [options]`;
            }
            command._args.forEach(arg => {
                if (arg.required) {
                    name = name.concat(` <${arg._name}>`);
                    return;
                }
                name = name.concat(` [${arg._name}]`);
            });
            commands[name] = command._description;
        });
        return commands;
    }
}
export { CommanderHandler };
