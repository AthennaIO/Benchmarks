/**
 * @athenna/ioc
 *
 * (c) Jo√£o Lenon <lenon@athenna.io>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
import { Ioc } from '#src/container/Ioc';
import { Facade } from '#src/facades/Facade';
import { Is, Module } from '@athenna/common';
import { PROTECTED_FACADE_METHODS } from '#src/constants/ProtectedFacadeMethods';
const require = Module.createRequire(import.meta.url);
export class FacadeProxyHandler {
    /**
     * Creates a new instance of FacadeProxyHandler.
     */
    constructor(container, facadeAccessor) {
        this.container = container;
        this.facadeAccessor = facadeAccessor;
    }
    /**
     * Get the facade alias registered to resolve deps
     * from the Ioc.
     */
    getFacadeAlias() {
        return this.facadeAccessor;
    }
    /**
     * Get the facade provider resolved from the Ioc.
     */
    getFacadeProvider() {
        return this.container.safeUse(this.facadeAccessor);
    }
    /**
     * Set a fake return value in the Facade method.
     */
    fakeMethod(method, returnValue) {
        this.container.fakeMethod(this.facadeAccessor, method, returnValue);
        return this;
    }
    /**
     * Restore the mocked method to his default state.
     */
    restoreMethod(method) {
        this.container.restoreMethod(this.facadeAccessor, method);
        return this;
    }
    /**
     * Restore all the mocked methods of this facade to
     * their default state.
     */
    restoreAllMethods() {
        this.container.restoreAllMethods(this.facadeAccessor);
        return this;
    }
    /**
     * Return a sinon mock instance.
     */
    getMock() {
        const sinon = require('sinon');
        this.mockedProvider = this.getFacadeProvider();
        return new Proxy(sinon.mock(this.mockedProvider), {
            get: (mock, method) => {
                if (method === 'verify') {
                    this.mockedProvider = null;
                }
                return mock[method];
            },
        });
    }
    /**
     * Method called by Proxy everytime a new property is called.
     */
    get(facade, key) {
        if (PROTECTED_FACADE_METHODS.includes(key)) {
            return this[key].bind(this);
        }
        if (this.mockedProvider) {
            return this.mockedProvider[key];
        }
        return this.__callStatic(facade, key);
    }
    /**
     * Returns the provider method with a Proxy applied in apply.
     * This way we guarantee that we are working with
     * the same instance when a Facade method returns this.
     */
    __callStatic(facade, key) {
        const provider = facade.container.safeUse(this.facadeAccessor);
        if (provider[key] === undefined) {
            return undefined;
        }
        if (!Is.Function(provider[key])) {
            return provider[key];
        }
        return new Proxy(provider[key], {
            apply: (method, _this, args) => method.bind(provider)(...args),
        });
    }
}
