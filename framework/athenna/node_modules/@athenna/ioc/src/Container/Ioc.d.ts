/**
 * @athenna/ioc
 *
 * (c) Jo√£o Lenon <lenon@athenna.io>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
import { type Resolver, type AwilixContainer, type RegistrationHash, type ContainerOptions } from 'awilix';
import type { LoadModuleOptions } from '#src';
export declare class Ioc {
    /**
     * Hold all the services that are fakes. The fake
     * services will never be replaced if its alias
     * exists here.
     */
    static fakes: string[];
    /**
     * The awilix container instance.
     */
    static container: AwilixContainer;
    /**
     * Creates a new instance of IoC.
     */
    constructor(options?: ContainerOptions);
    /**
     * Reconstruct the awilix container and fakes.
     */
    reconstruct(options?: ContainerOptions): Ioc;
    /**
     * List all bindings of the Ioc.
     */
    list(): RegistrationHash;
    /**
     * Return the registration of the service.
     */
    getRegistration<T = any>(alias: string): Resolver<T>;
    /**
     * Resolve a service from the container or
     * returns undefined if not found.
     */
    use<T = any>(alias: string): T;
    /**
     * Resolve a service from the container or
     * throws exception if not found.
     */
    safeUse<T = any>(alias: string): T;
    /**
     * Register an alias to another service alias.
     */
    alias(subAlias: string, originalAlias: string): Ioc;
    /**
     * Bind a transient service to the container.
     * Transient services will always resolve a new
     * instance of it every time you (or Athenna internally)
     * call ".use" or ".safeUse" method.
     */
    bind(alias: string, service: any): Ioc;
    /**
     * Bind a transient service to the container.
     * Transient services will always resolve a new
     * instance of it every time you (or Athenna internally)
     * call ".use" or ".safeUse" method.
     */
    transient(alias: string, service: any): Ioc;
    /**
     * Bind an instance service to the container.
     * Instance services have the same behavior of
     * singleton services, but you will have more control
     * on how you want to create your service constructor.
     */
    instance(alias: string, service: any): Ioc;
    /**
     * Bind a singleton service to the container.
     * Singleton services will always resolve the same
     * instance of it every time you (or Athenna internally)
     * call ".use" or ".safeUse" method.
     */
    singleton(alias: string, service: any): Ioc;
    /**
     * Bind a fake service to the container.
     * Fake services will not let the container
     * re-register the service alias until you call
     * "ioc.unfake()" method.
     */
    fake(alias: string, service: any): Ioc;
    /**
     * Remove the fake service from fakes map.
     */
    unfake(alias: string): Ioc;
    /**
     * Remove all fake services from fakes array.
     */
    clearAllFakes(): Ioc;
    /**
     * Verify if service alias is fake or not.
     */
    isFaked(alias: string): boolean;
    /**
     * Verify if the container has the service or not.
     */
    has(alias: string): boolean;
    /**
     * Import and register a module found in the determined
     * path.
     */
    loadModule(path: string, options?: LoadModuleOptions): Promise<void>;
    /**
     * Import and register all the files found in all
     * the determined paths.
     */
    loadModules(paths: string[], options?: LoadModuleOptions): Promise<void>;
    /**
     * Get the Awilix binder based on the type of the
     * service.
     */
    private getAwilixBinder;
    /**
     * Register the binder in the Awilix container.
     */
    private register;
}
