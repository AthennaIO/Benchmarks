/**
 * @athenna/ioc
 *
 * (c) JoÃ£o Lenon <lenon@athenna.io>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
import { aliasTo, asClass, asValue, asFunction, InjectionMode, createContainer, } from 'awilix';
import { String, Options, Is } from '@athenna/common';
import { ProviderFaker } from '#src/Helpers/ProviderFaker';
import { NotFoundDependencyException } from '#src/Exceptions/NotFoundDependencyException';
class Ioc {
    /**
     * Hold all the dependencies that are fakes. The fake
     * dependencies will never be replaced if its alias exists here.
     */
    static fakes = [];
    /**
     * The awilix container instance.
     */
    static container;
    /**
     * Creates a new instance of IoC.
     */
    constructor(options) {
        if (Ioc.container) {
            return this;
        }
        this.reconstruct(options);
    }
    /**
     * Reconstruct the awilix container and mocks.
     */
    reconstruct(options) {
        options = Options.create(options, { injectionMode: InjectionMode.CLASSIC });
        Ioc.fakes = [];
        Ioc.container = createContainer(options);
        return this;
    }
    /**
     * List all bindings of the Ioc.
     */
    list() {
        return Ioc.container.registrations;
    }
    /**
     * Return the registration of the dependency.
     */
    getRegistration(alias) {
        const registration = Ioc.container.getRegistration(alias);
        registration.hasCamelAlias = false;
        if (alias.includes('/')) {
            const aliasOfAlias = alias.split('/').pop();
            if (Ioc.container.hasRegistration(String.toCamelCase(aliasOfAlias))) {
                registration.hasCamelAlias = true;
            }
        }
        return registration;
    }
    /**
     * Resolve a service provider from the container or
     * returns undefined if not found.
     */
    use(alias) {
        return Ioc.container.resolve(alias, { allowUnregistered: true });
    }
    /**
     * Resolve a service provider from the container or
     * throws exception if not found.
     */
    safeUse(alias) {
        if (!this.hasDependency(alias)) {
            throw new NotFoundDependencyException(alias);
        }
        return Ioc.container.resolve(alias);
    }
    /**
     * Register and alias to other dependency alias of the
     * container.
     */
    alias(alias, dependencyAlias) {
        if (!this.hasDependency(dependencyAlias)) {
            throw new NotFoundDependencyException(dependencyAlias);
        }
        Ioc.container.register(alias, aliasTo(dependencyAlias));
        return this;
    }
    /**
     * Bind a transient dependency to the container.
     * Transient dependencies will always resolve a new
     * instance of it everytime you (or Athenna internally)
     * call ".use" or ".safeUse" method.
     */
    bind(alias, dependency, createCamelAlias = true) {
        this.register(alias, dependency, { type: 'transient', createCamelAlias });
        return this;
    }
    /**
     * Bind a transient dependency to the container.
     * Transient dependencies will always resolve a new
     * instance of it everytime you (or Athenna internally)
     * call ".use" or ".safeUse" method.
     */
    transient(alias, dependency, createCamelAlias = true) {
        this.register(alias, dependency, { type: 'transient', createCamelAlias });
        return this;
    }
    /**
     * Bind a scoped dependency to the container.
     */
    scoped(alias, dependency, createCamelAlias = true) {
        this.register(alias, dependency, { type: 'scoped', createCamelAlias });
        return this;
    }
    /**
     * Bind an instance dependency to the container.
     * Instance dependencies have the same behavior of
     * singleton dependencies, but you will have more control
     * on how you want to create your dependency constructor.
     */
    instance(alias, dependency, createCamelAlias = true) {
        this.register(alias, dependency, { type: 'singleton', createCamelAlias });
        return this;
    }
    /**
     * Bind a singleton dependency to the container.
     * Singleton dependencies will always resolve the same
     * instance of it everytime you (or Athenna internally)
     * call ".use" or ".safeUse" method.
     */
    singleton(alias, dependency, createCamelAlias = true) {
        this.register(alias, dependency, { type: 'singleton', createCamelAlias });
        return this;
    }
    /**
     * Bind a fake dependency to the container.
     * Fake dependencies will not let the container
     * register the dependencies until you call ".unfake"
     * method.
     */
    fake(alias, dependency, createCamelAlias = true) {
        this.register(alias, dependency, { type: 'singleton', createCamelAlias });
        Ioc.fakes.push(alias);
        return this;
    }
    /**
     * Remove the fake dependency from fakes map.
     */
    unfake(alias) {
        const index = Ioc.fakes.indexOf(alias);
        if (index > -1) {
            Ioc.fakes.splice(index, 1);
        }
        return this;
    }
    /**
     * Remove all fake dependencies from fakes map.
     */
    clearAllFakes() {
        Ioc.fakes = [];
        return this;
    }
    /**
     * Verify if dependency alias is fake or not.
     */
    isFaked(alias) {
        return Ioc.fakes.includes(alias);
    }
    /**
     * Register a fake method to the dependency.
     */
    fakeMethod(alias, method, returnValue) {
        ProviderFaker.fakeMethod(alias, method, returnValue);
        return this;
    }
    /**
     * Restore the dependency method to the default state.
     */
    restoreMethod(alias, method) {
        ProviderFaker.restoreMethod(alias, method);
        return this;
    }
    /**
     * Restore all the dependency methods to the default state.
     */
    restoreAllMethods(alias) {
        ProviderFaker.restoreAllMethods(alias);
        return this;
    }
    /**
     * Verify if the container has the dependency or not.
     */
    hasDependency(alias) {
        return Ioc.container.hasRegistration(alias);
    }
    /**
     * Get the Awilix binder based on the type of the
     * dependency.
     */
    getAwilixBinder(type, dependency) {
        if (Is.Class(dependency)) {
            return asClass(dependency)[type]();
        }
        if (Is.Function(dependency)) {
            return asFunction(dependency)[type]();
        }
        return asValue(dependency);
    }
    /**
     * Register the binder in the Awilix container.
     */
    register(alias, dependency, options) {
        if (this.isFaked(alias)) {
            return;
        }
        options = Options.create(options, {
            type: 'transient',
            createCamelAlias: true,
        });
        /**
         * Saving the logic inside the function to reuse the code
         * for promises and no promises dependencies.
         */
        const register = dep => {
            const binder = this.getAwilixBinder(options.type, dep);
            Ioc.container.register(alias, binder);
            if (alias.includes('/') && options.createCamelAlias) {
                const aliasOfAlias = alias.split('/').pop();
                this.alias(String.toCamelCase(aliasOfAlias), alias);
            }
        };
        if (dependency && dependency.then) {
            dependency.then(dep => register(dep));
            return;
        }
        register(dependency);
    }
}
export { Ioc };
