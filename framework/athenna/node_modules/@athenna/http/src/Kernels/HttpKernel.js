/**
 * @athenna/http
 *
 * (c) Jo√£o Lenon <lenon@athenna.io>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
import 'reflect-metadata';
import { Server } from '#src';
import { Log } from '@athenna/logger';
import { Config } from '@athenna/config';
import { isAbsolute, resolve } from 'node:path';
import { File, Exec, Is, Module } from '@athenna/common';
import { HttpExceptionHandler } from '#src/Handlers/HttpExceptionHandler';
const corsPlugin = await Module.safeImport('@fastify/cors');
const helmetPlugin = await Module.safeImport('@fastify/helmet');
const swaggerPlugin = await Module.safeImport('@fastify/swagger');
const swaggerUiPlugin = await Module.safeImport('@fastify/swagger-ui');
const rateLimitPlugin = await Module.safeImport('@fastify/rate-limit');
const rTracerPlugin = await Module.safeImport('cls-rtracer');
export class HttpKernel {
    /**
     * Register the @fastify/cors plugin in the Http server.
     */
    async registerCors() {
        if (!corsPlugin) {
            return;
        }
        await Server.plugin(corsPlugin, Config.get('http.cors'));
    }
    /**
     * Register the @fastify/helmet plugin in the Http server.
     */
    async registerHelmet() {
        if (!helmetPlugin) {
            return;
        }
        await Server.plugin(helmetPlugin, Config.get('http.helmet'));
    }
    /**
     * Register the @fastify/swagger plugin in the Http server.
     */
    async registerSwagger() {
        if (swaggerPlugin) {
            await Server.plugin(swaggerPlugin, Config.get('http.swagger.configurations'));
        }
        if (swaggerUiPlugin) {
            await Server.plugin(swaggerUiPlugin, Config.get('http.swagger.ui'));
        }
    }
    /**
     * Register the @fastify/rate-limit plugin in the Http server.
     */
    async registerRateLimit() {
        if (!rateLimitPlugin) {
            return;
        }
        await Server.plugin(rateLimitPlugin, Config.get('http.rateLimit'));
    }
    /**
     * Register the cls-rtracer plugin in the Http server.
     */
    async registerRTracer() {
        if (!rTracerPlugin) {
            return;
        }
        Server.middleware(async (ctx) => (ctx.data.traceId = rTracerPlugin.id()));
        await Server.plugin(rTracerPlugin.fastifyPlugin, Config.get('http.rTracer'));
    }
    /**
     * Register the global log terminator in the Http server.
     */
    async registerLoggerTerminator() {
        if (!Config.exists('http.logger') || Config.is('http.logger', false)) {
            return;
        }
        Server.terminate(ctx => Log.channelOrVanilla('request').info(ctx));
    }
    /**
     * Register all the controllers found inside "rc.controllers" config
     * inside the service provider.
     */
    async registerControllers() {
        const controllers = Config.get('rc.controllers', []);
        await Exec.concurrently(controllers, async (path) => {
            const Controller = await this.resolvePath(path);
            if (Reflect.hasMetadata('provider:registered', Controller)) {
                return;
            }
            const createCamelAlias = false;
            const alias = `App/Http/Controllers/${Controller.name}`;
            ioc.bind(alias, Controller, createCamelAlias);
        });
    }
    /**
     * Register all the middlewares found inside "rc.middlewares" config
     * inside the service provider. Also register if "rc.namedMiddlewares"
     * and "rc.globalMiddlewares" exists.
     */
    async registerMiddlewares() {
        await this.registerNamedMiddlewares();
        await this.registerGlobalMiddlewares();
        if (Config.exists('rc.middlewares')) {
            await Exec.concurrently(Config.get('rc.middlewares'), this.resolvePath);
        }
    }
    /**
     * Register all the named middlewares found inside "rc.namedMiddlewares"
     * property.
     */
    async registerNamedMiddlewares() {
        const namedMiddlewares = Config.get('rc.namedMiddlewares');
        if (Is.Empty(namedMiddlewares)) {
            return;
        }
        await Exec.concurrently(Object.keys(namedMiddlewares), async (key) => {
            const Middleware = await this.resolvePath(namedMiddlewares[key]);
            if (Reflect.hasMetadata('provider:registered', Middleware)) {
                return;
            }
            const createCamelAlias = false;
            const { alias, namedAlias } = this.getNamedMiddlewareAlias(key, Middleware);
            ioc.bind(alias, Middleware, createCamelAlias).alias(namedAlias, alias);
        });
    }
    /**
     * Register all the named middlewares found inside "rc.globalMiddlewares"
     * property.
     */
    async registerGlobalMiddlewares() {
        const globalMiddlewares = Config.get('rc.globalMiddlewares');
        if (Is.Empty(globalMiddlewares)) {
            return;
        }
        await Exec.concurrently(globalMiddlewares, async (path) => {
            const Middleware = await this.resolvePath(path);
            if (Reflect.hasMetadata('provider:registered', Middleware)) {
                return;
            }
            const createCamelAlias = false;
            const { alias, handler, serverMethod } = this.getGlobalMiddlewareAliasAndHandler(Middleware);
            ioc.bind(alias, Middleware, createCamelAlias);
            Server[serverMethod](ioc.safeUse(alias)[handler]);
        });
    }
    /**
     * Register the exception handler for all request handlers.
     */
    async registerExceptionHandler(path) {
        if (!path) {
            const handler = new HttpExceptionHandler();
            Server.setErrorHandler(handler.handle.bind(handler));
            return;
        }
        const Handler = await this.resolvePath(path);
        const handler = new Handler();
        Server.setErrorHandler(handler.handle.bind(handler));
    }
    /**
     * Register the route file by importing the file.
     */
    async registerRoutes(path) {
        if (path.startsWith('#')) {
            await this.resolvePath(path);
            return;
        }
        if (!isAbsolute(path)) {
            path = resolve(path);
        }
        if (!(await File.exists(path))) {
            return;
        }
        await this.resolvePath(path);
    }
    /**
     * Fabricate the named middlewares aliases.
     */
    getNamedMiddlewareAlias(name, Middleware) {
        const middleware = new Middleware();
        if (middleware.handle) {
            return {
                alias: `App/Http/Middlewares/${Middleware.name}`,
                namedAlias: `App/Http/Middlewares/Names/${name}`,
            };
        }
        if (middleware.intercept) {
            return {
                alias: `App/Http/Interceptors/${Middleware.name}`,
                namedAlias: `App/Http/Interceptors/Names/${name}`,
            };
        }
        if (middleware.terminate) {
            return {
                alias: `App/Http/Terminators/${Middleware.name}`,
                namedAlias: `App/Http/Terminators/Names/${name}`,
            };
        }
    }
    /**
     * Fabricate the global middlewares alias and resolve the handler and
     * server methods.
     */
    getGlobalMiddlewareAliasAndHandler(Middleware) {
        const middleware = new Middleware();
        if (middleware.handle) {
            return {
                handler: 'handle',
                serverMethod: 'middleware',
                alias: `App/Http/Middlewares/${Middleware.name}`,
            };
        }
        if (middleware.intercept) {
            return {
                handler: 'intercept',
                serverMethod: 'intercept',
                alias: `App/Http/Interceptors/${Middleware.name}`,
            };
        }
        if (middleware.terminate) {
            return {
                handler: 'terminate',
                serverMethod: 'terminate',
                alias: `App/Http/Terminators/${Middleware.name}`,
            };
        }
    }
    /**
     * Resolve the import path by meta URL and import it.
     */
    resolvePath(path) {
        return Module.resolve(`${path}?version=${Math.random()}`, Config.get('rc.meta'));
    }
}
