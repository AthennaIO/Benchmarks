/**
 * @athenna/core
 *
 * (c) Jo√£o Lenon <lenon@athenna.io>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Exec, File, Folder } from '@athenna/common';
import { BaseCommand, Option } from '@athenna/artisan';
export class BuildCommand extends BaseCommand {
    clean;
    ignoreOnClean;
    static signature() {
        return 'build';
    }
    static description() {
        return 'Compile your application code to JavaScript.';
    }
    async handle() {
        if (this.clean) {
            this.logger.simple('({bold,green} [ CLEANING APPLICATION ])\n');
            const folder = await new Folder(Path.pwd()).load();
            const files = folder.getFilesByPattern(`!(${this.ignoreOnClean})/**/*.@(js|d.ts|js.map)`);
            await this.logger.promiseSpinner(() => Exec.concurrently(files, file => file.remove()), {
                stream: process.stdout,
                text: 'Cleaning all .js, .d.ts and .js.map files from your application',
                successText: 'Application successfully cleaned',
                failText: 'Failed to clean your application:',
            });
            return;
        }
        this.logger.simple('({bold,green} [ BUILDING APPLICATION ])\n');
        const tsConfig = await this.getTsConfig();
        await this.logger.promiseSpinner(() => Exec.command(`${Path.bin('tsc')} --project ${tsConfig.path}`), {
            stream: process.stdout,
            text: 'Compiling all .ts files from your application',
            successText: 'Application successfully compiled',
            failText: 'Failed to compile your application:',
        });
    }
    getTsConfig() {
        const path = Config.get('rc.commands.build.tsconfig', '../../tmp/tsconfig.build.json');
        const content = {
            extends: this.toPosix(Path.pwd('tsconfig.json')),
            include: [this.toPosix(Path.pwd('**/*'))],
            exclude: [this.toPosix(Path.tests()), this.toPosix(Path.nodeModules())],
        };
        return new File(path, JSON.stringify(content, null, 2)).load();
    }
    toPosix(path) {
        if (process.platform === 'win32') {
            return path.replace(/\\/g, '/').slice(2);
        }
        return path;
    }
}
__decorate([
    Option({
        signature: '--clean',
        description: 'Clean all .js and .d.ts files instead of building your code.',
        default: false,
    })
], BuildCommand.prototype, "clean", void 0);
__decorate([
    Option({
        signature: '--ignore-on-clean [folders]',
        description: 'Ignore the given folders when cleaning the application.',
        default: 'tests|node_modules',
    })
], BuildCommand.prototype, "ignoreOnClean", void 0);
