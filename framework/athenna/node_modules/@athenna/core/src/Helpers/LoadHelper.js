/**
 * @athenna/core
 *
 * (c) Jo√£o Lenon <lenon@athenna.io>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
import { parse } from 'node:path';
import { Log } from '@athenna/logger';
import { Exec, Module } from '@athenna/common';
class LoadHelper {
    /**
     * The providers modules loaded.
     */
    static providers = [];
    /**
     * The file paths that are already preloaded.
     */
    static alreadyPreloaded = [];
    /**
     * REGOOT (Register and Boot) providers.
     */
    static async regootProviders() {
        await this.loadBootableProviders();
        await this.registerProviders();
        await this.bootProviders();
        if (Config.is('rc.bootLogs', true)) {
            this.providers.forEach(Provider => Log.channelOrVanilla('application').success(`Provider ({yellow} ${Provider.name}) successfully booted`));
        }
    }
    /**
     * Execute the "boot" method of all the providers loaded.
     */
    static async bootProviders() {
        await Exec.concurrently(this.providers, Provider => new Provider().boot());
    }
    /**
     * Execute the "register" method of all the providers loaded.
     */
    static async registerProviders() {
        await Exec.concurrently(this.providers, Provider => new Provider().register());
    }
    /**
     * Execute the "shutdown" method of all the providers loaded.
     */
    static async shutdownProviders() {
        await Exec.concurrently(this.providers, Provider => {
            if (Config.is('rc.shutdownLogs', true)) {
                Log.channelOrVanilla('application').success(`Provider ({yellow} ${Provider.name}) successfully shutdown`);
            }
            return new Provider().shutdown();
        });
    }
    /**
     * Preload all the files inside "rc.preloads" configuration by importing.
     */
    static async preloadFiles() {
        await Exec.concurrently(Config.get('rc.preloads'), path => {
            if (this.alreadyPreloaded.includes(path)) {
                return;
            }
            if (Config.is('rc.bootLogs', true)) {
                Log.channelOrVanilla('application').success(`File ({yellow} ${parse(path).base}) successfully preloaded`);
            }
            return this.resolvePath(path).then(() => this.alreadyPreloaded.push(path));
        });
    }
    /**
     * Get all the providers from .athennarc.json file. Also, will return only
     * the providers have the same value of "rc.s".
     */
    static async loadBootableProviders() {
        const paths = Config.get('rc.providers');
        const providers = await Exec.concurrently(paths, this.resolvePath);
        this.providers = providers.filter(Provider => {
            if (!this.isRegistered(Provider) && this.canBeBootstrapped(Provider)) {
                return true;
            }
            return false;
        });
    }
    /**
     * Verify if provider is already registered.
     */
    static isRegistered(Provider) {
        return !!this.providers.find(P => P === Provider);
    }
    /**
     * Verify if provider can be bootstrapped.
     */
    static canBeBootstrapped(Provider) {
        const provider = new Provider();
        if (provider.environment[0] === '*') {
            return true;
        }
        const envs = Config.get('rc.environments');
        if (!envs || !envs.length || envs[0] === '*') {
            return true;
        }
        return envs.some(env => provider.environment.indexOf(env) >= 0);
    }
    /**
     * Resolve the import path by meta URL and import it.
     */
    static async resolvePath(path) {
        return Module.resolve(path, Config.get('rc.meta'));
    }
}
export { LoadHelper };
