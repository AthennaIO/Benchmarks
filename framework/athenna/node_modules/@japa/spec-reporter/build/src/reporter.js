"use strict";
/*
 * @japa/spec-reporter
 *
 * (c) Japa.dev
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpecReporter = void 0;
const ms_1 = __importDefault(require("ms"));
const path_1 = require("path");
const cliui_1 = require("@poppinss/cliui");
const base_reporter_1 = require("@japa/base-reporter");
/**
 * Pretty prints the tests on the console
 */
class SpecReporter extends base_reporter_1.BaseReporter {
    constructor(options = {}) {
        super(options);
        this.isFirstLoneTest = true;
    }
    /**
     * Returns the icon for the test
     */
    getTestIcon(payload) {
        if (payload.isTodo) {
            return cliui_1.logger.colors.cyan(cliui_1.icons.info);
        }
        if (payload.isFailing) {
            return payload.hasError
                ? cliui_1.logger.colors.magenta(cliui_1.icons.squareSmallFilled)
                : cliui_1.logger.colors.red(cliui_1.icons.cross);
        }
        if (payload.hasError) {
            return cliui_1.logger.colors.red(cliui_1.icons.cross);
        }
        if (payload.isSkipped) {
            return cliui_1.logger.colors.yellow(cliui_1.icons.bullet);
        }
        return cliui_1.logger.colors.green(cliui_1.icons.tick);
    }
    /**
     * Returns the test message
     */
    getTestMessage(payload) {
        const message = typeof payload.title === 'string' ? payload.title : payload.title.expanded;
        if (payload.isTodo) {
            return cliui_1.logger.colors.blue(message);
        }
        if (payload.isFailing) {
            return payload.hasError ? cliui_1.logger.colors.magenta(message) : cliui_1.logger.colors.red(message);
        }
        if (payload.hasError) {
            return cliui_1.logger.colors.red(message);
        }
        if (payload.isSkipped) {
            return cliui_1.logger.colors.yellow(message);
        }
        return cliui_1.logger.colors.grey(message);
    }
    /**
     * Returns the subtext message for the test
     */
    getSubText(payload) {
        if (payload.isSkipped && payload.skipReason) {
            return cliui_1.logger.colors.yellow(payload.skipReason);
        }
        if (!payload.isFailing) {
            return;
        }
        if (!payload.hasError) {
            return cliui_1.logger.colors.magenta(`Test marked with ".fails()" must finish with an error`);
        }
        if (payload.failReason) {
            return cliui_1.logger.colors.magenta(payload.failReason);
        }
        const testErrorMessage = payload.errors.find((error) => error.phase === 'test');
        if (testErrorMessage && testErrorMessage.error) {
            return cliui_1.logger.colors.magenta(testErrorMessage.error.message);
        }
    }
    /**
     * Returns the filename relative from the current working dir
     */
    getRelativeFilename(fileName) {
        return (0, path_1.relative)(process.cwd(), fileName);
    }
    /**
     * Prints the test details
     */
    printTest(payload) {
        const icon = this.getTestIcon(payload);
        const message = this.getTestMessage(payload);
        const prefix = payload.isPinned ? cliui_1.logger.colors.yellow('[PINNED] ') : '';
        const indentation = this.currentFileName || this.currentGroupTitle ? '  ' : '';
        const duration = cliui_1.logger.colors.dim(`(${(0, ms_1.default)(payload.duration)})`);
        const retries = payload.retryAttempt && payload.retryAttempt > 1
            ? cliui_1.logger.colors.dim(`(x${payload.retryAttempt}) `)
            : '';
        let subText = this.getSubText(payload);
        subText = subText ? `\n${indentation}  ${subText}` : '';
        console.log(`${indentation}${icon} ${prefix}${retries}${message} ${duration}${subText}`);
    }
    /**
     * Prints the group name
     */
    printGroup(payload) {
        const title = this.currentSuiteName !== 'default'
            ? `${this.currentSuiteName} / ${payload.title}`
            : payload.title;
        const suffix = this.currentFileName
            ? cliui_1.logger.colors.dim(` (${this.getRelativeFilename(this.currentFileName)})`)
            : '';
        console.log(`\n${title}${suffix}`);
    }
    onTestStart() {
        /**
         * Display the filename when
         *
         * - The filename exists
         * - The test is not under a group
         * - Test is first in a sequence
         */
        if (this.currentFileName && this.isFirstLoneTest) {
            console.log(`\n${cliui_1.logger.colors.dim(this.getRelativeFilename(this.currentFileName))}`);
        }
        this.isFirstLoneTest = false;
    }
    onTestEnd(payload) {
        this.printTest(payload);
    }
    onGroupStart(payload) {
        /**
         * When a group starts, we mark the upcoming test as NOT a
         * lone test
         */
        this.isFirstLoneTest = false;
        this.currentGroupTitle = payload.title;
        this.printGroup(payload);
    }
    onGroupEnd() {
        this.currentGroupTitle = undefined;
        /**
         * When the group ends we assume that the next test can
         * be out of the group, hence a lone test.
         *
         * If this assumption is false, then the `onGroupStart` method
         * will toggle the boolean
         */
        this.isFirstLoneTest = true;
    }
    async end() {
        const summary = this.runner.getSummary();
        await this.printSummary(summary);
    }
}
exports.SpecReporter = SpecReporter;
