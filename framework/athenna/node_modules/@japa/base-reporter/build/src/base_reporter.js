"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseReporter = void 0;
const ms_1 = __importDefault(require("ms"));
const cliui_1 = require("@poppinss/cliui");
const errors_printer_1 = require("@japa/errors-printer");
class BaseReporter {
    options;
    runner;
    currentFileName;
    currentSuiteName;
    uncaughtExceptions = [];
    constructor(options = {}) {
        this.options = {
            stackLinesCount: options.stackLinesCount || 5,
        };
    }
    printKeyValuePair(key, value, whitespaceLength) {
        console.log(`${cliui_1.logger.colors.dim(`${key.padEnd(whitespaceLength + 2)} : `)}${value}`);
    }
    onTestStart(_) { }
    onTestEnd(_) { }
    onGroupStart(_) { }
    onGroupEnd(_) { }
    onSuiteStart(_) { }
    onSuiteEnd(_) { }
    async start(_) { }
    async end(_) { }
    printAggregates(summary) {
        const [tests, time] = [[], []];
        time.push(cliui_1.logger.colors.dim((0, ms_1.default)(summary.duration)));
        if (summary.aggregates.passed) {
            tests.push(cliui_1.logger.colors.green(`${summary.aggregates.passed} passed`));
        }
        if (summary.aggregates.failed) {
            tests.push(cliui_1.logger.colors.red(`${summary.aggregates.failed} failed`));
        }
        if (summary.aggregates.todo) {
            tests.push(cliui_1.logger.colors.cyan(`${summary.aggregates.todo} todo`));
        }
        if (summary.aggregates.skipped) {
            tests.push(cliui_1.logger.colors.yellow(`${summary.aggregates.skipped} skipped`));
        }
        if (summary.aggregates.regression) {
            tests.push(cliui_1.logger.colors.magenta(`${summary.aggregates.regression} regression`));
        }
        const keysPadding = summary.aggregates.uncaughtExceptions ? 19 : 5;
        this.printKeyValuePair('Tests', `${tests.join(', ')} ${cliui_1.logger.colors.dim(`(${summary.aggregates.total})`)}`, keysPadding);
        this.printKeyValuePair('Time', time.join(''), keysPadding);
        if (summary.aggregates.uncaughtExceptions) {
            this.printKeyValuePair('Uncaught exceptions', cliui_1.logger.colors.red(String(summary.aggregates.uncaughtExceptions)), keysPadding);
        }
    }
    async printErrors(summary) {
        if (summary.failureTree.length || this.uncaughtExceptions.length) {
            console.log('');
            console.log('');
        }
        const errorPrinter = new errors_printer_1.ErrorsPrinter({
            stackLinesCount: this.options.stackLinesCount,
        });
        for (let suite of summary.failureTree) {
            await errorPrinter.printErrors(suite.name, suite.errors);
            for (let testOrGroup of suite.children) {
                if (testOrGroup.type === 'group') {
                    await errorPrinter.printErrors(testOrGroup.name, testOrGroup.errors);
                    for (let test of testOrGroup.children) {
                        await errorPrinter.printErrors(test.title, test.errors);
                    }
                }
                else {
                    await errorPrinter.printErrors(testOrGroup.title, testOrGroup.errors);
                }
            }
        }
        await errorPrinter.printErrors('Uncaught exception', this.uncaughtExceptions);
    }
    async printSummary(summary) {
        console.log('');
        if (summary.aggregates.total === 0 && !summary.hasError) {
            console.log(cliui_1.logger.colors.bgYellow().black(' NO TESTS EXECUTED '));
            return;
        }
        if (summary.hasError) {
            console.log(cliui_1.logger.colors.bgRed().black(' FAILED '));
        }
        else {
            console.log(cliui_1.logger.colors.bgGreen().black(' PASSED '));
        }
        console.log('');
        this.printAggregates(summary);
        await this.printErrors(summary);
    }
    boot(runner, emitter) {
        this.runner = runner;
        emitter.on('test:start', (payload) => {
            this.currentFileName = payload.meta.fileName;
            this.onTestStart(payload);
        });
        emitter.on('test:end', (payload) => {
            this.onTestEnd(payload);
        });
        emitter.on('group:start', (payload) => {
            this.currentFileName = payload.meta.fileName;
            this.onGroupStart(payload);
        });
        emitter.on('group:end', (payload) => {
            this.onGroupEnd(payload);
        });
        emitter.on('suite:start', (payload) => {
            this.currentSuiteName = payload.name;
            this.onSuiteStart(payload);
        });
        emitter.on('suite:end', (payload) => {
            this.currentSuiteName = undefined;
            this.onSuiteEnd(payload);
        });
        emitter.on('uncaught:exception', async (error) => {
            this.uncaughtExceptions.push({ phase: 'test', error });
        });
        emitter.on('runner:start', async (payload) => {
            await this.start(payload);
        });
        emitter.on('runner:end', async (payload) => {
            await this.end(payload);
        });
    }
}
exports.BaseReporter = BaseReporter;
