"use strict";
/*
 * @japa/assert
 *
 * (c) Japa.dev
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Assert = void 0;
const macroable_1 = require("macroable");
const api_contract_validator_1 = require("api-contract-validator");
const chai_1 = require("chai");
const utils_1 = require("./utils");
/**
 * The Assert class is derived from chai.assert to allow support
 * for additional assertion methods and assertion planning.
 *
 * Also some of the methods from chai.assert are not available
 * and some additional methods have been added.
 *
 * @example
 * const assert = new Assert()
 * assert.deepEqual({ id: 1 }, { id: 1 })
 */
class Assert extends macroable_1.Macroable {
    constructor() {
        super(...arguments);
        /**
         * Tracking assertions
         */
        this.assertions = {
            total: 0,
            mismatchError: null,
            validate() {
                if (this.planned === undefined) {
                    return;
                }
                if (this.planned !== this.total) {
                    const suffix = this.planned === 1 ? '' : 's';
                    const message = `Planned for ${this.planned} assertion${suffix}, but ran ${this.total}`;
                    this.mismatchError.message = message;
                    throw this.mismatchError;
                }
            },
        };
        this.Assertion = chai_1.Assertion;
        this.AssertionError = chai_1.AssertionError;
    }
    /**
     * Register api specs to be used for validating responses
     */
    static registerApiSpecs(paths, options) {
        this.hasInstalledApiValidator = true;
        (0, chai_1.use)((0, api_contract_validator_1.chaiPlugin)({ apiDefinitionsPath: paths, ...options }));
    }
    /**
     * Converts a luxon date to JavaScript date
     */
    luxonToJSDate(value) {
        if (typeof value?.toJSDate === 'function') {
            return value.toJSDate();
        }
        return value;
    }
    /**
     * Increments the assertions count by 1
     */
    incrementAssertionsCount() {
        this.assertions.total += 1;
    }
    /**
     * Plan assertions to expect by the end of this test
     */
    plan(assertionsToExpect) {
        const error = new Error();
        if (Error.captureStackTrace) {
            Error.captureStackTrace(error);
        }
        this.assertions.planned = assertionsToExpect;
        this.assertions.mismatchError = error;
        return this;
    }
    /**
     * Evaluate an expression and raise {@link AssertionError} if expression
     * is not truthy
     */
    evaluate(expression, message, stackProps) {
        this.Assertion.prototype.assert.call({
            __flags: {
                operator: stackProps.operator,
                message: stackProps.prefix,
                object: stackProps.thisObject,
            },
        }, expression, message, '', stackProps.expected, stackProps.actual, stackProps.showDiff === undefined ? true : stackProps.showDiff);
    }
    /**
     * Assert an expression to be truthy.
     * Optionally define the error message
     *
     * @example:
     * assert(isTrue(foo))
     * assert(foo === 'bar')
     * assert(age > 18, 'Not allowed to enter the club')
     *
     */
    assert(expression, message) {
        this.incrementAssertionsCount();
        return (0, chai_1.assert)(expression, message);
    }
    fail(actual, expected, message, operator) {
        this.incrementAssertionsCount();
        if (arguments.length === 1 && typeof actual === 'string') {
            return chai_1.assert.fail(actual);
        }
        return chai_1.assert.fail(actual, expected, message, operator);
    }
    /**
     * Assert the value is truthy
     *
     * @example
     * assert.isOk({ hello: 'world' }) // passes
     * assert.isOk(null) // fails
     *
     */
    isOk(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isOk(...args);
    }
    /**
     * Assert the value is truthy
     *
     * @alias
     * isOk
     *
     * @example
     * assert.ok({ hello: 'world' }) // passes
     * assert.ok(null) // fails
     *
     */
    ok(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.ok(...args);
    }
    /**
     * Assert the value is falsy
     *
     * @example
     * assert.isNotOk({ hello: 'world' }) // fails
     * assert.isNotOk(null) // passes
     *
     */
    isNotOk(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isNotOk(...args);
    }
    /**
     * Assert the value is falsy
     *
     * @alias
     * isNotOk
     *
     * @example
     * assert.notOk({ hello: 'world' }) // fails
     * assert.notOk(null) // passes
     *
     */
    notOk(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.notOk(...args);
    }
    /**
     * Assert two values are equal but not strictly. The comparsion
     * is same as "foo == bar".
     *
     * See {@link strictEqual} for strict equality
     * See {@link deepEqual} for comparing objects and arrays
     *
     * @example
     * assert.equal(3, 3) // passes
     * assert.equal(3, '3') // passes
     * assert.equal(Symbol.for('foo'), Symbol.for('foo')) // passes
     *
     */
    equal(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.equal(...args);
    }
    /**
     * Assert two values are not equal. The comparsion
     * is same as "foo != bar".
     *
     * See @notStrictEqual for strict inequality
     * See @notDeepEqual for comparing objects and arrays
     *
     * @example
     * assert.notEqual(3, 2) // passes
     * assert.notEqual(3, '2') // passes
     * assert.notEqual(Symbol.for('foo'), Symbol.for('bar')) // passes
     *
     */
    notEqual(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.notEqual(...args);
    }
    /**
     * Assert two values are strictly equal. The comparsion
     * is same as "foo === bar".
     *
     * See @equal for non-strict equality
     * See @deepEqual for comparing objects and arrays
     *
     * @example
     * assert.equal(3, 3) // passes
     * assert.equal(3, '3') // fails
     * assert.equal(Symbol.for('foo'), Symbol.for('foo')) // passes
     */
    strictEqual(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.strictEqual(...args);
    }
    /**
     * Assert two values are not strictly equal. The comparsion
     * is same as "foo !== bar".
     *
     * See @notEqual for non-strict equality
     * See @notDeepEqual for comparing objects and arrays
     *
     * @example
     * assert.notStrictEqual(3, 2) // passes
     * assert.notStrictEqual(3, '2') // fails
     * assert.notStrictEqual(Symbol.for('foo'), Symbol.for('bar')) // passes
     */
    notStrictEqual(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.notStrictEqual(...args);
    }
    /**
     * Assert two values are deeply equal. The order of items in
     * an array should be same for the assertion to pass.
     *
     * @example
     * assert.deepEqual({ a: 1, b: 2 }, { a: 1, b: 2 }) // passes
     * assert.deepEqual({ b: 2, a: 1 }, { a: 1, b: 2 }) // passes
     * assert.deepEqual([1, 2], [1, 2]) // passes
     * assert.deepEqual([1, 2], [2, 1]) // fails
     * assert.deepEqual(/a/, /a/) // passes
     * assert.deepEqual(
     *   new Date('2020 01 22'),
     *   new Date('2020 01 22')
     * ) // passes
     */
    deepEqual(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.deepEqual(...args);
    }
    /**
     * Assert two values are not deeply equal.
     *
     * @example
     * assert.notDeepEqual({ a: 1, b: 2 }, { a: 1, b: '2' }) // passes
     * assert.notDeepEqual([1, 2], [2, 1]) // passes
     * assert.notDeepEqual(
     *   new Date('2020 01 22'),
     *   new Date('2020 01 23')
     * ) // passes
     */
    notDeepEqual(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.notDeepEqual(...args);
    }
    isAbove(valueToCheck, valueToBeAbove, message) {
        valueToCheck = this.luxonToJSDate(valueToCheck);
        valueToBeAbove = this.luxonToJSDate(valueToBeAbove);
        this.incrementAssertionsCount();
        return chai_1.assert.isAbove(valueToCheck, valueToBeAbove, message);
    }
    isAtLeast(valueToCheck, valueToBeAtLeast, message) {
        valueToCheck = this.luxonToJSDate(valueToCheck);
        valueToBeAtLeast = this.luxonToJSDate(valueToBeAtLeast);
        this.incrementAssertionsCount();
        return chai_1.assert.isAtLeast(valueToCheck, valueToBeAtLeast, message);
    }
    isBelow(valueToCheck, valueToBeBelow, message) {
        valueToCheck = this.luxonToJSDate(valueToCheck);
        valueToBeBelow = this.luxonToJSDate(valueToBeBelow);
        this.incrementAssertionsCount();
        return chai_1.assert.isBelow(valueToCheck, valueToBeBelow, message);
    }
    isAtMost(valueToCheck, valueToBeAtMost, message) {
        valueToCheck = this.luxonToJSDate(valueToCheck);
        valueToBeAtMost = this.luxonToJSDate(valueToBeAtMost);
        this.incrementAssertionsCount();
        return chai_1.assert.isAtMost(valueToCheck, valueToBeAtMost, message);
    }
    /**
     * Assert the value is a boolean (true).
     *
     * @example
     * assert.isTrue(true) // passes
     * assert.isTrue(false) // fails
     * assert.isTrue(1) // fails
     * assert.isTrue('foo') // fails
     */
    isTrue(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isTrue(...args);
    }
    /**
     * Assert the value is anything, but not true
     *
     * @example
     * assert.isNotTrue(true) // fails
     * assert.isNotTrue(false) // passes
     * assert.isNotTrue(1) // passes
     * assert.isNotTrue('foo') // passes
     */
    isNotTrue(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isNotTrue(...args);
    }
    /**
     * Assert the value is boolean (false)
     *
     * @example
     * assert.isFalse(false) // passes
     * assert.isFalse(true) // fails
     * assert.isFalse(0) // fails
     * assert.isFalse(null) // fails
     */
    isFalse(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isFalse(...args);
    }
    /**
     * Assert the value is anything but not false
     *
     * @example
     * assert.isNotFalse(false) // fails
     * assert.isNotFalse(true) // passes
     * assert.isNotFalse(null) // passes
     * assert.isNotFalse(undefined) // passes
     */
    isNotFalse(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isNotFalse(...args);
    }
    /**
     * Assert the value is null
     *
     * @example
     * assert.isNull(null) // passes
     * assert.isNull(true) // fails
     * assert.isNull(false) // fails
     * assert.isNull('foo') // fails
     */
    isNull(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isNull(...args);
    }
    /**
     * Assert the value is anything but not null
     *
     * @example
     * assert.isNotNull(null) // fails
     * assert.isNotNull(true) // passes
     * assert.isNotNull(false) // passes
     * assert.isNotNull('foo') // passes
     */
    isNotNull(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isNotNull(...args);
    }
    /**
     * Assert the value is NaN
     *
     * @example
     * assert.isNaN(NaN) // passes
     * assert.isNaN(Number('hello')) // passes
     * assert.isNaN(true) // fails
     * assert.isNaN(false) // fails
     * assert.isNaN(null) // fails
     */
    isNaN(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isNaN(...args);
    }
    /**
     * Assert the value is anything, but not NaN
     *
     * @example
     * assert.isNotNaN(NaN) // fails
     * assert.isNotNaN(Number('hello')) // fails
     * assert.isNotNaN(true) // passes
     * assert.isNotNaN(false) // passes
     * assert.isNotNaN(null) // passes
     */
    isNotNaN(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isNotNaN(...args);
    }
    /**
     * Asserts the value is not "null" or "undefined"
     *
     * @example
     * assert.exists(false) // passes
     * assert.exists(0) // passes
     * assert.exists('') // passes
     * assert.exists(null) // fails
     * assert.exists(undefined) // fails
     */
    exists(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.exists(...args);
    }
    /**
     * Asserts the value is "null" or "undefined"
     *
     * @example
     * assert.notExists(null) // passes
     * assert.notExists(undefined) // passes
     * assert.notExists('') // fails
     * assert.notExists(false) // fails
     * assert.notExists(0) // fails
     */
    notExists(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.notExists(...args);
    }
    /**
     * Asserts the value is explicitly "undefined"
     *
     * @example
     * assert.isUndefined(undefined) // passes
     * assert.isUndefined(false) // fails
     * assert.isUndefined(0) // fails
     * assert.isUndefined('') // fails
     * assert.isUndefined(null) // fails
     */
    isUndefined(...args) {
        this.incrementAssertionsCount();
        chai_1.assert.isUndefined(...args);
    }
    /**
     * Asserts the value is anything, but not "undefined"
     *
     * @example
     * assert.isDefined(undefined) // fails
     * assert.isDefined(0) // passes
     * assert.isDefined(false) // passes
     * assert.isDefined('') // passes
     * assert.isDefined(null) // passes
     */
    isDefined(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isDefined(...args);
    }
    /**
     * Assert the value is a function
     *
     * @example
     * assert.isFunction(function foo () {}) // passes
     * assert.isFunction(() => {}) // passes
     * assert.isFunction(class Foo {}) // passes
     */
    isFunction(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isFunction(...args);
    }
    /**
     * Assert the value is not a function
     *
     * @example
     * assert.isNotFunction({}) // passes
     * assert.isNotFunction(null) // passes
     * assert.isNotFunction(() => {}) // fails
     */
    isNotFunction(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isNotFunction(...args);
    }
    /**
     * Assert the value to a valid object literal
     *
     * @example
     * assert.isObject({}) // passes
     * assert.isObject(new SomeClass()) // passes
     * assert.isObject(null) // fails
     * assert.isObject([]) // fails
     */
    isObject(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isObject(...args);
    }
    /**
     * Assert the value to not be an object literal
     *
     * @example
     * assert.isNotObject(null) // passes
     * assert.isNotObject([]) // passes
     * assert.isNotObject({}) // fails
     * assert.isNotObject(new SomeClass()) // fails
     */
    isNotObject(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isNotObject(...args);
    }
    /**
     * Assert the value to be a valid array
  
     * @example
     * assert.isArray([]) // passes
     * assert.isArray({}) // fails
     */
    isArray(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isArray(...args);
    }
    /**
     * Assert the value to not be an array
  
     * @example
     * assert.isNotArray([]) // fails
     * assert.isNotArray({}) // passes
     */
    isNotArray(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isNotArray(...args);
    }
    /**
     * Assert the value to be a string literal
  
     * @example
     * assert.isString('') // passes
     * assert.isString(new String(true)) // passes
     * assert.isString(1) // fails
     */
    isString(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isString(...args);
    }
    /**
     * Assert the value to not be a string literal
     *
     * @example
     * assert.isNotString(1) // passes
     * assert.isNotString('') // fails
     * assert.isNotString(new String(true)) // fails
     */
    isNotString(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isNotString(...args);
    }
    /**
     * Assert the value to be a valid number
     *
     * @example
     * assert.isNumber(1) // passes
     * assert.isNumber(new Number('1')) // passes
     * assert.isNumber('1') // fails
     */
    isNumber(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isNumber(...args);
    }
    /**
     * Assert the value to not be a valid number
     *
     * @example
     * assert.isNotNumber('1') // passes
     * assert.isNotNumber(1) // fails
     */
    isNotNumber(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isNotNumber(...args);
    }
    /**
     * Assert the value to be a number and no NaN or Infinity
     *
     * @example
     * assert.isFinite(1) // passes
     * assert.isFinite(Infinity) // fails
     * assert.isFinite(NaN) // fails
     */
    isFinite(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isFinite(...args);
    }
    /**
     * Assert the value is a boolean
     *
     * @example
     * assert.isBoolean(true) // passes
     * assert.isBoolean(false) // passes
     * assert.isBoolean(1) // fails
     */
    isBoolean(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isBoolean(...args);
    }
    /**
     * Assert the value is anything, but not a boolean
     *
     * @example
     * assert.isNotBoolean(1) // passes
     * assert.isNotBoolean(false) // fails
     * assert.isNotBoolean(true) // fails
     */
    isNotBoolean(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isNotBoolean(...args);
    }
    /**
     * Assert the typeof value matches the expected type
     *
     * @example
     * assert.typeOf({ foo: 'bar' }, 'object') // passes
     * assert.typeOf(['admin'], 'array') // passes
     * assert.typeOf(new Date(), 'date') // passes
     */
    typeOf(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.typeOf(...args);
    }
    /**
     * Assert the typeof value is not same as the expected type
     *
     * @example
     * assert.notTypeOf({ foo: 'bar' }, 'array') // passes
     * assert.notTypeOf(['admin'], 'string') // passes
     */
    notTypeOf(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.notTypeOf(...args);
    }
    /**
     * Assert value to be an instance of the expected class
     *
     * @example
     * assert.instanceOf(new User(), User) // passes
     * assert.instanceOf(new User(), Function) // fails
     *
     * class User extends BaseUser {}
     * assert.instanceOf(new User(), BaseUser) // passes
     */
    instanceOf(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.instanceOf(...args);
    }
    /**
     * Assert value to NOT be an instance of the expected
     * class
     *
     * @example
     * assert.notInstanceOf(new User(), Function) // passes
     * assert.notInstanceOf(new User(), User) // fails
     */
    notInstanceOf(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.notInstanceOf(...args);
    }
    /**
     * Assert the collection includes an item. Works for strings, arrays
     * and objects.
     *
     * See {@link this.deepInclude} for deep comparsion
     *
     * @example
     * assert.include(
     *   { id: 1, name: 'virk' },
     *   { name: 'virk' }
     * ) // passes
     *
     * assert.include([1, 2, 3], 2) // passes
     * assert.include('hello world', 'hello') // passes
     */
    include(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.include(...args);
    }
    /**
     * Assert the collection to NOT include an item. Works for strings,
     * arrays and objects.
     *
     * See {@link this.deepInclude} for nested object properties
     *
     * @example
     * assert.include(
     *   { id: 1, name: 'virk' },
     *   { name: 'virk' }
     * ) // passes
     *
     * assert.include([1, 2, 3], 2) // passes
     * assert.include('hello world', 'hello') // passes
     */
    notInclude(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.notInclude(...args);
    }
    /**
     * Assert the collection includes an item. Works for strings, arrays
     * and objects.
     *
     * @example
     * assert.deepInclude(
     *   { foo: { a: 1 }, bar: { b: 2 } },
     *   { foo: { a: 1 } }
     * ) // passes
     *
     * assert.deepInclude([1, [2], 3], [2]) // passes
     */
    deepInclude(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.deepInclude(...args);
    }
    /**
     * Assert the collection to NOT include an item. Works for strings,
     * arrays, and objects.
     *
     * @example
     * assert.notDeepInclude(
     *   { foo: { a: 1 }, bar: { b: 2 } },
     *   { foo: { a: 4 } }
     * ) // passes
     *
     * assert.deepInclude([1, [2], 3], [20]) // passes
     */
    notDeepInclude(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.notDeepInclude(...args);
    }
    /**
     * Assert the value to match the given regular expression
     *
     * @example
     * assert.match('foobar', /^foo/) // passes
     */
    match(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.match(...args);
    }
    /**
     * Assert the value to NOT match the given regular expression
     *
     * @example
     * assert.notMatch('foobar', /^foo/) // fails
     */
    notMatch(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.notMatch(...args);
    }
    /**
     * Assert an object to contain a property
     *
     * @example
     * assert.property(
     *   { id: 1, username: 'virk' },
     *   'id'
     * ) // passes
     */
    property(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.nestedProperty(...args);
    }
    /**
     * Assert an object to NOT contain a property
     *
     * @example
     * assert.notProperty(
     *   { id: 1, username: 'virk' },
     *   'email'
     * ) // passes
     */
    notProperty(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.notNestedProperty(...args);
    }
    /**
     * Assert an object property to match the expected value
     *
     * Use {@link deepPropertyVal} for deep comparing the value
     *
     * @example
     * assert.propertyVal(
     *   { id: 1, username: 'virk' },
     *   'id',
     *   1
     * ) // passes
     *
     * assert.propertyVal(
     *   { user: { id: 1 } },
     *   'user',
     *   { id: 1 }
     * ) // fails
     */
    propertyVal(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.nestedPropertyVal(...args);
    }
    /**
     * Assert an object property to NOT match the expected value
     *
     * @example
     * assert.notPropertyVal(
     *   { id: 1, username: 'virk' },
     *   'id',
     *   22
     * ) // passes
     */
    notPropertyVal(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.notNestedPropertyVal(...args);
    }
    /**
     * Assert an object property to deeply match the expected value
     *
     * @example
     * assert.deepPropertyVal(
     *   { user: { id: 1 } },
     *   'user',
     *   { id: 1 }
     * ) // passes
     */
    deepPropertyVal(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.deepNestedPropertyVal(...args);
    }
    /**
     * Assert an object property to NOT deeply match the expected value
     *
     * @example
     * assert.notDeepPropertyVal(
     *   { user: { id: 1 } },
     *   'user',
     *   { email: 'foo@bar.com' }
     * ) // passes
     */
    notDeepPropertyVal(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.notDeepNestedPropertyVal(...args);
    }
    /**
     * Assert length of an array, map or set to match the expected value
     *
     * @example
     * assert.lengthOf([1, 2, 3], 3)
     * assert.lengthOf(new Map([[1],[2]]), 2)
     * assert.lengthOf('hello world', 11)
     */
    lengthOf(object, length, message) {
        this.incrementAssertionsCount();
        return chai_1.assert.lengthOf(object, length, message);
    }
    /**
     * Assert the object has all of the expected properties
     *
     * @example
     * assert.properties(
     *   { username: 'virk', age: 22, id: 1 },
     *   ['id', 'age']
     * ) // passes
     */
    properties(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.containsAllKeys(...args);
    }
    /**
     * Assert the object has any of the expected properties
     *
     * @example
     * assert.anyProperties(
     *   { username: 'virk', age: 22, id: 1 },
     *   ['id', 'name', 'dob']
     * ) // passes
     */
    anyProperties(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.hasAnyKeys(...args);
    }
    /**
     * Assert the object has only the expected properties. Extra
     * properties will fail the assertion
     *
     * @example
     * assert.onlyProperties(
     *   { username: 'virk', age: 22, id: 1 },
     *   ['id', 'name', 'age']
     * ) // passes
     *
     * assert.onlyProperties(
     *   { username: 'virk', age: 22, id: 1 },
     *   ['id', 'name']
     * ) // fails
     */
    onlyProperties(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.hasAllKeys(...args);
    }
    /**
     * Assert the object to not have any of the mentioned properties
     *
     * @example
     * assert.notAnyProperties(
     *   { id: 1, name: 'foo' },
     *   ['email', 'age']
     * ) // passes
     *
     * assert.notAnyProperties(
     *   { id: 1, name: 'foo' },
     *   ['email', 'id']
     * ) // fails
     */
    notAnyProperties(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.doesNotHaveAnyKeys(...args);
    }
    /**
     * Assert the object to not have all of the mentioned properties
     *
     * @example
     * assert.notAllProperties(
     *   { id: 1, name: 'foo' },
     *   ['id', 'name', 'email']
     * ) // passes
     */
    notAllProperties(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.doesNotHaveAllKeys(...args);
    }
    throws(fn, errType, regExp, message) {
        this.incrementAssertionsCount();
        const args = [fn, errType, regExp, message];
        return chai_1.assert.throws(...args);
    }
    doesNotThrows(fn, errType, regExp, message) {
        this.incrementAssertionsCount();
        const args = [fn, errType, regExp, message];
        return chai_1.assert.doesNotThrow(...args);
    }
    /**
     * Assert the value is closer to the expected value + delta
     *
     * @example
     * assert.closeTo(10, 6, 8) // passes
     * assert.closeTo(10, 6, 4) // passes
     * assert.closeTo(10, 20, 10) // passes
     */
    closeTo(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.closeTo(...args);
    }
    /**
     * Assert the value is equal to the expected value +/- delta range
     *
     * @example
     * assert.approximately(10, 6, 8) // passes
     * assert.approximately(10, 6, 4) // passes
     * assert.approximately(10, 20, 10) // passes
     */
    approximately(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.approximately(...args);
    }
    /**
     * Assert two arrays to have same members. The values comparison
     * is same the `assert.equal` method.
     *
     * Use {@link sameDeepMembers} for deep comparison
     *
     * @example
     * assert.sameMembers(
     *   [1, 2, 3],
     *   [1, 2, 3]
     * ) // passes
     *
     * assert.sameMembers(
     *   [1, { id: 1 }, 3],
     *   [1, { id: 1 }, 3]
     * ) // fails
     */
    sameMembers(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.sameMembers(...args);
    }
    /**
     * Assert two arrays to NOT have same members. The values comparison
     * is same the `assert.notEqual` method.
     *
     * Use {@link notSameDeepMembers} for deep comparison
     *
     * @example
     * assert.notSameMembers(
     *   [1, { id: 1 }, 3],
     *   [1, { id: 1 }, 3]
     * ) // passes
     *
     * assert.notSameMembers(
     *   [1, 2, 3],
     *   [1, 2, 3]
     * ) // fails
     *
     */
    notSameMembers(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert['notSameMembers'](...args);
    }
    /**
     * Assert two arrays to have same members.
     *
     * @example
     * assert.sameDeepMembers(
     *   [1, 2, 3],
     *   [1, 2, 3]
     * ) // passes
     *
     * assert.sameDeepMembers(
     *   [1, { id: 1 }, 3],
     *   [1, { id: 1 }, 3]
     * ) // passes
     */
    sameDeepMembers(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.sameDeepMembers(...args);
    }
    /**
     * Assert two arrays to NOT have same members.
     *
     * @example
     * assert.notSameDeepMembers(
     *   [1, { id: 1 }, 3],
     *   [1, { id: 2 }, 3]
     * ) // passes
     *
     */
    notSameDeepMembers(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert['notSameDeepMembers'](...args);
    }
    /**
     * Expect two arrays to have same members and in the same order.
     *
     * The values comparison is same the `assert.equal` method.
     * Use {@link sameDeepOrderedMembers} for deep comparison
     *
     * @example
     * assert.sameOrderedMembers(
     *   [1, 2, 3],
     *   [1, 2, 3]
     * ) // passes
     *
     * assert.sameOrderedMembers(
     *   [1, 3, 2],
     *   [1, 2, 3]
     * ) // fails
     */
    sameOrderedMembers(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.sameOrderedMembers(...args);
    }
    /**
     * Expect two arrays to either have different members or in
     * different order
     *
     * The values comparison is same the `assert.notEqual` method.
     * Use {@link notSameDeepOrderedMembers} for deep comparison
     *
     * @example
     * assert.notSameOrderedMembers(
     *   [1, 2, 3],
     *   [1, 2, 3]
     * ) // passes
     *
     * assert.notSameOrderedMembers(
     *   [1, 3, 2],
     *   [1, 2, 3]
     * ) // fails
     */
    notSameOrderedMembers(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.notSameOrderedMembers(...args);
    }
    /**
     * Expect two arrays to have same members and in the same order.
     *
     * The values comparison is same the `assert.deepEqual` method.
     *
     * @example
     * assert.sameDeepOrderedMembers(
     *   [1, { id: 1 }, { name: 'virk' }],
     *   [1, { id: 1 }, { name: 'virk' }]
     * ) // passes
     *
     * assert.sameDeepOrderedMembers(
     *   [1, { id: 1 }, { name: 'virk' }],
     *   [1, { name: 'virk' }, { id: 1 }]
     * ) // fails
     */
    sameDeepOrderedMembers(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.sameDeepOrderedMembers(...args);
    }
    /**
     * Expect two arrays to either have different members or in
     * different order
     *
     * The values comparison is same the `assert.notDeepEqual` method.
     * Use {@link notSameDeepOrderedMembers} for deep comparison
     *
     * @example
     * assert.notSameDeepOrderedMembers(
     *   [1, { id: 1 }, { name: 'virk' }],
     *   [1, { name: 'virk' }, { id: 1 }]
     * ) // passes
     *
     * assert.notSameDeepOrderedMembers(
     *   [1, { id: 1 }, { name: 'virk' }],
     *   [1, { id: 1 }, { name: 'virk' }]
     * ) // fails
     */
    notSameDeepOrderedMembers(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.notSameDeepOrderedMembers(...args);
    }
    /**
     * Assert the expected array is a subset of a given array.
     *
     * The values comparison is same the `assert.equal` method.
     * Use {@link includeDeepMembers} for deep comparsion.
     *
     * @example
     * assert.includeMembers([1, 2, 4, 5], [1, 2]) // passes
     * assert.includeMembers([1, 2, 4, 5], [1, 3]) // fails
     */
    includeMembers(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.includeMembers(...args);
    }
    /**
     * Assert the expected array is NOT a subset of a given array.
     *
     * The values comparison is same the `assert.notEqual` method.
     * Use {@link notIncludeDeepMembers} for deep comparsion.
     *
     * @example
     * assert.notIncludeMembers([1, 2, 4, 5], [1, 3]) // passes
     * assert.notIncludeMembers([1, 2, 4, 5], [1, 2]) // fails
     */
    notIncludeMembers(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.notIncludeMembers(...args);
    }
    /**
     * Assert the expected array is a subset of a given array.
     *
     * The values comparison is same the `assert.deepEqual` method.
     *
     * @example
     * assert.includeDeepMembers(
     *   [{ id: 1 }, { id: 2 }],
     *   [{ id: 2 }]
     * ) // passes
     *
     * assert.includeDeepMembers(
     *   [{ id: 1 }, { id: 2 }],
     *   [{ id: 3 }]
     * ) // fails
     */
    includeDeepMembers(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.includeDeepMembers(...args);
    }
    /**
     * Assert the expected array is NOT a subset of a given array.
     *
     * The values comparison is same the `assert.notDeepEqual` method.
     *
     * @example
     * assert.notIncludeDeepMembers(
     *   [{ id: 1 }, { id: 2 }],
     *   [{ id: 3 }]
     * ) // passes
     *
     * assert.notIncludeDeepMembers(
     *   [{ id: 1 }, { id: 2 }],
     *   [{ id: 2 }]
     * ) // fails
     */
    notIncludeDeepMembers(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert['notIncludeDeepMembers'](...args);
    }
    /**
     * Assert the expected array is a subset of a given array and
     * in the same order
     *
     * The values comparison is same the `assert.equal` method.
     * Use {@link includeDeepOrderedMembers} for deep comparsion.
     *
     * @example
     * assert.includeOrderedMembers(
     *   [1, 2, 4, 5],
     *   [1, 2, 4]
     * ) // passes
     *
     * assert.includeOrderedMembers(
     *   [1, 2, 4, 5],
     *   [1, 4, 2]
     * ) // fails
     *
     * assert.includeOrderedMembers(
     *   [1, 2, 4, 5],
     *   [1, 2, 5]
     * ) // fails
     */
    includeOrderedMembers(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.includeOrderedMembers(...args);
    }
    /**
     * Assert the expected array is either not a subset of
     * a given array or is not in the same order.
     *
     * The values comparison is same the `assert.notEqual` method.
     * Use {@link notIncludeDeepOrderedMembers} for deep comparsion.
     *
     * @example
     *
     * assert.notIncludeOrderedMembers(
     *   [1, 2, 4, 5],
     *   [1, 4, 2]
     * ) // passes
     *
     * assert.notIncludeOrderedMembers(
     *   [1, 2, 4, 5],
     *   [1, 2, 5]
     * ) // passes
     *
     * assert.notIncludeOrderedMembers(
     *   [1, 2, 4, 5],
     *   [1, 2, 4]
     * ) // fails
     */
    notIncludeOrderedMembers(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.notIncludeOrderedMembers(...args);
    }
    /**
     * Assert the expected array is a subset of a given array and
     * in the same order
     *
     * The values comparison is same the `assert.deepEqual` method.
     *
     * @example
     * assert.includeDeepOrderedMembers(
     *   [{ id: 1 }, { id: 2 }, { id: 4 }],
     *   [{ id: 1 }, { id: 2 }]
     * ) // passes
     *
     * assert.includeDeepOrderedMembers(
     *   [{ id: 1 }, { id: 2 }, { id: 4 }],
     *   [{ id: 1 }, { id: 4 }]
     * ) // fails
     *
     * assert.includeDeepOrderedMembers(
     *   [{ id: 1 }, { id: 2 }, { id: 4 }],
     *   [{ id: 1 }, { id: 4 }, { id: 2 }]
     * ) // fails
     */
    includeDeepOrderedMembers(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.includeDeepOrderedMembers(...args);
    }
    /**
     * Assert the expected array is either not a subset of
     * a given array or is not in the same order.
     *
     * The values comparison is same the `assert.notDeepEqual` method.
     *
     * @example
     *
     * assert.notIncludeDeepOrderedMembers(
     *   [{ id: 1 }, { id: 2 }, { id: 4 }],
     *   [{ id: 1 }, { id: 4 }]
     * ) // passes
     *
     * assert.notIncludeDeepOrderedMembers(
     *   [{ id: 1 }, { id: 2 }, { id: 4 }],
     *   [{ id: 1 }, { id: 4 }, { id: 2 }]
     * ) // passes
     *
     * assert.notIncludeDeepOrderedMembers(
     *   [{ id: 1 }, { id: 2 }, { id: 4 }],
     *   [{ id: 1 }, { id: 2 }]
     * ) // fails
     */
    notIncludeDeepOrderedMembers(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.notIncludeDeepOrderedMembers(...args);
    }
    /**
     * Assert the object is sealed.
     *
     * @example
     * assert.isSealed(Object.seal({})) // passes
     * assert.isSealed({}) // fails
     */
    isSealed(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isSealed(...args);
    }
    /**
     * Assert the object is sealed.
     *
     * @alias
     * isSealed
     *
     * @example
     * assert.sealed(Object.seal({})) // passes
     * assert.sealed({}) // fails
     */
    sealed(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.sealed(...args);
    }
    /**
     * Assert the object is not sealed.
     *
     * @example
     * assert.isNotSealed({}) // passes
     * assert.isNotSealed(Object.seal({})) // fails
     */
    isNotSealed(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isNotSealed(...args);
    }
    /**
     * Assert the object is not sealed.
     *
     * @alias
     * isNotSealed
     *
     * @example
     * assert.notSealed({}) // passes
     * assert.notSealed(Object.seal({})) // fails
     */
    notSealed(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.notSealed(...args);
    }
    /**
     * Assert the object is frozen.
     *
     * @example
     * assert.isFrozen(Object.freeze({})) // passes
     * assert.isFrozen({}) // fails
     */
    isFrozen(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isFrozen(...args);
    }
    /**
     * Assert the object is frozen.
     *
     * @alias
     * isFrozen
     *
     * @example
     * assert.frozen(Object.freeze({})) // passes
     * assert.frozen({}) // fails
     */
    frozen(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.frozen(...args);
    }
    /**
     * Assert the object is not frozen.
     *
     * @example
     * assert.isNotFrozen({}) // passes
     * assert.isNotFrozen(Object.freeze({})) // fails
     */
    isNotFrozen(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isNotFrozen(...args);
    }
    /**
     * Assert the object is not frozen.
     *
     * @alias
     * isNotFrozen
     *
     * @example
     * assert.notFrozen({}) // passes
     * assert.notFrozen(Object.freeze({})) // fails
     */
    notFrozen(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.notFrozen(...args);
    }
    /**
     * Assert value to be empty
     *
     * @example
     * assert.isEmpty([]) // passes
     * assert.isEmpty({}) // passes
     * assert.isEmpty('') // passes
     */
    isEmpty(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isEmpty(...args);
    }
    /**
     * Assert value to be empty
     *
     * @alias
     * isEmpty
     *
     * @example
     * assert.empty([]) // passes
     * assert.empty({}) // passes
     * assert.empty('') // passes
     */
    empty(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isEmpty(...args);
    }
    /**
     * Assert value to not be empty
     *
     * @example
     * assert.isNotEmpty([1, 2]) // passes
     * assert.isNotEmpty({ foo: 'bar' }) // passes
     * assert.isNotEmpty('hello') // passes
     */
    isNotEmpty(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isNotEmpty(...args);
    }
    /**
     * Assert value to not be empty
     *
     * @alias
     * isNotEmpty
     *
     * @example
     * assert.notEmpty([1, 2]) // passes
     * assert.notEmpty({ foo: 'bar' }) // passes
     * assert.notEmpty('hello') // passes
     */
    notEmpty(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.isNotEmpty(...args);
    }
    /**
     * Assert an array or an object to contain a subset of the expected
     * value. Useful for testing API responses.
     *
     * @example
     * assert.containsSubset(
     *   { id: 1, created_at: Date },
     *   { id: 1 }
     * ) // passes
     *
     * assert.containsSubset(
     *   [
     *     { id: 1, created_at: Date },
     *     { id: 2, created_at: Date }
     *   ],
     *   [{ id: 1 }, { id: 2 }]
     * ) // passes
     */
    containsSubset(haystack, needle, message) {
        this.incrementAssertionsCount();
        this.evaluate((0, utils_1.subsetCompare)(needle, haystack), 'expected #{act} to contain subset #{exp}', {
            expected: needle,
            actual: haystack,
            operator: 'containsSubset',
            prefix: message,
        });
    }
    /**
     * Assert an array or an object to not contain a subset of the expected
     * value.
     *
     * @example
     * assert.notContainsSubset(
     *   { id: 1, created_at: Date },
     *   { email: 'foo@bar.com' }
     * ) // passes
     */
    notContainsSubset(haystack, needle, message) {
        this.incrementAssertionsCount();
        this.evaluate(!(0, utils_1.subsetCompare)(needle, haystack), 'expected #{act} to not contain subset #{exp}', {
            expected: needle,
            actual: haystack,
            operator: 'notContainsSubset',
            prefix: message,
        });
    }
    /**
     * Assert the value is available in the provided list.
     *
     * @example
     * assert.oneOf('foo', ['foo', 'bar', 'baz']) // passes
     * assert.oneOf('foo', ['bar', 'baz']) // fails
     */
    oneOf(...args) {
        this.incrementAssertionsCount();
        return chai_1.assert.oneOf(...args);
    }
    async rejects(fn, errType, regExp, message) {
        let raisedException = null;
        this.incrementAssertionsCount();
        /**
         * Fn should be a valid function
         */
        if (typeof fn !== 'function') {
            return this.evaluate(false, 'expected #{this} to be a function', {
                thisObject: fn,
                expected: '',
                actual: '',
                prefix: message,
                operator: 'rejects',
            });
        }
        /**
         * Invoke the function
         */
        try {
            await fn();
        }
        catch (error) {
            raisedException = error;
        }
        /**
         * Normalizing values
         */
        const expectedExceptionClass = errType && typeof errType === 'function' ? errType : null;
        let expectedErrorMessageRegex = regExp && regExp instanceof RegExp ? regExp : null;
        let expectedErrorMessage = regExp && typeof regExp === 'string' ? regExp : null;
        if (!expectedErrorMessageRegex && !expectedErrorMessage && errType) {
            if (errType instanceof RegExp) {
                expectedErrorMessageRegex = errType;
            }
            else if (typeof errType === 'string') {
                expectedErrorMessage = errType;
            }
        }
        /**
         * No exception was raised
         */
        if (!raisedException) {
            return this.evaluate(false, 'expected #{this} to throw an error', {
                thisObject: fn,
                expected: '',
                actual: '',
                prefix: message,
                operator: 'rejects',
            });
        }
        /**
         * Expected constructors are different
         */
        if (expectedExceptionClass && raisedException instanceof expectedExceptionClass === false) {
            return this.evaluate(false, 'expected #{this} to throw #{exp} but #{act} was thrown', {
                thisObject: fn,
                expected: expectedExceptionClass,
                actual: raisedException,
                prefix: message,
                operator: 'rejects',
            });
        }
        /**
         * Message doesn't match the expected regex
         */
        if (expectedErrorMessageRegex && !expectedErrorMessageRegex.test(raisedException.message)) {
            return this.evaluate(false, 'expected #{this} to throw error matching #{exp} but got #{act}', {
                thisObject: fn,
                expected: expectedErrorMessageRegex,
                actual: raisedException.message,
                prefix: message,
                operator: 'rejects',
            });
        }
        /**
         * Message doesn't match the expected message
         */
        if (expectedErrorMessage && raisedException.message !== expectedErrorMessage) {
            return this.evaluate(false, 'expected #{this} to throw error including #{exp} but got #{act}', {
                thisObject: fn,
                expected: expectedErrorMessage,
                actual: raisedException.message,
                prefix: message,
                operator: 'rejects',
            });
        }
    }
    async doesNotRejects(fn, errType, regExp, message) {
        this.incrementAssertionsCount();
        let raisedException = null;
        /**
         * Fn should be a valid function
         */
        if (typeof fn !== 'function') {
            return this.evaluate(false, 'expected #{this} to be a function', {
                thisObject: fn,
                expected: '',
                actual: '',
                prefix: message,
                operator: 'doesNotRejects',
            });
        }
        /**
         * Invoke the function
         */
        try {
            await fn();
        }
        catch (error) {
            raisedException = error;
        }
        /**
         * No exception was raised (as expected)
         */
        if (!raisedException) {
            return;
        }
        /**
         * Normalizing values
         */
        const expectedExceptionClass = errType && typeof errType === 'function' ? errType : undefined;
        let expectedErrorMessageRegex = regExp && regExp instanceof RegExp ? regExp : undefined;
        let expectedErrorMessage = regExp && typeof regExp === 'string' ? regExp : undefined;
        const hasMatchingErrorClass = expectedExceptionClass && raisedException instanceof expectedExceptionClass;
        if (!expectedErrorMessageRegex && expectedErrorMessage === undefined && errType) {
            if (errType instanceof RegExp) {
                expectedErrorMessageRegex = errType;
            }
            else if (typeof errType === 'string') {
                expectedErrorMessage = errType;
            }
        }
        /**
         * Exception was raised and caller is not trying to narrow down the exception
         */
        if (!expectedErrorMessage && !expectedErrorMessageRegex && !expectedExceptionClass) {
            return this.evaluate(false, 'expected #{this} to not throw an error but #{act} was thrown', {
                thisObject: fn,
                expected: expectedExceptionClass,
                actual: raisedException,
                prefix: message,
                operator: 'doesNotRejects',
            });
        }
        /**
         * An exception was raised for not the expected error constructor
         */
        if (hasMatchingErrorClass && !expectedErrorMessage && !expectedErrorMessageRegex) {
            return this.evaluate(false, 'expected #{this} to not throw #{exp} but #{act} was thrown', {
                thisObject: fn,
                expected: expectedExceptionClass,
                actual: raisedException,
                prefix: message,
                operator: 'doesNotRejects',
            });
        }
        if (expectedErrorMessageRegex && expectedErrorMessageRegex.test(raisedException.message)) {
            return this.evaluate(false, 'expected #{this} to throw error not matching #{exp}', {
                thisObject: fn,
                expected: expectedErrorMessageRegex,
                actual: raisedException.message,
                prefix: message,
                operator: 'doesNotRejects',
            });
        }
        /**
         * Message doesn't match the expected message
         */
        if (expectedErrorMessage && raisedException.message === expectedErrorMessage) {
            return this.evaluate(false, hasMatchingErrorClass
                ? 'expected #{this} to not throw #{exp} but #{act} was thrown'
                : 'expected #{this} to throw error not including #{act}', {
                thisObject: fn,
                expected: hasMatchingErrorClass ? expectedExceptionClass : expectedErrorMessage,
                actual: hasMatchingErrorClass ? raisedException : raisedException.message,
                prefix: message,
                operator: 'doesNotRejects',
            });
        }
    }
    /**
     * Assert the response confirms to open API spec
     */
    isValidApiResponse(response) {
        if (!this.constructor['hasInstalledApiValidator']) {
            throw new Error('Cannot validate responses without defining api schemas');
        }
        return (0, chai_1.expect)(response).to.matchApiSchema();
    }
}
exports.Assert = Assert;
Assert.macros = {};
Assert.getters = {};
Assert.hasInstalledApiValidator = false;
