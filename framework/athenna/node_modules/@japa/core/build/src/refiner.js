"use strict";
/*
 * @japa/core
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Refiner = void 0;
const main_1 = require("./group/main");
/**
 * Exposes the API to refine unwanted tests based upon applied
 * filters.
 *
 * @example
 * const refiner = new Refiner({ tags: ['@slow'] })
 * refiner.allows('tags', ['@slow']) // true
 * refiner.allows('tags', ['@regression']) // false
 *
 * const refiner = new Refiner({ tags: [] })
 * refiner.allows('tags', ['@slow']) // true
 * refiner.allows('tags', ['@regression']) // true
 */
class Refiner {
    constructor(filters = {}) {
        /**
         * A set of pinned tests
         */
        this.pinnedTests = new Set();
        /**
         * Available filters
         */
        this.filters = {
            tags: [],
            tests: [],
            groups: [],
            negateTags: [],
        };
        if (filters.tags) {
            this.add('tags', filters.tags);
        }
        if (filters.tests) {
            this.add('tests', filters.tests);
        }
        if (filters.groups) {
            this.add('groups', filters.groups);
        }
    }
    /**
     * Find if the group is allowed to execute its tests.
     */
    isGroupAllowed(group) {
        const groupFilters = this.filters.groups;
        /**
         * Group filters exists and group title is not within the filters
         * list, then return false right away
         */
        if (groupFilters.length && !groupFilters.includes(group.title)) {
            return false;
        }
        /**
         * By default the group is not allowed to be executed. However,
         * we go through all the tests within that group and if
         * one or more tests are allowed to run, then we will
         * allow the group to run as well.
         *
         * Basically, we are checking the children to find if the group
         * should run or not.
         */
        let allowGroup = false;
        for (let test of group.tests) {
            allowGroup = this.allows(test);
            if (allowGroup) {
                break;
            }
        }
        return allowGroup;
    }
    /**
     * Find if the test is allowed to be executed by checking
     * for the test title filter
     */
    isTestTitleAllowed(test) {
        /**
         * All tests are allowed, when no filters are applied
         * on the test title
         */
        if (!this.filters.tests.length) {
            return true;
        }
        return this.filters.tests.includes(test.title);
    }
    /**
     * Find if test is allowed by the negated tags filter
     */
    allowedByNegatedTags(test) {
        if (!this.filters.negateTags.length) {
            return true;
        }
        /**
         * There should be zero matching negated tags
         */
        return this.filters.negateTags.every((tag) => !test.options.tags.includes(tag));
    }
    /**
     * Test if the test is allowed by the tags filter
     */
    allowedByTags(test) {
        if (!this.filters.tags.length) {
            return true;
        }
        /**
         * Find one or more matching tags
         */
        return this.filters.tags.some((tag) => test.options.tags.includes(tag));
    }
    /*
     * Find if the test is allowed to be executed by checking
     * for the test tags
     */
    areTestTagsAllowed(test) {
        return this.allowedByTags(test) && this.allowedByNegatedTags(test);
    }
    /*
     * Find if the test is allowed to be executed by checking
     * for the pinned tests
     */
    isAllowedByPinnedTest(test) {
        /**
         * All tests are allowed, when no tests are pinned
         */
        if (!this.pinnedTests.size) {
            return true;
        }
        return this.pinnedTests.has(test);
    }
    /**
     * Pin a test to be executed.
     */
    pinTest(test) {
        this.pinnedTests.add(test);
    }
    /**
     * Find if a test is pinned
     */
    isPinned(test) {
        return this.pinnedTests.has(test);
    }
    /**
     * Add a filter
     */
    add(layer, values) {
        if (layer === 'tags') {
            values.forEach((tag) => {
                if (tag.startsWith('!')) {
                    this.filters.negateTags.push(tag.slice(1));
                }
                else {
                    this.filters.tags.push(tag);
                }
            });
        }
        else {
            this.filters[layer].push(...values);
        }
    }
    /**
     * Check if refiner allows a specific test or group to run by looking
     * at the applied filters
     */
    allows(testOrGroup) {
        if (testOrGroup instanceof main_1.Group) {
            return this.isGroupAllowed(testOrGroup);
        }
        /**
         * Do not run lone tests when group filter is applied. It is responsibility
         * of the runner to attach groups to tests.
         */
        if (this.filters.groups.length && !testOrGroup.parent) {
            return false;
        }
        /**
         * Layer 1
         */
        const isTestTitleAllowed = this.isTestTitleAllowed(testOrGroup);
        if (!isTestTitleAllowed) {
            return false;
        }
        /**
         * Layer 2
         */
        const areTestTagsAllowed = this.areTestTagsAllowed(testOrGroup);
        if (!areTestTagsAllowed) {
            return false;
        }
        /**
         * Layer 3
         */
        return this.isAllowedByPinnedTest(testOrGroup);
    }
}
exports.Refiner = Refiner;
