"use strict";
/*
 * @japa/core
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestRunner = exports.DummyRunner = void 0;
const async_retry_1 = __importDefault(require("async-retry"));
const time_span_1 = __importDefault(require("time-span"));
const debug_1 = __importDefault(require("../debug"));
const interpolate_1 = require("../interpolate");
/**
 * Dummy test runner that just emits the required events
 */
class DummyRunner {
    constructor(test, emitter) {
        this.test = test;
        this.emitter = emitter;
    }
    /**
     * Notify the reporter about the test start
     */
    notifyStart() {
        const startOptions = {
            ...this.test.options,
            title: {
                original: this.test.options.title,
                expanded: this.test.options.title,
                toString() {
                    return this.original;
                },
            },
            isPinned: this.test.isPinned,
        };
        this.emitter.emit('test:start', startOptions);
    }
    /**
     * Notify the reporter about the test start
     */
    notifyEnd() {
        const endOptions = {
            ...this.test.options,
            title: {
                original: this.test.options.title,
                expanded: this.test.options.title,
                toString() {
                    return this.original;
                },
            },
            isPinned: this.test.isPinned,
            hasError: false,
            duration: 0,
            errors: [],
        };
        this.emitter.emit('test:end', endOptions);
    }
    /**
     * Run test
     */
    run() {
        this.notifyStart();
        this.notifyEnd();
    }
}
exports.DummyRunner = DummyRunner;
/**
 * Run an instance of test
 */
class TestRunner {
    constructor(test, hooks, emitter, disposeCalls, datasetCurrentIndex) {
        this.test = test;
        this.hooks = hooks;
        this.emitter = emitter;
        this.disposeCalls = disposeCalls;
        this.datasetCurrentIndex = datasetCurrentIndex;
        /**
         * Reference to the startup runner
         */
        this.setupRunner = this.hooks.runner('setup');
        /**
         * Reference to the cleanup runner
         */
        this.teardownRunner = this.hooks.runner('teardown');
        /**
         * Test errors
         */
        this.errors = [];
        /**
         * Track if test has any errors
         */
        this.hasError = false;
    }
    /**
     * Returns the dataset node for the test events
     */
    getDatasetNode() {
        if (this.datasetCurrentIndex !== undefined && this.test.dataset) {
            return {
                dataset: {
                    row: this.test.dataset[this.datasetCurrentIndex],
                    index: this.datasetCurrentIndex,
                    size: this.test.dataset.length,
                },
            };
        }
    }
    /**
     * Get the title node for the test
     */
    getTitle(dataset) {
        const title = this.test.options.title;
        return {
            original: title,
            expanded: dataset ? (0, interpolate_1.interpolate)(title, dataset.row, dataset.index + 1) : title,
            toString() {
                return this.original;
            },
        };
    }
    /**
     * Notify the reporter about the test start
     */
    notifyStart() {
        this.timeTracker = (0, time_span_1.default)();
        const dataset = this.getDatasetNode();
        const startOptions = {
            ...this.test.options,
            ...dataset,
            isPinned: this.test.isPinned,
            title: this.getTitle(dataset ? dataset.dataset : undefined),
        };
        this.emitter.emit('test:start', startOptions);
    }
    /**
     * Notify the reporter about the test start
     */
    notifyEnd() {
        const dataset = this.getDatasetNode();
        const endOptions = {
            ...this.test.options,
            ...dataset,
            isPinned: this.test.isPinned,
            title: this.getTitle(dataset ? dataset.dataset : undefined),
            hasError: this.hasError,
            errors: this.errors,
            retryAttempt: this.test.options.retryAttempt,
            duration: this.timeTracker.rounded(),
        };
        this.emitter.emit('test:end', endOptions);
    }
    /**
     * Running setup hooks
     */
    async runSetupHooks() {
        try {
            (0, debug_1.default)('running "%s" test setup hooks', this.test.title);
            await this.setupRunner.run(this.test);
        }
        catch (error) {
            (0, debug_1.default)('test setup hooks failed, test: %s, error: %O', this.test.title, error);
            this.hasError = true;
            this.errors.push({ phase: 'setup', error });
        }
    }
    /**
     * Running teardown hooks
     */
    async runTeardownHooks() {
        try {
            (0, debug_1.default)('running "%s" test teardown hooks', this.test.title);
            await this.teardownRunner.run(this.test);
        }
        catch (error) {
            (0, debug_1.default)('test teardown hooks failed, test: %s, error: %O', this.test.title, error);
            this.hasError = true;
            this.errors.push({ phase: 'teardown', error });
        }
    }
    /**
     * Running test cleanup functions
     */
    async runTestCleanupFunctions() {
        try {
            (0, debug_1.default)('running "%s" test cleanup functions', this.test.title);
            await this.hooks.runner('cleanup').run(this.errors.length > 0, this.test);
        }
        catch (error) {
            (0, debug_1.default)('test cleanup functions failed, test: %s, error: %O', this.test.title, error);
            this.hasError = true;
            this.errors.push({ phase: 'test:cleanup', error });
        }
    }
    /**
     * Running setup cleanup functions
     */
    async runSetupCleanupFunctions() {
        try {
            (0, debug_1.default)('running "%s" test setup cleanup functions', this.test.title);
            await this.setupRunner.cleanup(this.errors.length > 0, this.test);
        }
        catch (error) {
            (0, debug_1.default)('test setup cleanup functions failed, test: %s, error: %O', this.test.title, error);
            this.hasError = true;
            this.errors.push({ phase: 'setup:cleanup', error });
        }
    }
    /**
     * Running teardown cleanup functions
     */
    async runTeardownCleanupFunctions() {
        try {
            (0, debug_1.default)('running "%s" test teardown cleanup functions', this.test.title);
            await this.teardownRunner.cleanup(this.errors.length > 0, this.test);
        }
        catch (error) {
            (0, debug_1.default)('test teardown cleanup functions failed, test: %s, error: %O', this.test.title, error);
            this.hasError = true;
            this.errors.push({ phase: 'teardown:cleanup', error });
        }
    }
    /**
     * Run the test executor. The method takes care of passing
     * dataset row to the test method
     */
    async runTest(done) {
        const datasetRow = this.datasetCurrentIndex !== undefined && this.test.dataset
            ? this.test.dataset[this.datasetCurrentIndex]
            : undefined;
        return datasetRow !== undefined
            ? this.test.options.executor(this.test.context, datasetRow, done)
            : this.test.options.executor(this.test.context, done);
    }
    /**
     * Run the test executor that relies on the done method. The test will
     * timeout if done isn't called.
     */
    runTestWithDone() {
        return new Promise((resolve, reject) => {
            const done = (error) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve();
                }
            };
            /**
             * Done style tests the primary source of uncaught exceptions. Hence
             * we make an extra efforts to related uncaught exceptions with
             * them
             */
            if (!this.uncaughtExceptionHandler) {
                this.uncaughtExceptionHandler = (error) => {
                    reject(error);
                };
                process.on('uncaughtException', this.uncaughtExceptionHandler);
            }
            (0, debug_1.default)('running test "%s" and waiting for done method call', this.test.title);
            this.runTest(done).catch(reject);
        });
    }
    /**
     * Run the test executor and make sure it times out after the configured
     * timeout.
     */
    async wrapTestInTimeout() {
        if (!this.test.options.timeout) {
            return this.test.options.waitsForDone ? this.runTestWithDone() : this.runTest();
        }
        let timeoutTimer = null;
        const timeout = () => {
            return new Promise((_, reject) => {
                timeoutTimer = setTimeout(() => reject(new Error('Test timeout')), this.test.options.timeout);
            });
        };
        try {
            await Promise.race([
                this.test.options.waitsForDone ? this.runTestWithDone() : this.runTest(),
                timeout(),
            ]);
        }
        finally {
            if (timeoutTimer) {
                clearTimeout(timeoutTimer);
            }
        }
    }
    /**
     * Runs the test with retries in place
     */
    wrapTestInRetries() {
        if (!this.test.options.retries) {
            return this.wrapTestInTimeout();
        }
        return (0, async_retry_1.default)((_, attempt) => {
            this.test.options.retryAttempt = attempt;
            return this.wrapTestInTimeout();
        }, { retries: this.test.options.retries, factor: 1 });
    }
    /**
     * Run the test
     */
    async run() {
        (0, debug_1.default)('starting to run "%s" test', this.test.title);
        this.notifyStart();
        /**
         * Run setup hooks and exit early when one of the hooks
         * fails
         */
        await this.runSetupHooks();
        if (this.hasError) {
            await this.runSetupCleanupFunctions();
            this.notifyEnd();
            return;
        }
        /**
         * Run the test executor
         */
        try {
            await this.wrapTestInRetries();
        }
        catch (error) {
            this.hasError = true;
            this.errors.push({ phase: 'test', error });
        }
        finally {
            if (this.uncaughtExceptionHandler) {
                process.removeListener('uncaughtException', this.uncaughtExceptionHandler);
            }
        }
        /**
         * Run dispose callbacks
         */
        try {
            this.disposeCalls.forEach((callback) => callback(this.test, this.hasError, this.errors));
        }
        catch (error) {
            this.hasError = true;
            this.errors.push({ phase: 'test', error });
        }
        /**
         * Run test cleanup hooks
         */
        await this.runTestCleanupFunctions();
        /**
         * Cleanup setup hooks
         */
        await this.runSetupCleanupFunctions();
        /**
         * Run + cleanup teardown hooks
         */
        await this.runTeardownHooks();
        await this.runTeardownCleanupFunctions();
        /**
         * Notify test end
         */
        this.notifyEnd();
    }
}
exports.TestRunner = TestRunner;
