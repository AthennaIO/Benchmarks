"use strict";
/*
 * @japa/core
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Test = void 0;
const macroable_1 = require("macroable");
const hooks_1 = require("@poppinss/hooks");
const debug_1 = __importDefault(require("../debug"));
const runner_1 = require("./runner");
/**
 * Test class exposes a self contained API to configure and run
 * tests along with its hooks.
 *
 * @example
 * const test = new Test('2 + 2 = 4', emitter, refiner)
 *
 * test.run(async ({ assert }) => {
 *   assert.equal(2 + 2 , 4)
 * })
 */
class Test extends macroable_1.Macroable {
    /**
     * Find if the test is pinned
     */
    get isPinned() {
        return this.refiner.isPinned(this);
    }
    constructor(title, context, emitter, refiner, parent) {
        super();
        this.title = title;
        this.emitter = emitter;
        this.refiner = refiner;
        this.parent = parent;
        /**
         * Find if the test has already been executed
         */
        this.executed = false;
        /**
         * Reference to registered hooks
         */
        this.hooks = new hooks_1.Hooks();
        /**
         * Test options
         */
        this.options = {
            title: this.title,
            tags: [],
            timeout: 2000,
            meta: {},
        };
        /**
         * Make sure the instantiated class has its own property "disposeCalls"
         */
        if (!this.constructor.hasOwnProperty('disposeCallbacks')) {
            throw new Error(`Define static property "disposeCallbacks = []" on ${this.constructor.name} class`);
        }
        if (typeof context === 'function') {
            this.contextAccumlator = context;
        }
        else {
            this.context = context;
        }
    }
    /**
     * Find if test should be skipped
     */
    async computeShouldSkip() {
        if (this.skipAccumulator) {
            this.options.isSkipped = await this.skipAccumulator();
        }
    }
    /**
     * Find if test is a todo
     */
    computeisTodo() {
        this.options.isTodo = !this.options.executor;
    }
    /**
     * Returns the dataset array or undefined
     */
    async computeDataset() {
        if (typeof this.datasetAccumlator === 'function') {
            this.dataset = await this.datasetAccumlator();
        }
        return this.dataset;
    }
    /**
     * Get context instance for the test
     */
    async computeContext() {
        if (typeof this.contextAccumlator === 'function') {
            this.context = await this.contextAccumlator(this);
        }
        return this.context;
    }
    /**
     * Skip the test conditionally
     */
    skip(skip = true, skipReason) {
        if (typeof skip === 'function') {
            this.skipAccumulator = skip;
        }
        else {
            this.options.isSkipped = skip;
        }
        this.options.skipReason = skipReason;
        return this;
    }
    /**
     * Expect the test to fail. Helpful in creating test cases
     * to showcase bugs
     */
    fails(failReason) {
        this.options.isFailing = true;
        this.options.failReason = failReason;
        return this;
    }
    /**
     * Define custom timeout for the test
     */
    timeout(timeout) {
        this.options.timeout = timeout;
        return this;
    }
    /**
     * Disable test timeout. It is same as calling `test.timeout(0)`
     */
    disableTimeout() {
        return this.timeout(0);
    }
    /**
     * Assign tags to the test. Later you can use the tags to run
     * specific tests
     */
    tags(tags, strategy = 'replace') {
        if (strategy === 'replace') {
            this.options.tags = tags;
            return this;
        }
        if (strategy === 'prepend') {
            this.options.tags = tags.concat(this.options.tags);
            return this;
        }
        this.options.tags = this.options.tags.concat(tags);
        return this;
    }
    /**
     * Configure the number of times this test should be retried
     * when failing.
     */
    retry(retries) {
        this.options.retries = retries;
        return this;
    }
    /**
     * Wait for the test executor to call done method
     */
    waitForDone() {
        this.options.waitsForDone = true;
        return this;
    }
    /**
     * Pin current test. Pinning a test will only run the
     * pinned tests.
     */
    pin() {
        this.refiner.pinTest(this);
        return this;
    }
    /**
     * Define a dispose callback.
     *
     * Do note: Async methods are not allowed
     */
    static dispose(callback) {
        this.disposeCallbacks.push(callback);
    }
    /**
     * Define the dataset for the test. The test executor will be invoked
     * for all the items inside the dataset array
     */
    with(dataset) {
        if (Array.isArray(dataset)) {
            this.dataset = dataset;
            return this;
        }
        if (typeof dataset === 'function') {
            this.datasetAccumlator = dataset;
            return this;
        }
        throw new Error('dataset must be an array or a function that returns an array');
    }
    /**
     * Define the test executor function
     */
    run(executor) {
        this.options.executor = executor;
        return this;
    }
    /**
     * Register a test setup function
     */
    setup(handler) {
        (0, debug_1.default)('registering "%s" test setup hook %s', this.title, handler);
        this.hooks.add('setup', handler);
        return this;
    }
    /**
     * Register a test teardown function
     */
    teardown(handler) {
        (0, debug_1.default)('registering "%s" test teardown hook %s', this.title, handler);
        this.hooks.add('teardown', handler);
        return this;
    }
    /**
     * Register a cleanup hook from within the test
     */
    cleanup(handler) {
        (0, debug_1.default)('registering "%s" test cleanup function %s', this.title, handler);
        this.hooks.add('cleanup', handler);
        return this;
    }
    /**
     * Execute test
     */
    async exec() {
        /**
         * Return early, if there are pinned test and the current test is not
         * pinned.
         *
         * However, the pinned test check is only applied when there
         * is no filter on the test title.
         */
        if (!this.refiner.allows(this)) {
            (0, debug_1.default)('test "%s" skipped by refiner', this.title);
            return;
        }
        /**
         * Avoid re-running the same test multiple times
         */
        if (this.executed) {
            return;
        }
        this.executed = true;
        /**
         * Do not run tests without executor function
         */
        this.computeisTodo();
        if (this.options.isTodo) {
            (0, debug_1.default)('skipping todo test "%s"', this.title);
            new runner_1.DummyRunner(this, this.emitter).run();
            return;
        }
        /**
         * Do not run test meant to be skipped
         */
        await this.computeShouldSkip();
        if (this.options.isSkipped) {
            (0, debug_1.default)('skipping test "%s", reason (%s)', this.title, this.options.skipReason || 'Skipped using .skip method');
            new runner_1.DummyRunner(this, this.emitter).run();
            return;
        }
        /**
         * Run for each row inside dataset
         */
        await this.computeDataset();
        if (Array.isArray(this.dataset) && this.dataset.length) {
            let index = 0;
            // eslint-disable-next-line @typescript-eslint/naming-convention
            for (let _ of this.dataset) {
                await this.computeContext();
                await new runner_1.TestRunner(this, this.hooks, this.emitter, this.constructor.disposeCallbacks, index).run();
                index++;
            }
            return;
        }
        /**
         * Run when no dataset is used
         */
        await this.computeContext();
        await new runner_1.TestRunner(this, this.hooks, this.emitter, this.constructor.disposeCallbacks).run();
    }
}
exports.Test = Test;
Test.macros = {};
Test.getters = {};
/**
 * Methods to call before disposing the test
 */
Test.disposeCallbacks = [];
