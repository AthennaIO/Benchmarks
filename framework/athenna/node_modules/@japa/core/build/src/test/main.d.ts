import { Macroable } from 'macroable';
import { Group } from '../group/main';
import { Emitter } from '../emitter';
import { Refiner } from '../refiner';
import { DataSetNode, TestEndNode, TestOptions, TestExecutor, TestHooksHandler, TestHooksCleanupHandler } from '../types';
/**
 * Test class exposes a self contained API to configure and run
 * tests along with its hooks.
 *
 * @example
 * const test = new Test('2 + 2 = 4', emitter, refiner)
 *
 * test.run(async ({ assert }) => {
 *   assert.equal(2 + 2 , 4)
 * })
 */
export declare class Test<Context extends Record<any, any>, TestData extends DataSetNode = undefined> extends Macroable {
    title: string;
    private emitter;
    private refiner;
    parent?: Group<Context> | undefined;
    static macros: {};
    static getters: {};
    /**
     * Methods to call before disposing the test
     */
    static disposeCallbacks: ((test: Test<any, any>, hasError: boolean, errors: TestEndNode['errors']) => void)[];
    /**
     * Find if the test has already been executed
     */
    private executed;
    /**
     * Reference to registered hooks
     */
    private hooks;
    /**
     * Test options
     */
    options: TestOptions;
    /**
     * Reference to the test dataset
     */
    dataset?: any[];
    /**
     * Reference to the test context. Available at the time
     * of running the test
     */
    context: Context;
    /**
     * Find if the test is pinned
     */
    get isPinned(): boolean;
    /**
     * The function for creating the test context
     */
    private contextAccumlator?;
    /**
     * The function for computing if test should
     * be skipped or not
     */
    private skipAccumulator?;
    /**
     * The function that returns the test data set
     */
    private datasetAccumlator?;
    constructor(title: string, context: Context | ((test: Test<Context, TestData>) => Context | Promise<Context>), emitter: Emitter, refiner: Refiner, parent?: Group<Context> | undefined);
    /**
     * Find if test should be skipped
     */
    private computeShouldSkip;
    /**
     * Find if test is a todo
     */
    private computeisTodo;
    /**
     * Returns the dataset array or undefined
     */
    private computeDataset;
    /**
     * Get context instance for the test
     */
    private computeContext;
    /**
     * Skip the test conditionally
     */
    skip(skip?: boolean | (() => Promise<boolean> | boolean), skipReason?: string): this;
    /**
     * Expect the test to fail. Helpful in creating test cases
     * to showcase bugs
     */
    fails(failReason?: string): this;
    /**
     * Define custom timeout for the test
     */
    timeout(timeout: number): this;
    /**
     * Disable test timeout. It is same as calling `test.timeout(0)`
     */
    disableTimeout(): this;
    /**
     * Assign tags to the test. Later you can use the tags to run
     * specific tests
     */
    tags(tags: string[], strategy?: 'replace' | 'append' | 'prepend'): this;
    /**
     * Configure the number of times this test should be retried
     * when failing.
     */
    retry(retries: number): this;
    /**
     * Wait for the test executor to call done method
     */
    waitForDone(): this;
    /**
     * Pin current test. Pinning a test will only run the
     * pinned tests.
     */
    pin(): this;
    /**
     * Define a dispose callback.
     *
     * Do note: Async methods are not allowed
     */
    static dispose(callback: (test: Test<any, any>, hasError: boolean, errors: TestEndNode['errors']) => void): void;
    /**
     * Define the dataset for the test. The test executor will be invoked
     * for all the items inside the dataset array
     */
    with<Dataset extends DataSetNode>(dataset: Dataset): Test<Context, Dataset>;
    /**
     * Define the test executor function
     */
    run(executor: TestExecutor<Context, TestData>): this;
    /**
     * Register a test setup function
     */
    setup(handler: TestHooksHandler<Context>): this;
    /**
     * Register a test teardown function
     */
    teardown(handler: TestHooksHandler<Context>): this;
    /**
     * Register a cleanup hook from within the test
     */
    cleanup(handler: TestHooksCleanupHandler<Context>): this;
    /**
     * Execute test
     */
    exec(): Promise<void>;
}
