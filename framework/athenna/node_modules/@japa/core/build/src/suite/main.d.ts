import { Macroable } from 'macroable';
import { Emitter } from '../emitter';
import { Test } from '../test/main';
import { Refiner } from '../refiner';
import { Group } from '../group/main';
import { SuiteHooksHandler } from '../types';
/**
 * The Suite class exposes the API to run a group of tests
 * or independent tests together as part of a suite.
 *
 * You can think of suites as
 *   - unit tests suite
 *   - e2e tests suites
 *   - and so on
 *
 * @example
 * const suite = new Suite('unit', emitter)
 * const group = new Group('addition', emitter, refiner)
 * const test = new Test('2 + 2 = 4', emitter, refiner)
 *
 * suite.add(group)
 * group.add(test)
 *
 * // Runs all the tests inside the registered group
 * await suite.exec()
 */
export declare class Suite<Context extends Record<any, any>> extends Macroable {
    name: string;
    private emitter;
    private refiner;
    static macros: {};
    static getters: {};
    /**
     * Reference to registered hooks
     */
    private hooks;
    /**
     * Callbacks to invoke on each test and group
     */
    private configureTestCallbacks;
    private configureGroupCallbacks;
    /**
     * A collection of tests and groups both
     */
    stack: (Test<Context, any> | Group<Context>)[];
    constructor(name: string, emitter: Emitter, refiner: Refiner);
    /**
     * Add a test or a group to the execution stack
     */
    add(testOrGroup: Test<Context, any> | Group<Context>): this;
    /**
     * Tap into each test and configure it
     */
    onTest(callback: (test: Test<Context, any>) => void): this;
    /**
     * Tap into each group and configure it
     */
    onGroup(callback: (group: Group<Context>) => void): this;
    /**
     * Register a test setup function
     */
    setup(handler: SuiteHooksHandler<Context>): this;
    /**
     * Register a test teardown function
     */
    teardown(handler: SuiteHooksHandler<Context>): this;
    /**
     * Execute suite groups, tests and hooks
     */
    exec(): Promise<void>;
}
