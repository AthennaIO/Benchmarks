"use strict";
/*
 * @japa/core
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Suite = void 0;
const macroable_1 = require("macroable");
const hooks_1 = require("@poppinss/hooks");
const debug_1 = __importDefault(require("../debug"));
const main_1 = require("../test/main");
const main_2 = require("../group/main");
const runner_1 = require("./runner");
/**
 * The Suite class exposes the API to run a group of tests
 * or independent tests together as part of a suite.
 *
 * You can think of suites as
 *   - unit tests suite
 *   - e2e tests suites
 *   - and so on
 *
 * @example
 * const suite = new Suite('unit', emitter)
 * const group = new Group('addition', emitter, refiner)
 * const test = new Test('2 + 2 = 4', emitter, refiner)
 *
 * suite.add(group)
 * group.add(test)
 *
 * // Runs all the tests inside the registered group
 * await suite.exec()
 */
class Suite extends macroable_1.Macroable {
    constructor(name, emitter, refiner) {
        super();
        this.name = name;
        this.emitter = emitter;
        this.refiner = refiner;
        /**
         * Reference to registered hooks
         */
        this.hooks = new hooks_1.Hooks();
        /**
         * Callbacks to invoke on each test and group
         */
        this.configureTestCallbacks = [];
        this.configureGroupCallbacks = [];
        /**
         * A collection of tests and groups both
         */
        this.stack = [];
    }
    /**
     * Add a test or a group to the execution stack
     */
    add(testOrGroup) {
        if (testOrGroup instanceof main_2.Group) {
            this.configureGroupCallbacks.forEach((callback) => callback(testOrGroup));
        }
        if (testOrGroup instanceof main_1.Test) {
            this.configureTestCallbacks.forEach((callback) => callback(testOrGroup));
        }
        this.stack.push(testOrGroup);
        return this;
    }
    /**
     * Tap into each test and configure it
     */
    onTest(callback) {
        this.configureTestCallbacks.push(callback);
        return this;
    }
    /**
     * Tap into each group and configure it
     */
    onGroup(callback) {
        this.configureGroupCallbacks.push(callback);
        return this;
    }
    /**
     * Register a test setup function
     */
    setup(handler) {
        (0, debug_1.default)('registering suite setup hook %s', handler);
        this.hooks.add('setup', handler);
        return this;
    }
    /**
     * Register a test teardown function
     */
    teardown(handler) {
        (0, debug_1.default)('registering suite teardown hook %s', handler);
        this.hooks.add('teardown', handler);
        return this;
    }
    /**
     * Execute suite groups, tests and hooks
     */
    async exec() {
        /**
         * By default a suite is not allowed to be executed. However, we go
         * through all the tests/ groups within the suite  and if one
         * or more tests/groups are allowed to run, then we will
         * allow the suite to run as well.
         *
         * Basically, we are checking the children to find if the suite
         * should run or not.
         */
        let allowSuite = false;
        for (let item of this.stack) {
            allowSuite = this.refiner.allows(item);
            if (allowSuite) {
                break;
            }
        }
        if (!allowSuite) {
            (0, debug_1.default)('suite disabled by refiner %s', this.name);
            return;
        }
        await new runner_1.SuiteRunner(this, this.hooks, this.emitter).run();
    }
}
exports.Suite = Suite;
Suite.macros = {};
Suite.getters = {};
