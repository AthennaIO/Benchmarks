"use strict";
/*
 * @japa/core
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Runner = void 0;
const macroable_1 = require("macroable");
const debug_1 = __importDefault(require("./debug"));
const tracker_1 = require("./tracker");
/**
 * The Runner class exposes the API to register test suites and execute
 * them sequentially.
 *
 * @example
 * const runner = new Runner(emitter)
 * const suite = new Suite('unit', emitter)
 *
 * runner.add(suite)
 * runner.registerReporter(reporters.list)
 *
 * await runner.exec()
 */
class Runner extends macroable_1.Macroable {
    constructor(emitter) {
        super();
        this.emitter = emitter;
        /**
         * Callbacks to invoke on every suite
         */
        this.configureSuiteCallbacks = [];
        /**
         * A collection of suites
         */
        this.suites = [];
        /**
         * Registered tests reporter
         */
        this.reporters = new Set();
    }
    /**
     * Notify the reporter about the runner start
     */
    notifyStart() {
        return this.emitter.emit('runner:start', {});
    }
    /**
     * Notify the reporter about the runner end
     */
    notifyEnd() {
        return this.emitter.emit('runner:end', {});
    }
    /**
     * Boot the runner
     */
    boot() {
        this.tracker = new tracker_1.Tracker();
        this.emitter.on('uncaught:exception', (payload) => this.tracker.processEvent('uncaught:exception', payload));
        this.emitter.on('runner:start', (payload) => this.tracker.processEvent('runner:start', payload));
        this.emitter.on('runner:end', (payload) => this.tracker.processEvent('runner:end', payload));
        this.emitter.on('suite:start', (payload) => this.tracker.processEvent('suite:start', payload));
        this.emitter.on('suite:end', (payload) => this.tracker.processEvent('suite:end', payload));
        this.emitter.on('group:start', (payload) => this.tracker.processEvent('group:start', payload));
        this.emitter.on('group:end', (payload) => this.tracker.processEvent('group:end', payload));
        this.emitter.on('test:start', (payload) => this.tracker.processEvent('test:start', payload));
        this.emitter.on('test:end', (payload) => this.tracker.processEvent('test:end', payload));
    }
    /**
     * Add a suite to the runner
     */
    add(suite) {
        this.configureSuiteCallbacks.forEach((callback) => callback(suite));
        this.suites.push(suite);
        (0, debug_1.default)('registering suite %s', suite.name);
        return this;
    }
    /**
     * Tap into each suite and configure it
     */
    onSuite(callback) {
        this.configureSuiteCallbacks.push(callback);
        return this;
    }
    /**
     * Register a tests reporter
     */
    registerReporter(reporter) {
        this.reporters.add(reporter);
        return this;
    }
    /**
     * Manage unhandled exceptions occurred during tests
     */
    manageUnHandledExceptions() {
        if (!this.uncaughtExceptionHandler) {
            this.uncaughtExceptionHandler = (error) => this.emitter.emit('uncaught:exception', error);
            process.on('uncaughtException', this.uncaughtExceptionHandler);
        }
        return this;
    }
    /**
     * Get tests summary
     */
    getSummary() {
        return this.tracker.getSummary();
    }
    /**
     * Start the test runner process. The method emits
     * "runner:start" event
     */
    async start() {
        this.boot();
        (0, debug_1.default)('starting to run tests');
        for (let reporter of this.reporters) {
            if (typeof reporter === 'function') {
                await reporter(this, this.emitter);
            }
            else {
                await reporter.handler(this, this.emitter);
            }
        }
        await this.notifyStart();
    }
    /**
     * Execute runner suites
     */
    async exec() {
        for (let suite of this.suites) {
            await suite.exec();
        }
    }
    /**
     * End the runner process. Emits "runner:end" event
     */
    async end() {
        await this.notifyEnd();
    }
}
exports.Runner = Runner;
Runner.macros = {};
Runner.getters = {};
