"use strict";
/*
 * @japa/core
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GroupRunner = void 0;
const debug_1 = __importDefault(require("../debug"));
/**
 * Run all tests for a given group
 */
class GroupRunner {
    constructor(group, hooks, emitter) {
        this.group = group;
        this.hooks = hooks;
        this.emitter = emitter;
        /**
         * Reference to the startup runner
         */
        this.setupRunner = this.hooks.runner('setup');
        /**
         * Reference to the cleanup runner
         */
        this.teardownRunner = this.hooks.runner('teardown');
        /**
         * Test errors
         */
        this.errors = [];
        /**
         * Track if test has any errors
         */
        this.hasError = false;
    }
    /**
     * Notify the reporter about the group start
     */
    notifyStart() {
        const startOptions = { ...this.group.options };
        this.emitter.emit('group:start', startOptions);
    }
    /**
     * Notify the reporter about the group end
     */
    notifyEnd() {
        const endOptions = {
            ...this.group.options,
            hasError: this.hasError,
            errors: this.errors,
        };
        this.emitter.emit('group:end', endOptions);
    }
    /**
     * Running setup hooks
     */
    async runSetupHooks() {
        try {
            (0, debug_1.default)('running "%s" group setup hooks', this.group.title);
            await this.setupRunner.run(this.group);
        }
        catch (error) {
            (0, debug_1.default)('group setup hooks failed, group: %s, error: %O', this.group.title, error);
            this.hasError = true;
            this.errors.push({ phase: 'setup', error });
        }
    }
    /**
     * Running teardown hooks
     */
    async runTeardownHooks() {
        try {
            (0, debug_1.default)('running "%s" group teardown hooks', this.group.title);
            await this.teardownRunner.run(this.group);
        }
        catch (error) {
            (0, debug_1.default)('group teardown hooks failed, group: %s, error: %O', this.group.title, error);
            this.hasError = true;
            this.errors.push({ phase: 'teardown', error });
        }
    }
    /**
     * Running setup cleanup functions
     */
    async runSetupCleanupFunctions() {
        try {
            (0, debug_1.default)('running "%s" group setup cleanup functions', this.group.title);
            await this.setupRunner.cleanup(this.hasError, this.group);
        }
        catch (error) {
            (0, debug_1.default)('group setup cleanup function failed, group: %s, error: %O', this.group.title, error);
            this.hasError = true;
            this.errors.push({ phase: 'setup:cleanup', error });
        }
    }
    /**
     * Running teardown cleanup functions
     */
    async runTeardownCleanupFunctions() {
        try {
            (0, debug_1.default)('running "%s" group teardown cleanup functions', this.group.title);
            await this.teardownRunner.cleanup(this.hasError, this.group);
        }
        catch (error) {
            (0, debug_1.default)('group teardown cleanup function failed, group: %s, error: %O', this.group.title, error);
            this.hasError = true;
            this.errors.push({ phase: 'teardown:cleanup', error });
        }
    }
    /**
     * Run the test
     */
    async run() {
        (0, debug_1.default)('starting to run "%s" group', this.group.title);
        this.notifyStart();
        /**
         * Run setup hooks and exit early when one of the hooks
         * fails
         */
        await this.runSetupHooks();
        if (this.hasError) {
            await this.runSetupCleanupFunctions();
            this.notifyEnd();
            return;
        }
        /**
         * Run the test executor
         */
        for (let test of this.group.tests) {
            await test.exec();
        }
        /**
         * Cleanup setup hooks
         */
        await this.runSetupCleanupFunctions();
        /**
         * Run + cleanup teardown hooks
         */
        await this.runTeardownHooks();
        await this.runTeardownCleanupFunctions();
        /**
         * Notify test end
         */
        this.notifyEnd();
    }
}
exports.GroupRunner = GroupRunner;
