"use strict";
/*
 * @japa/core
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tracker = void 0;
const time_span_1 = __importDefault(require("time-span"));
/**
 * Tracks the tests events to generate a summary report. Failing tests are further tracked
 * for complete hierarchy
 */
class Tracker {
    constructor() {
        /**
         * If the entire run cycle has one or more errors
         */
        this.hasError = false;
        /**
         * Storing state if current suite and group has errors. These
         * errors are not directly from the suite and groups, but
         * instead from their children.
         *
         * For example: If a test fails, it marks both current group
         * and suite has errors.
         */
        this.currentSuiteHasError = false;
        this.currentGroupHasError = false;
        this.aggregates = {
            total: 0,
            failed: 0,
            passed: 0,
            regression: 0,
            skipped: 0,
            todo: 0,
            uncaughtExceptions: 0,
        };
        this.duration = 0;
        /**
         * A tree of suites/groups and tests that have failed. They are always nested inside
         * other unless the test groups where used, then suites contains a list of tests
         * directly.
         */
        this.failureTree = [];
        this.failedTestsTitles = [];
    }
    /**
     * Set reference for the current suite
     */
    onSuiteStart(payload) {
        this.currentSuiteHasError = false;
        this.currentSuite = {
            name: payload.name,
            type: 'suite',
            errors: [],
            children: [],
        };
    }
    /**
     * Move suite to the failure tree when the suite
     * has errors
     */
    onSuiteEnd(payload) {
        if (payload.hasError) {
            this.hasError = true;
            this.currentSuiteHasError = true;
            this.currentSuite.errors = payload.errors;
        }
        if (this.currentSuiteHasError) {
            this.failureTree.push(this.currentSuite);
        }
    }
    /**
     * Set reference for the current group
     */
    onGroupStart(payload) {
        this.currentGroupHasError = false;
        this.currentGroup = {
            name: payload.title,
            type: 'group',
            errors: [],
            children: [],
        };
    }
    /**
     * Move suite to the failure tree when the suite
     * has errors
     */
    onGroupEnd(payload) {
        if (payload.hasError) {
            this.hasError = true;
            this.currentGroupHasError = true;
            this.currentGroup.errors = payload.errors;
        }
        if (this.currentGroupHasError) {
            this.currentSuiteHasError = true;
            this.currentSuite.children.push(this.currentGroup);
        }
    }
    /**
     * In case of failure, track the test inside the current group
     * or the current suite.
     */
    onTestEnd(payload) {
        /**
         * Bumping aggregates
         */
        this.aggregates.total++;
        /**
         * Test was skipped
         */
        if (payload.isSkipped) {
            this.aggregates.skipped++;
            return;
        }
        /**
         * Test was a todo
         */
        if (payload.isTodo) {
            this.aggregates.todo++;
            return;
        }
        /**
         * Regression test. Mark test as failed, when there is no error
         * Because, we expect regression tests to have errors.
         *
         * However, there is no need to move anything to the failure
         * tree, since there is no real error
         */
        if (payload.isFailing) {
            if (!payload.hasError) {
                this.aggregates.failed++;
                this.hasError = true;
            }
            else {
                this.aggregates.regression++;
            }
            return;
        }
        /**
         * Test completed successfully
         */
        if (!payload.hasError) {
            this.aggregates.passed++;
            return;
        }
        this.markTestAsFailed(payload);
    }
    /**
     * Mark test as failed
     */
    markTestAsFailed(payload) {
        /**
         * Bump failed count
         */
        this.aggregates.failed++;
        this.hasError = true;
        /**
         * Test payload
         */
        const testPayload = {
            type: 'test',
            title: payload.title.expanded,
            errors: payload.errors,
        };
        /**
         * Track test inside the current group or suite
         */
        if (this.currentGroup) {
            this.currentGroupHasError = true;
            this.currentGroup.children.push(testPayload);
        }
        else if (this.currentSuite) {
            this.currentSuiteHasError = true;
            this.currentSuite.children.push(testPayload);
        }
        /**
         * Push title to the failedTestsTitles array
         */
        this.failedTestsTitles.push(payload.title.original);
    }
    /**
     * Increment the count of uncaught exceptions
     */
    onUncaughtException() {
        this.aggregates.uncaughtExceptions++;
        this.hasError = true;
    }
    /**
     * Process the tests events
     */
    processEvent(event, payload) {
        switch (event) {
            case 'uncaught:exception':
                this.onUncaughtException();
                break;
            case 'suite:start':
                this.onSuiteStart(payload);
                break;
            case 'suite:end':
                this.onSuiteEnd(payload);
                break;
            case 'group:start':
                this.onGroupStart(payload);
                break;
            case 'group:end':
                this.onGroupEnd(payload);
                break;
            case 'test:end':
                this.onTestEnd(payload);
                break;
            case 'runner:start':
                this.timeTracker = (0, time_span_1.default)();
                break;
            case 'runner:end':
                this.duration = this.timeTracker.rounded();
                break;
        }
    }
    /**
     * Returns the tests runner summary
     */
    getSummary() {
        return {
            aggregates: this.aggregates,
            hasError: this.hasError,
            duration: this.duration,
            failureTree: this.failureTree,
            failedTestsTitles: this.failedTestsTitles,
        };
    }
}
exports.Tracker = Tracker;
