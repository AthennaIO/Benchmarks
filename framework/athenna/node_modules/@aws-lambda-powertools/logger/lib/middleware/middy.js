"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectLambdaContext = void 0;
const Logger_1 = require("../Logger");
const middleware_1 = require("@aws-lambda-powertools/commons/lib/middleware");
/**
 * A middy middleware that helps emitting CloudWatch EMF metrics in your logs.
 *
 * Using this middleware on your handler function will automatically add context information to logs, as well as optionally log the event and clear attributes set during the invocation.
 *
 * @example
 * ```typescript
 * import { Logger, injectLambdaContext } from '@aws-lambda-powertools/logger';
 * import middy from '@middy/core';
 *
 *
 * const logger = new Logger();
 *
 * const lambdaHandler = async (_event: any, _context: any) => {
 *     logger.info('This is an INFO log with some context');
 * };
 *
 * export const handler = middy(lambdaHandler).use(injectLambdaContext(logger));
 * ```
 *
 * @param target - The Logger instance(s) to use for logging
 * @param options - (_optional_) Options for the middleware
 * @returns - The middy middleware object
 */
const injectLambdaContext = (target, options) => {
    const loggers = target instanceof Array ? target : [target];
    const persistentAttributes = [];
    const isClearState = options && options.clearState === true;
    /**
     * Set the cleanup function to be called in case other middlewares return early.
     *
     * @param request - The request object
     */
    const setCleanupFunction = (request) => {
        request.internal = {
            ...request.internal,
            [middleware_1.LOGGER_KEY]: injectLambdaContextAfterOrOnError,
        };
    };
    const injectLambdaContextBefore = async (request) => {
        loggers.forEach((logger, index) => {
            if (isClearState) {
                persistentAttributes[index] = {
                    ...logger.getPersistentLogAttributes(),
                };
                setCleanupFunction(request);
            }
            Logger_1.Logger.injectLambdaContextBefore(logger, request.event, request.context, options);
        });
    };
    const injectLambdaContextAfterOrOnError = async () => {
        if (isClearState) {
            loggers.forEach((logger, index) => {
                Logger_1.Logger.injectLambdaContextAfterOrOnError(logger, persistentAttributes[index], options);
            });
        }
    };
    return {
        before: injectLambdaContextBefore,
        after: injectLambdaContextAfterOrOnError,
        onError: injectLambdaContextAfterOrOnError,
    };
};
exports.injectLambdaContext = injectLambdaContext;
