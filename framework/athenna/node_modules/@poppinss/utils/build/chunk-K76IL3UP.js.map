{"version":3,"sources":["../src/string/bytes.ts","../src/string/seconds.ts","../src/string/slugify.ts","../src/string/random.ts","../src/string/excerpt.ts","../src/string/ordinal.ts","../src/string/truncate.ts","../src/string/sentence.ts","../src/string/interpolate.ts","../src/string/pluralize.ts","../src/string/change_case.ts","../src/string/main.ts"],"sourcesContent":["/*\n * @poppinss/utils\n *\n * (c) Poppinss\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport bytes, { BytesOptions } from 'bytes'\n\nexport default {\n  format(valueInBytes: number, options?: BytesOptions): string {\n    return bytes.format(valueInBytes, options)\n  },\n\n  /**\n   * Parse the unit expression to bytes. If the unit value\n   * is a number, then it will be returned as it is considering\n   * it is already in bytes.\n   */\n  parse(unit: string | number): number {\n    if (typeof unit === 'number') {\n      return unit\n    }\n\n    return bytes.parse(unit)\n  },\n}\n","/*\n * @poppinss/utils\n *\n * (c) Poppinss\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { parse, format } from '@lukeed/ms'\n\nexport default {\n  format(seconds: number, long?: boolean): string {\n    return format(seconds * 1000, long)\n  },\n\n  /**\n   * Parse time expression string to seconds. The number value\n   * is returned as it is, considering it is already in seconds\n   */\n  parse(duration: string | number): number {\n    if (typeof duration === 'number') {\n      return duration\n    }\n\n    const milliseconds = parse(duration)\n    if (milliseconds === undefined) {\n      throw new Error(`Invalid duration expression \"${duration}\"`)\n    }\n\n    return Math.floor(milliseconds / 1000)\n  },\n}\n","/*\n * @poppinss/utils\n *\n * (c) Poppinss\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { default as slugifyPkg } from 'slugify'\n\n/**\n * Typings of the slugify package are a bit off and therefore we have\n * to do this manual dance of re-assigning types\n */\nexport const slug = slugifyPkg as unknown as (typeof slugifyPkg)['default']\n","/*\n * @poppinss/utils\n *\n * (c) Poppinss\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { randomBytes } from 'node:crypto'\nimport { base64 } from '../base64.js'\n\n/**\n * Generates a random string of a given size\n */\nexport function random(size: number): string {\n  const bits = (size + 1) * 6\n  const buffer = randomBytes(Math.ceil(bits / 8))\n  return base64.urlEncode(buffer).slice(0, size)\n}\n","/*\n * @poppinss/utils\n *\n * (c) Poppinss\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n// @ts-expect-error (Package has no types)\nimport truncatise from 'truncatise'\n\n/**\n * Truncate a sentence to be under a certain characters limit and strip\n * out HTML tags from it.\n *\n * Optionally, you can force the truncate logic to complete words, which\n * may exceed the defined characters limit.\n */\nexport function excerpt(\n  sentence: string,\n  charactersLimit: number,\n  options?: {\n    completeWords?: boolean\n    suffix?: string\n  }\n): string {\n  return truncatise(sentence, {\n    TruncateLength: charactersLimit,\n    /**\n     * Do not complete words when \"completeWords\" is not explicitly set\n     * to true\n     */\n    Strict: options && options.completeWords === true ? false : true,\n    StripHTML: true,\n    TruncateBy: 'characters',\n    Suffix: options && options.suffix,\n  })\n}\n","/*\n * @poppinss/utils\n *\n * (c) Poppinss\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**\n * Ordinalize a give number or string\n */\nexport function ordinal(value: string | number): string {\n  const transformedValue = Math.abs(typeof value === 'string' ? Number.parseInt(value) : value)\n  if (!Number.isFinite(transformedValue) || Number.isNaN(transformedValue)) {\n    throw new Error('Cannot ordinalize invalid or infinite numbers')\n  }\n\n  const percent = transformedValue % 100\n  if (percent >= 10 && percent <= 20) {\n    return `${value}th`\n  }\n\n  const decimal = transformedValue % 10\n  switch (decimal) {\n    case 1:\n      return `${value}st`\n    case 2:\n      return `${value}nd`\n    case 3:\n      return `${value}rd`\n    default:\n      return `${value}th`\n  }\n}\n","/*\n * @poppinss/utils\n *\n * (c) Poppinss\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n// @ts-expect-error (Package has no types)\nimport truncatise from 'truncatise'\n\n/**\n * Truncate a sentence to be under a certain characters limit.\n *\n * Optionally, you can force the truncate logic to complete words, which\n * may exceed the defined characters limit.\n */\nexport function truncate(\n  sentence: string,\n  charactersLimit: number,\n  options?: {\n    completeWords?: boolean\n    suffix?: string\n  }\n): string {\n  return truncatise(sentence, {\n    TruncateLength: charactersLimit,\n    /**\n     * Do not complete words when \"completeWords\" is not explicitly set\n     * to true\n     */\n    Strict: options && options.completeWords === true ? false : true,\n    StripHTML: false,\n    TruncateBy: 'characters',\n    Suffix: options && options.suffix,\n  })\n}\n","/*\n * @poppinss/utils\n *\n * (c) Poppinss\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**\n * Convert an array of values to a sentence.\n */\nexport function sentence(\n  values: any[],\n  options?: {\n    separator?: string\n    pairSeparator?: string\n    lastSeparator?: string\n  }\n): string {\n  /**\n   * Empty array\n   */\n  if (values.length === 0) {\n    return ''\n  }\n\n  /**\n   * Just one item\n   */\n  if (values.length === 1) {\n    return values[0]\n  }\n\n  /**\n   * Giving some love to two items, so that one can ditch comma with two items\n   */\n  if (values.length === 2) {\n    return `${values[0]}${options?.pairSeparator || ' and '}${values[1]}`\n  }\n\n  const normalized = Object.assign({ separator: ', ', lastSeparator: ', and ' }, options)\n\n  /**\n   * Make sentence\n   */\n  return `${values.slice(0, -1).join(normalized.separator)}${normalized.lastSeparator}${\n    values[values.length - 1]\n  }`\n}\n","/*\n * @poppinss/utils\n *\n * (c) Poppinss\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**\n * Parses prop\n */\nfunction parseProp(data: any, key: string) {\n  const tokens = key.split('.')\n  while (tokens.length) {\n    if (data === null || typeof data !== 'object') {\n      return\n    }\n    const token = tokens.shift()!\n    data = Object.hasOwn(data, token) ? data[token] : undefined\n  }\n  return data\n}\n\n/**\n * A simple function interpolate values inside curly braces.\n *\n * ```\n * interpolate('hello {{ username }}', { username: 'virk' })\n * ```\n */\nexport function interpolate(input: string, data: any) {\n  return input.replace(/(\\\\)?{{(.*?)}}/g, (_, escapeChar, key) => {\n    if (escapeChar) {\n      return `{{${key}}}`\n    }\n\n    return parseProp(data, key.trim())\n  })\n}\n","/*\n * @poppinss/utils\n *\n * (c) Poppinss\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { default as pluralizePkg } from 'pluralize'\n\n/**\n * Pluralize a word based upon the count. The method returns the\n * singular form when count is 1.\n */\nexport function pluralize(word: string, count?: number, inclusive?: boolean): string {\n  return pluralizePkg(word, count, inclusive)\n}\npluralize.addPluralRule = pluralizePkg.addPluralRule\npluralize.addSingularRule = pluralizePkg.addSingularRule\npluralize.addIrregularRule = pluralizePkg.addIrregularRule\npluralize.addUncountableRule = pluralizePkg.addUncountableRule\n\nexport const plural = pluralizePkg.plural\nexport const singular = pluralizePkg.singular\nexport const isPlural = pluralizePkg.isPlural\nexport const isSingular = pluralizePkg.isSingular\n","/*\n * @poppinss/utils\n *\n * (c) Poppinss\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport * as changeCase from 'case-anything'\n\n// Support camel case (\"camelCase\" -> \"camel Case\" and \"CAMELCase\" -> \"CAMEL Case\").\nconst NO_CASE_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g]\n\n// Remove all non-word characters.\nconst NO_CASE_STRIP_REGEXP = /[^A-Z0-9]+/gi\n\nconst SMALL_WORDS =\n  /\\b(?:an?d?|a[st]|because|but|by|en|for|i[fn]|neither|nor|o[fnr]|only|over|per|so|some|tha[tn]|the|to|up|upon|vs?\\.?|versus|via|when|with|without|yet)\\b/i\nconst TOKENS = /[^\\s:–—-]+|./g\nconst WHITESPACE = /\\s/\nconst IS_MANUAL_CASE = /.(?=[A-Z]|\\..)/\nconst ALPHANUMERIC_PATTERN = /[A-Za-z0-9\\u00C0-\\u00FF]/\n\n/**\n * The method is a copy/paste from the \"title-case\" package. They have\n * a dependency on \"tslib\", which I don't want.\n */\nexport function titleCase(input: string) {\n  let output = ''\n  let result: RegExpExecArray | null\n\n  while ((result = TOKENS.exec(input)) !== null) {\n    const { 0: token, index } = result\n\n    if (\n      !IS_MANUAL_CASE.test(token) &&\n      (!SMALL_WORDS.test(token) || index === 0 || index + token.length === input.length) &&\n      (input.charAt(index + token.length) !== ':' ||\n        WHITESPACE.test(input.charAt(index + token.length + 1)))\n    ) {\n      output += token.replace(ALPHANUMERIC_PATTERN, (char) => char.toUpperCase())\n      continue\n    }\n\n    output += token\n  }\n\n  return output\n}\n\n/**\n * Convert string to camelcase\n */\nexport function camelCase(value: string): string {\n  return changeCase.camelCase(value)\n}\n\n/**\n * Convert string to snakecase\n */\nexport function snakeCase(value: string): string {\n  return changeCase.snakeCase(value)\n}\n\n/**\n * Convert string to dashcase\n */\nexport function dashCase(value: string, options?: { capitalize?: boolean }): string {\n  if (options && options.capitalize) {\n    return changeCase.trainCase(value)\n  }\n\n  return changeCase.kebabCase(value)\n}\n\n/**\n * Convert string to pascal case\n */\nexport function pascalCase(value: string): string {\n  return changeCase.pascalCase(value)\n}\n\n/**\n * Convert string to capital case\n */\nexport function capitalCase(value: string): string {\n  return changeCase.capitalCase(value)\n}\n\n/**\n * Convert string to sentence case\n */\nexport function sentenceCase(value: string): string {\n  return noCase(value, (input, index) => {\n    const result = input.toLowerCase()\n    if (index === 0) {\n      return input.charAt(0).toUpperCase() + input.substring(1)\n    }\n    return result\n  })\n}\n\n/**\n * Convert string to dot case\n */\nexport function dotCase(value: string, options?: { lowerCase?: boolean }): string {\n  const transformedValue = changeCase.dotNotation(value)\n  if (options && options.lowerCase) {\n    return transformedValue.toLowerCase()\n  }\n\n  return transformedValue\n}\n\n/**\n * Remove all sort of casing from the string. Copy-pasted from\n * \"no-case\" package with slight modifications.\n */\nexport function noCase(\n  value: string,\n  transform?: (part: string, index: number, parts: string[]) => string\n): string {\n  let result = NO_CASE_SPLIT_REGEXP.reduce((input, regex) => input.replace(regex, '$1\\0$2'), value)\n  result = result.replace(NO_CASE_STRIP_REGEXP, '\\0')\n\n  let start = 0\n  let end = result.length\n\n  // Trim the delimiter from around the output string.\n  while (result.charAt(start) === '\\0') {\n    start++\n  }\n  while (result.charAt(end - 1) === '\\0') {\n    end--\n  }\n\n  return result\n    .slice(start, end)\n    .split('\\0')\n    .map(transform || ((input) => input.toLowerCase()))\n    .join(' ')\n}\n","/*\n * @poppinss/utils\n *\n * (c) Poppinss\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport bytes from './bytes.js'\nimport seconds from './seconds.js'\nimport { slug } from './slugify.js'\nimport { random } from './random.js'\nimport { excerpt } from './excerpt.js'\nimport { ordinal } from './ordinal.js'\nimport { truncate } from './truncate.js'\nimport milliseconds from './milliseconds.js'\nimport { sentence } from './sentence.js'\nimport { interpolate } from './interpolate.js'\nimport { plural, pluralize, singular, isPlural, isSingular } from './pluralize.js'\nimport {\n  noCase,\n  dotCase,\n  dashCase,\n  camelCase,\n  snakeCase,\n  titleCase,\n  pascalCase,\n  capitalCase,\n  sentenceCase,\n} from './change_case.js'\n\n/**\n * Condense multiple whitespaces from a string\n */\nfunction condenseWhitespace(value: string): string {\n  return value.trim().replace(/\\s{2,}/g, ' ')\n}\n\nconst string = {\n  excerpt,\n  truncate,\n  slug,\n  interpolate,\n  plural,\n  pluralize,\n  singular,\n  isPlural,\n  isSingular,\n  camelCase,\n  capitalCase,\n  dashCase,\n  dotCase,\n  noCase,\n  pascalCase,\n  sentenceCase,\n  snakeCase,\n  titleCase,\n  random,\n  sentence,\n  condenseWhitespace,\n  seconds,\n  milliseconds,\n  bytes,\n  ordinal,\n}\n\nexport default string\n"],"mappings":"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","names":["sentence","truncatise","sentence","camelCase","snakeCase","pascalCase","capitalCase","camelCase","capitalCase","pascalCase","snakeCase"]}