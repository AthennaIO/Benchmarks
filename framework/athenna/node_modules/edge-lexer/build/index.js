import {
  MustacheTypes,
  TagTypes
} from "./chunk-RJJ2FQOC.js";

// src/scanner.ts
var Scanner = class {
  #pattern;
  #tolaretionCounts = 0;
  #tolerateLhs = "";
  #tolerateRhs = "";
  #patternLength = 0;
  /**
   * Tracking if the scanner has been closed
   */
  closed = false;
  /**
   * The matched content within the pattern
   */
  match = "";
  /**
   * The content in the same line but after the closing
   * of the pattern
   */
  leftOver = "";
  loc;
  constructor(pattern, toleratePair, line, col) {
    this.#tolerateLhs = toleratePair[0];
    this.#tolerateRhs = toleratePair[1];
    this.#patternLength = pattern.length;
    this.#pattern = pattern;
    this.loc = {
      line,
      col
    };
  }
  /**
   * Returns a boolean telling if the pattern matches the current
   * char and the upcoming chars or not.
   *
   * This will be used to mark the scanner as closed and stop scanning
   * for more chars
   */
  #matchesPattern(chars, iterationCount) {
    for (let i = 0; i < this.#patternLength; i++) {
      if (this.#pattern[i] !== chars[iterationCount + i]) {
        return false;
      }
    }
    return true;
  }
  /**
   * Scan a string and look for the closing pattern. The string will
   * be seperated with the closing pattern and also tracks the
   * toleration patterns to make sure they are not making the
   * scanner to end due to pattern mis-match.
   */
  scan(chunk) {
    if (chunk === "\n") {
      this.loc.line++;
      this.loc.col = 0;
      this.match += "\n";
      return;
    }
    if (!chunk.trim()) {
      return;
    }
    const chunkLength = chunk.length;
    let iterations = 0;
    while (iterations < chunkLength) {
      const char = chunk[iterations];
      if (this.#tolaretionCounts === 0 && this.#matchesPattern(chunk, iterations)) {
        iterations += this.#patternLength;
        this.closed = true;
        break;
      }
      if (char === this.#tolerateLhs) {
        this.#tolaretionCounts++;
      }
      if (char === this.#tolerateRhs) {
        this.#tolaretionCounts--;
      }
      this.match += char;
      iterations++;
    }
    if (this.closed) {
      this.loc.col += iterations;
      this.leftOver = chunk.slice(iterations);
    }
  }
};

// src/detector.ts
var TAG_REGEX = /^(\s*)(@{1,2})(!)?([a-zA-Z._]+)(\s{0,2})/;
function getTag(content, filename, line, col, tags, claimTag) {
  const match = TAG_REGEX.exec(content);
  if (!match) {
    return null;
  }
  const name = match[4];
  let tag = tags[name];
  if (!tag && claimTag) {
    tag = claimTag(name);
  }
  if (!tag) {
    return null;
  }
  const escaped = match[2] === "@@";
  const selfclosed = !!match[3];
  const whitespaceLeft = match[1].length;
  const whitespaceRight = match[5].length;
  const seekable = tag.seekable;
  const block = tag.block;
  const noNewLine = !!tag.noNewLine;
  col += whitespaceLeft + match[2].length + name.length + whitespaceRight;
  if (selfclosed) {
    col++;
  }
  const hasBrace = seekable && content[col] === "(";
  return {
    name,
    filename,
    seekable,
    selfclosed,
    block,
    line,
    col,
    escaped,
    hasBrace,
    noNewLine
  };
}
function getMustache(content, filename, line, col) {
  const mustacheIndex = content.indexOf("{{");
  if (mustacheIndex === -1) {
    return null;
  }
  const realCol = mustacheIndex;
  const isComment = content[mustacheIndex + 2] === "-" && content[mustacheIndex + 3] === "-";
  if (isComment) {
    return {
      isComment,
      filename,
      line,
      col: col + realCol,
      realCol
    };
  }
  const safe = content[mustacheIndex + 2] === "{";
  const escaped = content[mustacheIndex - 1] === "@";
  return {
    isComment,
    safe,
    filename,
    escaped,
    line,
    col: col + realCol,
    realCol
  };
}

// src/exceptions.ts
import { EdgeError } from "edge-error";
function cannotSeekStatement(chars, pos, filename) {
  return new EdgeError(`Unexpected token "${chars}"`, "E_CANNOT_SEEK_STATEMENT", {
    line: pos.line,
    col: pos.col,
    filename
  });
}
function unclosedParen(pos, filename) {
  return new EdgeError('Missing token ")"', "E_UNCLOSED_PAREN", {
    line: pos.line,
    col: pos.col,
    filename
  });
}
function unopenedParen(pos, filename) {
  return new EdgeError('Missing token "("', "E_UNOPENED_PAREN", {
    line: pos.line,
    col: pos.col,
    filename
  });
}
function unclosedCurlyBrace(pos, filename) {
  return new EdgeError('Missing token "}"', "E_UNCLOSED_CURLY_BRACE", {
    line: pos.line,
    col: pos.col,
    filename
  });
}
function unclosedTag(tag, pos, filename) {
  return new EdgeError(`Unclosed tag ${tag}`, "E_UNCLOSED_TAG", {
    line: pos.line,
    col: pos.col,
    filename
  });
}

// src/tokenizer.ts
var Tokenizer = class {
  /**
   * Current line number
   */
  #line = 0;
  /**
   * Tracking if two back to back lines are tags or not. Need it for inserting
   * whitespace between them
   */
  #isLastLineATag = false;
  /**
   * When true, the tokenizer will drop the newline
   */
  #dropNewLine = false;
  /**
   * An array of opened block level tags
   */
  #openedTags = [];
  /**
   * Copy of options
   */
  #options;
  /**
   * Template to parse
   */
  #template;
  /**
   * Tags known ahead of time
   */
  #tagsDef;
  /**
   * Lexer tokens
   */
  tokens = [];
  /**
   * Holds the current tag statement, until it is closed
   */
  tagStatement = null;
  /**
   * Holds the current mustache statement, until it is closed
   */
  mustacheStatement = null;
  constructor(template, tagsDef, options) {
    this.#template = template;
    this.#tagsDef = tagsDef;
    this.#options = options;
  }
  /**
   * Returns the raw token
   */
  #getRawNode(text) {
    return {
      type: "raw",
      value: text,
      filename: this.#options.filename,
      line: this.#line
    };
  }
  /**
   * Returns the new line token
   */
  #getNewLineNode(line) {
    return {
      type: "newline",
      filename: this.#options.filename,
      line: (line || this.#line) - 1
    };
  }
  /**
   * Returns the TagToken for a runtime tag. The `jsArg` and ending
   * loc is computed using the scanner and must be passed to this
   * method.
   */
  #getTagNode(tag, jsArg, closingLoc) {
    return {
      type: tag.escaped ? "e__tag" /* ETAG */ : "tag" /* TAG */,
      filename: tag.filename,
      properties: {
        name: tag.name,
        jsArg,
        selfclosed: tag.selfclosed
      },
      loc: {
        start: {
          line: tag.line,
          col: tag.col
        },
        end: closingLoc
      },
      children: []
    };
  }
  /**
   * Consume the runtime tag node.
   *
   * If tag is `block`, then we push it to the list of
   * opened tags and wait for the closing statement to
   * appear.
   *
   * Otherwise, we move it to the tokens array directly.
   */
  #consumeTag(tag, jsArg, loc) {
    if (tag.block && !tag.selfclosed) {
      this.#openedTags.push(this.#getTagNode(tag, jsArg, loc));
    } else {
      this.#consumeNode(this.#getTagNode(tag, jsArg, loc));
    }
  }
  /**
   * Handles the opening of the tag.
   */
  #handleTagOpening(line, tag) {
    if (tag.seekable && !tag.hasBrace) {
      throw unopenedParen({ line: tag.line, col: tag.col }, tag.filename);
    }
    if (!tag.seekable) {
      this.#consumeTag(tag, "", { line: tag.line, col: tag.col });
      if (tag.noNewLine || line.endsWith("~")) {
        this.#dropNewLine = true;
      }
      return;
    }
    tag.col += 1;
    this.tagStatement = {
      tag,
      scanner: new Scanner(")", ["(", ")"], this.#line, tag.col)
    };
    this.#feedCharsToCurrentTag(line.slice(tag.col));
  }
  /**
   * Scans the string using the scanner and waits for the
   * closing brace ')' to appear
   */
  #feedCharsToCurrentTag(content) {
    const { tag, scanner } = this.tagStatement;
    scanner.scan(content);
    if (!scanner.closed) {
      return;
    }
    this.#consumeTag(tag, scanner.match, scanner.loc);
    if (scanner.leftOver.trim() === "~") {
      this.tagStatement = null;
      this.#dropNewLine = true;
      return;
    }
    if (scanner.leftOver.trim()) {
      throw cannotSeekStatement(scanner.leftOver, scanner.loc, tag.filename);
    }
    if (tag.noNewLine) {
      this.#dropNewLine = true;
    }
    this.tagStatement = null;
  }
  /**
   * Returns the mustache type by checking for `safe` and `escaped`
   * properties.
   */
  #getMustacheType(mustache) {
    if (mustache.safe) {
      return mustache.escaped ? "es__mustache" /* ESMUSTACHE */ : "s__mustache" /* SMUSTACHE */;
    }
    return mustache.escaped ? "e__mustache" /* EMUSTACHE */ : "mustache" /* MUSTACHE */;
  }
  /**
   * Returns the mustache token using the runtime mustache node. The `jsArg` and
   * ending `loc` is fetched using the scanner.
   */
  #getMustacheNode(mustache, jsArg, closingLoc) {
    return {
      type: this.#getMustacheType(mustache),
      filename: mustache.filename,
      properties: {
        jsArg
      },
      loc: {
        start: {
          line: mustache.line,
          col: mustache.col
        },
        end: closingLoc
      }
    };
  }
  /**
   * Returns the comment token using the runtime comment node.
   */
  #getCommentNode(comment, value, closingLoc) {
    return {
      type: "comment",
      filename: comment.filename,
      value,
      loc: {
        start: {
          line: comment.line,
          col: comment.col
        },
        end: closingLoc
      }
    };
  }
  /**
   * Handles the line which has mustache opening braces.
   */
  #handleMustacheOpening(line, mustache) {
    const pattern = mustache.isComment ? "--}}" : mustache.safe ? "}}}" : "}}";
    const textLeftIndex = mustache.isComment || !mustache.escaped ? mustache.realCol : mustache.realCol - 1;
    if (textLeftIndex > 0) {
      this.#consumeNode(this.#getRawNode(line.slice(0, textLeftIndex)));
    }
    mustache.col += pattern.length;
    mustache.realCol += pattern.length;
    this.mustacheStatement = {
      mustache,
      scanner: new Scanner(pattern, ["{", "}"], mustache.line, mustache.col)
    };
    this.#feedCharsToCurrentMustache(line.slice(mustache.realCol));
  }
  /**
   * Feed chars to the mustache statement, which isn't closed yet.
   */
  #feedCharsToCurrentMustache(content) {
    const { mustache, scanner } = this.mustacheStatement;
    scanner.scan(content);
    if (!scanner.closed) {
      return;
    }
    if (mustache.isComment) {
      this.#consumeNode(this.#getCommentNode(mustache, scanner.match, scanner.loc));
    } else {
      this.#consumeNode(this.#getMustacheNode(mustache, scanner.match, scanner.loc));
    }
    if (scanner.leftOver.trim()) {
      const anotherMustache = getMustache(
        scanner.leftOver,
        this.#options.filename,
        scanner.loc.line,
        scanner.loc.col
      );
      if (anotherMustache) {
        this.#handleMustacheOpening(scanner.leftOver, anotherMustache);
        return;
      }
      this.#consumeNode(this.#getRawNode(scanner.leftOver));
    }
    this.mustacheStatement = null;
  }
  /**
   * Returns a boolean telling if the content of the line is the
   * closing tag for the most recently opened tag.
   *
   * The opening and closing has to be in a order, otherwise the
   * compiler will get mad.
   */
  #isClosingTag(line) {
    if (!this.#openedTags.length) {
      return false;
    }
    line = line.trim();
    const recentTag = this.#openedTags[this.#openedTags.length - 1];
    const endStatement = `@end${recentTag.properties.name}`;
    return line === endStatement || line === `${endStatement}~` || line === "@end" || line === "@end~";
  }
  /**
   * Consume any type of token by moving it to the correct list. If there are
   * opened tags, then the token becomes part of the tag children. Otherwise
   * moved as top level token.
   */
  #consumeNode(tag) {
    if (this.#openedTags.length) {
      this.#openedTags[this.#openedTags.length - 1].children.push(tag);
      return;
    }
    this.tokens.push(tag);
  }
  /**
   * Pushes a new line to the list. This method avoids
   * new lines at position 0.
   */
  #pushNewLine(line) {
    if ((line || this.#line) === 1) {
      return;
    }
    if (this.#dropNewLine) {
      this.#dropNewLine = false;
      return;
    }
    this.#consumeNode(this.#getNewLineNode(line));
  }
  /**
   * Process the current line based upon what it is. What it is?
   * That's the job of this method to find out.
   */
  #processText(line) {
    if (typeof this.#options.onLine === "function") {
      line = this.#options.onLine(line);
    }
    if (this.tagStatement) {
      this.#feedCharsToCurrentTag("\n");
      this.#feedCharsToCurrentTag(line);
      return;
    }
    if (this.mustacheStatement) {
      this.#feedCharsToCurrentMustache("\n");
      this.#feedCharsToCurrentMustache(line);
      return;
    }
    if (this.#isClosingTag(line)) {
      this.#consumeNode(this.#openedTags.pop());
      if (line.endsWith("~")) {
        this.#dropNewLine = true;
      }
      return;
    }
    const tag = getTag(
      line,
      this.#options.filename,
      this.#line,
      0,
      this.#tagsDef,
      this.#options.claimTag
    );
    if (tag) {
      if (this.#isLastLineATag) {
        this.#pushNewLine();
      }
      this.#isLastLineATag = true;
      this.#handleTagOpening(line, tag);
      return;
    }
    this.#isLastLineATag = false;
    const mustache = getMustache(line, this.#options.filename, this.#line, 0);
    if (mustache) {
      this.#pushNewLine();
      this.#handleMustacheOpening(line, mustache);
      return;
    }
    this.#pushNewLine();
    this.#consumeNode(this.#getRawNode(line));
  }
  /**
   * Checks for errors after the tokenizer completes it's work, so that we
   * can find broken statements or unclosed tags.
   */
  #checkForErrors() {
    if (this.tagStatement) {
      const { tag } = this.tagStatement;
      throw unclosedParen({ line: tag.line, col: tag.col }, tag.filename);
    }
    if (this.mustacheStatement) {
      const { mustache, scanner } = this.mustacheStatement;
      throw unclosedCurlyBrace(scanner.loc, mustache.filename);
    }
    if (this.#openedTags.length) {
      const openedTag = this.#openedTags[this.#openedTags.length - 1];
      throw unclosedTag(openedTag.properties.name, openedTag.loc.start, openedTag.filename);
    }
  }
  /**
   * Parse the template and generate an AST out of it
   */
  parse() {
    const lines = this.#template.split(/\r\n|\r|\n/g);
    const linesLength = lines.length;
    while (this.#line < linesLength) {
      const line = lines[this.#line];
      this.#line++;
      this.#processText(line);
    }
    this.#checkForErrors();
  }
};
export {
  MustacheTypes,
  TagTypes,
  Tokenizer
};
//# sourceMappingURL=index.js.map