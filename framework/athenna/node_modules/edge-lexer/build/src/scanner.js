"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Scanner = void 0;
class Scanner {
    pattern;
    line;
    col;
    tolaretionCounts = 0;
    tolerateLhs = '';
    tolerateRhs = '';
    patternLength = 0;
    closed = false;
    match = '';
    leftOver = '';
    loc;
    constructor(pattern, toleratePair, line, col) {
        this.pattern = pattern;
        this.line = line;
        this.col = col;
        this.tolerateLhs = toleratePair[0];
        this.tolerateRhs = toleratePair[1];
        this.patternLength = this.pattern.length;
        this.loc = {
            line: this.line,
            col: this.col,
        };
    }
    matchesPattern(chars, iterationCount) {
        for (let i = 0; i < this.patternLength; i++) {
            if (this.pattern[i] !== chars[iterationCount + i]) {
                return false;
            }
        }
        return true;
    }
    scan(chunk) {
        if (chunk === '\n') {
            this.loc.line++;
            this.loc.col = 0;
            this.match += '\n';
            return;
        }
        if (!chunk.trim()) {
            return;
        }
        const chunkLength = chunk.length;
        let iterations = 0;
        while (iterations < chunkLength) {
            const char = chunk[iterations];
            if (this.tolaretionCounts === 0 && this.matchesPattern(chunk, iterations)) {
                iterations += this.patternLength;
                this.closed = true;
                break;
            }
            if (char === this.tolerateLhs) {
                this.tolaretionCounts++;
            }
            if (char === this.tolerateRhs) {
                this.tolaretionCounts--;
            }
            this.match += char;
            iterations++;
        }
        if (this.closed) {
            this.loc.col += iterations;
            this.leftOver = chunk.slice(iterations);
        }
    }
}
exports.Scanner = Scanner;
