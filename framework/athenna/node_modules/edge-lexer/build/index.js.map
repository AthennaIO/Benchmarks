{"version":3,"sources":["../src/scanner.ts","../src/detector.ts","../src/exceptions.ts","../src/tokenizer.ts"],"sourcesContent":["/**\n * edge-lexer\n *\n * (c) Edge\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n/**\n * Scan a string and seperate it into 2 pairs. The first pair will be series\n * of characters until the ending pattern is found and 2nd pair is the\n * left over.\n *\n * Their are some special behaviors over the regular `string.split` method.\n *\n * 1. Multiple lines can be passed by calling `scan` method for each line.\n * 2. Tolerates characters when they conflict with the ending pattern.\n *\n * ```js\n * const pattern = ')'\n * const tolerations = ['(', ')']\n * const scanner = new Scanner(pattern, tolerations)\n *\n * scanner.scan('2 + 2 * (3))')\n * if (scanner.closed) {\n *   scanner.match // 2 + 2 * (3)\n *   scanner.leftOver // ''\n * }\n * ```\n *\n * If we take the same string `2 + 2 * (3))` and split it using ')', then we\n * will get unexpected result, since the split method splits by finding the\n * first match.\n */\nexport class Scanner {\n  #pattern: string\n\n  #tolaretionCounts: number = 0\n  #tolerateLhs: string = ''\n  #tolerateRhs: string = ''\n  #patternLength: number = 0\n\n  /**\n   * Tracking if the scanner has been closed\n   */\n  closed: boolean = false\n\n  /**\n   * The matched content within the pattern\n   */\n  match: string = ''\n\n  /**\n   * The content in the same line but after the closing\n   * of the pattern\n   */\n  leftOver: string = ''\n\n  loc: { line: number; col: number }\n\n  constructor(pattern: string, toleratePair: [string, string], line: number, col: number) {\n    this.#tolerateLhs = toleratePair[0]\n    this.#tolerateRhs = toleratePair[1]\n    this.#patternLength = pattern.length\n    this.#pattern = pattern\n    this.loc = {\n      line: line,\n      col: col,\n    }\n  }\n\n  /**\n   * Returns a boolean telling if the pattern matches the current\n   * char and the upcoming chars or not.\n   *\n   * This will be used to mark the scanner as closed and stop scanning\n   * for more chars\n   */\n  #matchesPattern(chars: string, iterationCount: number) {\n    for (let i = 0; i < this.#patternLength; i++) {\n      if (this.#pattern[i] !== chars[iterationCount + i]) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Scan a string and look for the closing pattern. The string will\n   * be seperated with the closing pattern and also tracks the\n   * toleration patterns to make sure they are not making the\n   * scanner to end due to pattern mis-match.\n   */\n  scan(chunk: string): void {\n    if (chunk === '\\n') {\n      this.loc.line++\n      this.loc.col = 0\n      this.match += '\\n'\n      return\n    }\n\n    if (!chunk.trim()) {\n      return\n    }\n\n    const chunkLength = chunk.length\n    let iterations = 0\n\n    while (iterations < chunkLength) {\n      const char = chunk[iterations]\n\n      /**\n       * Toleration count is 0 and closing pattern matches the current\n       * or series of upcoming characters\n       */\n      if (this.#tolaretionCounts === 0 && this.#matchesPattern(chunk, iterations)) {\n        iterations += this.#patternLength\n        this.closed = true\n        break\n      }\n\n      /**\n       * Increments the tolarate counts when char is the\n       * tolerate lhs character\n       */\n      if (char === this.#tolerateLhs) {\n        this.#tolaretionCounts++\n      }\n\n      /**\n       * Decrements the tolare counts when char is the\n       * tolerate rhs character\n       */\n      if (char === this.#tolerateRhs) {\n        this.#tolaretionCounts--\n      }\n\n      /**\n       * Append to the matched string and waiting for the\n       * closing pattern\n       */\n      this.match += char\n\n      iterations++\n    }\n\n    /**\n     * If closed, then return the matched string and also the\n     * left over string\n     */\n    if (this.closed) {\n      this.loc.col += iterations\n      this.leftOver = chunk.slice(iterations)\n    }\n  }\n}\n","/**\n * edge-lexer\n *\n * (c) Edge\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type {\n  Tags,\n  RuntimeTag,\n  RuntimeComment,\n  RuntimeMustache,\n  LexerTagDefinitionContract,\n} from './types.js'\n\n/**\n * The only regex we need in the entire lexer. Also tested\n * with https://github.com/substack/safe-regex\n */\nconst TAG_REGEX = /^(\\s*)(@{1,2})(!)?([a-zA-Z._]+)(\\s{0,2})/\n\n/**\n * Returns runtime tag node if tag is detected and is a registered tag\n */\nexport function getTag(\n  content: string,\n  filename: string,\n  line: number,\n  col: number,\n  tags: Tags,\n  claimTag?: (name: string) => LexerTagDefinitionContract | null\n): RuntimeTag | null {\n  const match = TAG_REGEX.exec(content)\n\n  /**\n   * Return when their is no match\n   */\n  if (!match) {\n    return null\n  }\n\n  const name = match[4]\n  let tag: null | LexerTagDefinitionContract = tags[name]\n\n  /**\n   * See if the tag can be claimed\n   */\n  if (!tag && claimTag) {\n    tag = claimTag(name)\n  }\n\n  /**\n   * Return when not a registered tag\n   */\n  if (!tag) {\n    return null\n  }\n\n  const escaped = match[2] === '@@'\n  const selfclosed = !!match[3]\n  const whitespaceLeft = match[1].length\n  const whitespaceRight = match[5].length\n  const seekable = tag.seekable\n  const block = tag.block\n  const noNewLine = !!tag.noNewLine\n\n  /**\n   * Advanced the col position\n   */\n  col += whitespaceLeft + match[2].length + name.length + whitespaceRight\n  if (selfclosed) {\n    col++\n  }\n\n  /**\n   * Seekable tags without the brace in same line are invalid\n   */\n  const hasBrace = seekable && content[col] === '('\n\n  return {\n    name,\n    filename,\n    seekable,\n    selfclosed,\n    block,\n    line,\n    col,\n    escaped,\n    hasBrace,\n    noNewLine,\n  }\n}\n\n/**\n * Returns the runtime mustache node if mustache is detected. It will look for 3 types of\n * mustache statements.\n *\n * - Comments `{{-- --}}`\n * - Safe Mustache `{{{ }}}`\n * - Escaped Mustache `@{{}}`\n */\nexport function getMustache(\n  content: string,\n  filename: string,\n  line: number,\n  col: number\n): RuntimeMustache | RuntimeComment | null {\n  const mustacheIndex = content.indexOf('{{')\n\n  if (mustacheIndex === -1) {\n    return null\n  }\n\n  const realCol = mustacheIndex\n\n  /**\n   * Mustache is a comment\n   */\n  const isComment = content[mustacheIndex + 2] === '-' && content[mustacheIndex + 3] === '-'\n  if (isComment) {\n    return {\n      isComment,\n      filename,\n      line,\n      col: col + realCol,\n      realCol,\n    }\n  }\n\n  /**\n   * Mustache is for interpolation\n   */\n  const safe = content[mustacheIndex + 2] === '{'\n  const escaped = content[mustacheIndex - 1] === '@'\n\n  return {\n    isComment,\n    safe,\n    filename,\n    escaped,\n    line,\n    col: col + realCol,\n    realCol,\n  }\n}\n","/**\n * edge-lexer\n *\n * (c) Edge\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { EdgeError } from 'edge-error'\n\n/**\n * Raised when there is inline content next to a tag opening\n * block. For example:\n *\n * Incorrect\n * ```\n * @if(username) Hello {{ username }} @endif\n * ```\n *\n * Correct\n * ```\n * @if(username)\n *   Hello {{ username }}\n * @endif\n * ```\n */\nexport function cannotSeekStatement(\n  chars: string,\n  pos: { line: number; col: number },\n  filename: string\n): EdgeError {\n  return new EdgeError(`Unexpected token \"${chars}\"`, 'E_CANNOT_SEEK_STATEMENT', {\n    line: pos.line,\n    col: pos.col,\n    filename: filename,\n  })\n}\n\n/**\n * Raised when a tag opening body doesn't have a closing brace. For example:\n *\n * Incorrect\n * ```\n * @if(username\n * ```\n *\n * Correct\n * ```\n * @if(username)\n * ```\n */\nexport function unclosedParen(pos: { line: number; col: number }, filename: string): EdgeError {\n  return new EdgeError('Missing token \")\"', 'E_UNCLOSED_PAREN', {\n    line: pos.line,\n    col: pos.col,\n    filename: filename,\n  })\n}\n\n/**\n * Raised when a tag is used without an opening brace. For example:\n *\n * Incorrect\n * ```\n * @if username\n * ```\n *\n * Correct\n * ```\n * @if(username)\n * ```\n */\nexport function unopenedParen(pos: { line: number; col: number }, filename: string): EdgeError {\n  return new EdgeError('Missing token \"(\"', 'E_UNOPENED_PAREN', {\n    line: pos.line,\n    col: pos.col,\n    filename: filename,\n  })\n}\n\n/**\n * Raised when the curly closing brace is missing from the mustache\n * statement. For example:\n *\n * Incorrect\n * ```\n * {{ username }\n * ```\n *\n * Correct\n *\n * ```\n * {{ username }}\n * ```\n */\nexport function unclosedCurlyBrace(\n  pos: { line: number; col: number },\n  filename: string\n): EdgeError {\n  return new EdgeError('Missing token \"}\"', 'E_UNCLOSED_CURLY_BRACE', {\n    line: pos.line,\n    col: pos.col,\n    filename: filename,\n  })\n}\n\n/**\n * Raised when a block level tag is opened but never closed. For example:\n *\n * Incorrect\n * ```\n * @if(username)\n * ```\n *\n * Correct\n * ```\n * @if(username)\n * @endif\n * ```\n */\nexport function unclosedTag(\n  tag: string,\n  pos: { line: number; col: number },\n  filename: string\n): EdgeError {\n  return new EdgeError(`Unclosed tag ${tag}`, 'E_UNCLOSED_TAG', {\n    line: pos.line,\n    col: pos.col,\n    filename: filename,\n  })\n}\n","/**\n * edge-lexer\n *\n * (c) Edge\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { Scanner } from './scanner.js'\nimport { getTag, getMustache } from './detector.js'\nimport { TagTypes, MustacheTypes } from './enums.js'\n\nimport {\n  unclosedTag,\n  unclosedParen,\n  unopenedParen,\n  unclosedCurlyBrace,\n  cannotSeekStatement,\n} from './exceptions.js'\n\nimport type {\n  Tags,\n  Token,\n  LexerLoc,\n  TagToken,\n  RawToken,\n  RuntimeTag,\n  CommentToken,\n  NewLineToken,\n  MustacheToken,\n  RuntimeComment,\n  RuntimeMustache,\n  TokenizerOptions,\n} from './types.js'\n\n/**\n * Tokenizer converts a bunch of text into an array of tokens. Later\n * these tokens can be used to build the transformed text.\n *\n * Go through the README file to learn more about the syntax and\n * the tokens output.\n */\nexport class Tokenizer {\n  /**\n   * Current line number\n   */\n  #line: number = 0\n\n  /**\n   * Tracking if two back to back lines are tags or not. Need it for inserting\n   * whitespace between them\n   */\n  #isLastLineATag: boolean = false\n\n  /**\n   * When true, the tokenizer will drop the newline\n   */\n  #dropNewLine: boolean = false\n\n  /**\n   * An array of opened block level tags\n   */\n  #openedTags: TagToken[] = []\n\n  /**\n   * Copy of options\n   */\n  #options: TokenizerOptions\n\n  /**\n   * Template to parse\n   */\n  #template: string\n\n  /**\n   * Tags known ahead of time\n   */\n  #tagsDef: Tags\n\n  /**\n   * Lexer tokens\n   */\n  tokens: Token[] = []\n\n  /**\n   * Holds the current tag statement, until it is closed\n   */\n  tagStatement: null | { scanner: Scanner; tag: RuntimeTag } = null\n\n  /**\n   * Holds the current mustache statement, until it is closed\n   */\n  mustacheStatement: null | {\n    scanner: Scanner\n    mustache: RuntimeMustache | RuntimeComment\n  } = null\n\n  constructor(template: string, tagsDef: Tags, options: TokenizerOptions) {\n    this.#template = template\n    this.#tagsDef = tagsDef\n    this.#options = options\n  }\n\n  /**\n   * Returns the raw token\n   */\n  #getRawNode(text: string): RawToken {\n    return {\n      type: 'raw',\n      value: text,\n      filename: this.#options.filename,\n      line: this.#line,\n    }\n  }\n\n  /**\n   * Returns the new line token\n   */\n  #getNewLineNode(line?: number): NewLineToken {\n    return {\n      type: 'newline',\n      filename: this.#options.filename,\n      line: (line || this.#line) - 1,\n    }\n  }\n\n  /**\n   * Returns the TagToken for a runtime tag. The `jsArg` and ending\n   * loc is computed using the scanner and must be passed to this\n   * method.\n   */\n  #getTagNode(tag: RuntimeTag, jsArg: string, closingLoc: LexerLoc['end']): TagToken {\n    return {\n      type: tag.escaped ? TagTypes.ETAG : TagTypes.TAG,\n      filename: tag.filename,\n      properties: {\n        name: tag.name,\n        jsArg: jsArg,\n        selfclosed: tag.selfclosed,\n      },\n      loc: {\n        start: {\n          line: tag.line,\n          col: tag.col,\n        },\n        end: closingLoc,\n      },\n      children: [],\n    }\n  }\n\n  /**\n   * Consume the runtime tag node.\n   *\n   * If tag is `block`, then we push it to the list of\n   * opened tags and wait for the closing statement to\n   * appear.\n   *\n   * Otherwise, we move it to the tokens array directly.\n   */\n  #consumeTag(tag: RuntimeTag, jsArg: string, loc: LexerLoc['end']) {\n    if (tag.block && !tag.selfclosed) {\n      this.#openedTags.push(this.#getTagNode(tag, jsArg, loc))\n    } else {\n      this.#consumeNode(this.#getTagNode(tag, jsArg, loc))\n    }\n  }\n\n  /**\n   * Handles the opening of the tag.\n   */\n  #handleTagOpening(line: string, tag: RuntimeTag) {\n    if (tag.seekable && !tag.hasBrace) {\n      throw unopenedParen({ line: tag.line, col: tag.col }, tag.filename)\n    }\n\n    /**\n     * When tag is not seekable, then their is no need to create\n     * a scanner instance, just consume it right away.\n     */\n    if (!tag.seekable) {\n      this.#consumeTag(tag, '', { line: tag.line, col: tag.col })\n      if (tag.noNewLine || line.endsWith('~')) {\n        this.#dropNewLine = true\n      }\n      return\n    }\n\n    /**\n     * Advance the `col`, since we do not want to start from the\n     * starting brace `(`.\n     */\n    tag.col += 1\n\n    /**\n     * Create a new block statement with the scanner to find\n     * the closing brace ')'\n     */\n    this.tagStatement = {\n      tag: tag,\n      scanner: new Scanner(')', ['(', ')'], this.#line, tag.col),\n    }\n\n    /**\n     * Pass all remaining content to the scanner\n     */\n    this.#feedCharsToCurrentTag(line.slice(tag.col))\n  }\n\n  /**\n   * Scans the string using the scanner and waits for the\n   * closing brace ')' to appear\n   */\n  #feedCharsToCurrentTag(content: string) {\n    const { tag, scanner } = this.tagStatement!\n\n    scanner.scan(content)\n\n    /**\n     * If scanner is not closed, then we need to keep on\n     * feeding more content\n     */\n    if (!scanner.closed) {\n      return\n    }\n\n    /**\n     * Consume the tag once we have found the closing brace and set\n     * block statement to null\n     */\n    this.#consumeTag(tag, scanner.match, scanner.loc)\n\n    /**\n     * If tag endswith `~`. Then instruct the tokenizer to drop the\n     * next new line\n     */\n    if (scanner.leftOver.trim() === '~') {\n      this.tagStatement = null\n      this.#dropNewLine = true\n      return\n    }\n\n    /**\n     * Raise error, if there is inline content after the closing brace ')'\n     * `@if(username) hello {{ username }}` is invalid\n     */\n    if (scanner.leftOver.trim()) {\n      throw cannotSeekStatement(scanner.leftOver, scanner.loc, tag.filename)\n    }\n\n    /**\n     * Do not add newline when tag instructs for it\n     */\n    if (tag.noNewLine) {\n      this.#dropNewLine = true\n    }\n\n    this.tagStatement = null\n  }\n\n  /**\n   * Returns the mustache type by checking for `safe` and `escaped`\n   * properties.\n   */\n  #getMustacheType(mustache: RuntimeMustache): MustacheTypes {\n    if (mustache.safe) {\n      return mustache.escaped ? MustacheTypes.ESMUSTACHE : MustacheTypes.SMUSTACHE\n    }\n\n    return mustache.escaped ? MustacheTypes.EMUSTACHE : MustacheTypes.MUSTACHE\n  }\n\n  /**\n   * Returns the mustache token using the runtime mustache node. The `jsArg` and\n   * ending `loc` is fetched using the scanner.\n   */\n  #getMustacheNode(\n    mustache: RuntimeMustache,\n    jsArg: string,\n    closingLoc: LexerLoc['end']\n  ): MustacheToken {\n    return {\n      type: this.#getMustacheType(mustache),\n      filename: mustache.filename,\n      properties: {\n        jsArg: jsArg,\n      },\n      loc: {\n        start: {\n          line: mustache.line,\n          col: mustache.col,\n        },\n        end: closingLoc,\n      },\n    }\n  }\n\n  /**\n   * Returns the comment token using the runtime comment node.\n   */\n  #getCommentNode(\n    comment: RuntimeComment,\n    value: string,\n    closingLoc: LexerLoc['end']\n  ): CommentToken {\n    return {\n      type: 'comment',\n      filename: comment.filename,\n      value: value,\n      loc: {\n        start: {\n          line: comment.line,\n          col: comment.col,\n        },\n        end: closingLoc,\n      },\n    }\n  }\n\n  /**\n   * Handles the line which has mustache opening braces.\n   */\n  #handleMustacheOpening(line: string, mustache: RuntimeMustache | RuntimeComment) {\n    const pattern = mustache.isComment ? '--}}' : mustache.safe ? '}}}' : '}}'\n    const textLeftIndex =\n      mustache.isComment || !mustache.escaped ? mustache.realCol : mustache.realCol - 1\n\n    /**\n     * Pull everything that is on the left of the mustache\n     * statement and use it as a raw node\n     */\n    if (textLeftIndex > 0) {\n      this.#consumeNode(this.#getRawNode(line.slice(0, textLeftIndex)))\n    }\n\n    /**\n     * Skip the curly braces when reading the expression inside\n     * it. We are actually skipping opening curly braces\n     * `{{`, however, their length will be same as the\n     * closing one's/\n     */\n    mustache.col += pattern.length\n    mustache.realCol += pattern.length\n\n    /**\n     * Create a new mustache statement with a scanner to scan for\n     * closing mustache braces. Note the closing `pattern` is\n     * different for safe and normal mustache.\n     */\n    this.mustacheStatement = {\n      mustache,\n      scanner: new Scanner(pattern, ['{', '}'], mustache.line, mustache.col),\n    }\n\n    /**\n     * Feed text to the mustache statement and wait for the closing braces\n     */\n    this.#feedCharsToCurrentMustache(line.slice(mustache.realCol))\n  }\n\n  /**\n   * Feed chars to the mustache statement, which isn't closed yet.\n   */\n  #feedCharsToCurrentMustache(content: string): void {\n    const { mustache, scanner } = this.mustacheStatement!\n    scanner.scan(content)\n\n    /**\n     * If scanner is not closed, then return early, since their\n     * not much we can do here.\n     */\n    if (!scanner.closed) {\n      return\n    }\n\n    /**\n     * Consume the node as soon as we have found the closing brace\n     */\n    if (mustache.isComment) {\n      this.#consumeNode(this.#getCommentNode(mustache, scanner.match, scanner.loc))\n    } else {\n      this.#consumeNode(this.#getMustacheNode(mustache, scanner.match, scanner.loc))\n    }\n\n    /**\n     * If their is leftOver text after the mustache closing brace, then re-scan\n     * it for more mustache statements. Example:\n     *\n     * I following statement, `, and {{ age }}` is the left over.\n     * ```\n     * {{ username }}, and {{ age }}\n     * ```\n     *\n     * This block is same the generic new line handler method. However, their is\n     * no need to check for tags and comments, so we ditch that method and\n     * process it here by duplicating code (which is fine).\n     */\n    if (scanner.leftOver.trim()) {\n      /**\n       * Scan for another mustache in the same line\n       */\n      const anotherMustache = getMustache(\n        scanner.leftOver,\n        this.#options.filename,\n        scanner.loc.line,\n        scanner.loc.col\n      )\n      if (anotherMustache) {\n        this.#handleMustacheOpening(scanner.leftOver, anotherMustache)\n        return\n      }\n\n      this.#consumeNode(this.#getRawNode(scanner.leftOver))\n    }\n\n    /**\n     * Set mustache statement to null\n     */\n    this.mustacheStatement = null\n  }\n\n  /**\n   * Returns a boolean telling if the content of the line is the\n   * closing tag for the most recently opened tag.\n   *\n   * The opening and closing has to be in a order, otherwise the\n   * compiler will get mad.\n   */\n  #isClosingTag(line: string): boolean {\n    if (!this.#openedTags.length) {\n      return false\n    }\n\n    line = line.trim()\n\n    const recentTag = this.#openedTags[this.#openedTags.length - 1]\n    const endStatement = `@end${recentTag.properties.name}`\n    return (\n      line === endStatement || line === `${endStatement}~` || line === '@end' || line === '@end~'\n    )\n  }\n\n  /**\n   * Consume any type of token by moving it to the correct list. If there are\n   * opened tags, then the token becomes part of the tag children. Otherwise\n   * moved as top level token.\n   */\n  #consumeNode(tag: Token): void {\n    if (this.#openedTags.length) {\n      this.#openedTags[this.#openedTags.length - 1].children.push(tag)\n      return\n    }\n\n    this.tokens.push(tag)\n  }\n\n  /**\n   * Pushes a new line to the list. This method avoids\n   * new lines at position 0.\n   */\n  #pushNewLine(line?: number) {\n    if ((line || this.#line) === 1) {\n      return\n    }\n\n    /**\n     * Ignore incoming new line\n     */\n    if (this.#dropNewLine) {\n      this.#dropNewLine = false\n      return\n    }\n\n    this.#consumeNode(this.#getNewLineNode(line))\n  }\n\n  /**\n   * Process the current line based upon what it is. What it is?\n   * That's the job of this method to find out.\n   */\n  #processText(line: string): void {\n    /**\n     * Pre process line when the onLine listener is defined\n     */\n    if (typeof this.#options.onLine === 'function') {\n      line = this.#options.onLine(line)\n    }\n\n    /**\n     * There is an open block statement, so feed line to it\n     */\n    if (this.tagStatement) {\n      this.#feedCharsToCurrentTag('\\n')\n      this.#feedCharsToCurrentTag(line)\n      return\n    }\n\n    /**\n     * There is an open mustache statement, so feed line to it\n     */\n    if (this.mustacheStatement) {\n      this.#feedCharsToCurrentMustache('\\n')\n      this.#feedCharsToCurrentMustache(line)\n      return\n    }\n\n    /**\n     * The line is an closing statement for a previously opened\n     * block level tag\n     */\n    if (this.#isClosingTag(line)) {\n      this.#consumeNode(this.#openedTags.pop()!)\n\n      /**\n       * Do not add next newline when statement ends with `~`\n       */\n      if (line.endsWith('~')) {\n        this.#dropNewLine = true\n      }\n      return\n    }\n\n    /**\n     * Check if the current line is a tag or not. If yes, then handle\n     * it appropriately\n     */\n    const tag = getTag(\n      line,\n      this.#options.filename,\n      this.#line,\n      0,\n      this.#tagsDef,\n      this.#options.claimTag\n    )\n    if (tag) {\n      /**\n       * When two back to back lines are tags, then we put a newline between them\n       * and one can use `skipNewLines` syntax to remove new lines (if required)\n       */\n      if (this.#isLastLineATag) {\n        this.#pushNewLine()\n      }\n\n      this.#isLastLineATag = true\n      this.#handleTagOpening(line, tag)\n      return\n    }\n\n    this.#isLastLineATag = false\n\n    /**\n     * Check if the current line contains a mustache statement or not. If yes,\n     * then handle it appropriately.\n     */\n    const mustache = getMustache(line, this.#options.filename, this.#line, 0)\n    if (mustache) {\n      this.#pushNewLine()\n      this.#handleMustacheOpening(line, mustache)\n      return\n    }\n\n    this.#pushNewLine()\n    this.#consumeNode(this.#getRawNode(line))\n  }\n\n  /**\n   * Checks for errors after the tokenizer completes it's work, so that we\n   * can find broken statements or unclosed tags.\n   */\n  #checkForErrors() {\n    /**\n     * We are done scanning the content and there is an open tagStatement\n     * seeking for new content. Which means we are missing a closing\n     * brace `)`.\n     */\n    if (this.tagStatement) {\n      const { tag } = this.tagStatement\n      throw unclosedParen({ line: tag.line, col: tag.col }, tag.filename)\n    }\n\n    /**\n     * We are done scanning the content and there is an open mustache statement\n     * seeking for new content. Which means we are missing closing braces `}}`.\n     */\n    if (this.mustacheStatement) {\n      const { mustache, scanner } = this.mustacheStatement\n      throw unclosedCurlyBrace(scanner.loc, mustache.filename)\n    }\n\n    /**\n     * A tag was opened, but forgot to close it\n     */\n    if (this.#openedTags.length) {\n      const openedTag = this.#openedTags[this.#openedTags.length - 1]\n      throw unclosedTag(openedTag.properties.name, openedTag.loc.start, openedTag.filename)\n    }\n  }\n\n  /**\n   * Parse the template and generate an AST out of it\n   */\n  parse(): void {\n    const lines = this.#template.split(/\\r\\n|\\r|\\n/g)\n    const linesLength = lines.length\n\n    while (this.#line < linesLength) {\n      const line = lines[this.#line]\n      this.#line++\n      this.#processText(line)\n    }\n\n    this.#checkForErrors()\n  }\n}\n"],"mappings":"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","names":[]}