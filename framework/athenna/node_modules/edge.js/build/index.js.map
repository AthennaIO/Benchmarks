{"version":3,"sources":["../src/loader.ts","../src/tags/main.ts","../src/tags/if.ts","../src/tags/let.ts","../src/tags/each.ts","../src/tags/slot.ts","../src/tags/else.ts","../src/tags/eval.ts","../src/tags/assign.ts","../src/tags/inject.ts","../src/tags/unless.ts","../src/tags/else_if.ts","../src/tags/include.ts","../src/tags/debugger.ts","../src/tags/new_error.ts","../src/tags/component.ts","../src/tags/include_if.ts","../src/compiler.ts","../src/cache_manager.ts","../src/edge/globals.ts","../src/processor.ts","../src/edge/renderer.ts","../src/plugins/supercharged.ts","../src/edge/main.ts","../index.ts"],"sourcesContent":["/**\n * edge\n *\n * (c) EdgeJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { slash } from '@poppinss/utils'\nimport { fileURLToPath } from 'node:url'\nimport string from '@poppinss/utils/string'\nimport { join, isAbsolute } from 'node:path'\nimport readdirSync from 'fs-readdir-recursive'\nimport { existsSync, readFileSync } from 'node:fs'\nimport type { ComponentsTree, LoaderContract, LoaderTemplate } from './types.js'\n\n/**\n * The job of a loader is to load the template from a given path.\n * The base loader (shipped with edge) looks for files on the\n * file-system and reads them synchronously.\n *\n * You are free to define your own loaders that implements the [[LoaderContract]] interface.\n */\nexport class Loader implements LoaderContract {\n  /**\n   * List of mounted directories\n   */\n  #mountedDirs: Map<string, string> = new Map()\n\n  /**\n   * List of pre-registered (in-memory) templates\n   */\n  #preRegistered: Map<string, LoaderTemplate> = new Map()\n\n  /**\n   * Reads the content of a template from the disk. An exception is raised\n   * when file is missing or if `readFileSync` returns an error.\n   */\n  #readTemplateContents(absPath: string): string {\n    try {\n      return readFileSync(absPath, 'utf-8')\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        throw new Error(`Cannot resolve \"${absPath}\". Make sure the file exists`)\n      } else {\n        throw error\n      }\n    }\n  }\n\n  /**\n   * Returns a list of components for a given disk\n   */\n  #getDiskComponents(diskName: string): ComponentsTree[0]['components'] {\n    const componentsDirName = 'components'\n    const diskBasePath = this.#mountedDirs.get(diskName)!\n    let files =\n      diskName === 'default'\n        ? Array.from(this.#preRegistered.keys()).map((template) => {\n            return {\n              fileName: template,\n              componentPath: template,\n            }\n          })\n        : []\n\n    /**\n     * Read disk files\n     */\n    if (existsSync(join(diskBasePath, componentsDirName))) {\n      files = files.concat(\n        readdirSync(join(diskBasePath, componentsDirName))\n          .filter((file) => file.endsWith('.edge'))\n          .map((template) => {\n            const fileName = slash(template).replace(/\\.edge$/, '')\n            return {\n              fileName,\n              componentPath: `${componentsDirName}/${fileName}`,\n            }\n          })\n      )\n    }\n\n    return files.map(({ fileName, componentPath }) => {\n      const tagName = fileName\n        .split('/')\n        .filter((segment, index) => {\n          return index === 0 || segment !== 'index'\n        })\n        .map((segment) => string.camelCase(segment))\n        .join('.')\n\n      return {\n        componentName: diskName !== 'default' ? `${diskName}::${componentPath}` : componentPath,\n        tagName: diskName !== 'default' ? `${diskName}.${tagName}` : tagName,\n      }\n    })\n  }\n\n  /**\n   * Returns a list of templates for a given disk\n   */\n  #getDiskTemplates(diskName: string): string[] {\n    const diskBasePath = this.#mountedDirs.get(diskName)!\n    let files = diskName === 'default' ? Array.from(this.#preRegistered.keys()) : []\n\n    if (existsSync(diskBasePath)) {\n      files = files.concat(readdirSync(join(diskBasePath)).filter((file) => file.endsWith('.edge')))\n    }\n\n    return files.map((file) => {\n      const fileName = slash(file).replace(/\\.edge$/, '')\n      return diskName !== 'default' ? `${diskName}::${fileName}` : fileName\n    })\n  }\n\n  /**\n   * Extracts the disk name and the template name from the template\n   * path expression.\n   *\n   * If `diskName` is missing, it will be set to `default`.\n   *\n   * ```\n   * extractDiskAndTemplateName('users::list')\n   * // returns ['users', 'list.edge']\n   *\n   * extractDiskAndTemplateName('list')\n   * // returns ['default', 'list.edge']\n   * ```\n   */\n  #extractDiskAndTemplateName(templatePath: string): [string, string] {\n    let [disk, ...rest] = templatePath.split('::')\n\n    if (!rest.length) {\n      rest = [disk]\n      disk = 'default'\n    }\n\n    let [template, ext] = rest.join('::').split('.edge')\n    return [disk, `${template}.${ext || 'edge'}`]\n  }\n\n  /**\n   * Returns an object of mounted directories with their public\n   * names.\n   *\n   * ```js\n   * loader.mounted\n   * // output\n   *\n   * {\n   *   default: '/users/virk/code/app/views',\n   *   foo: '/users/virk/code/app/foo',\n   * }\n   * ```\n   */\n  get mounted(): { [key: string]: string } {\n    return Array.from(this.#mountedDirs).reduce(\n      (obj, [key, value]) => {\n        obj[key] = value\n        return obj\n      },\n      {} as Record<string, string>\n    )\n  }\n\n  /**\n   * Returns an object of templates registered as a raw string\n   *\n   * ```js\n   * loader.templates\n   * // output\n   *\n   * {\n   *   'form.label': { template: 'Template contents' }\n   * }\n   * ```\n   */\n  get templates(): { [templatePath: string]: LoaderTemplate } {\n    return Array.from(this.#preRegistered).reduce(\n      (obj, [key, value]) => {\n        obj[key] = value\n        return obj\n      },\n      {} as Record<string, LoaderTemplate>\n    )\n  }\n\n  /**\n   * Mount a directory with a name for resolving views. If name is set\n   * to `default`, then you can resolve views without prefixing the\n   * disk name.\n   *\n   * ```js\n   * loader.mount('default', join(__dirname, 'views'))\n   *\n   * // mount a named disk\n   * loader.mount('admin', join(__dirname, 'admin/views'))\n   * ```\n   */\n  mount(diskName: string, dirPath: string | URL): void {\n    this.#mountedDirs.set(diskName, typeof dirPath === 'string' ? dirPath : fileURLToPath(dirPath))\n  }\n\n  /**\n   * Remove the previously mounted dir.\n   *\n   * ```js\n   * loader.unmount('default')\n   * ```\n   */\n  unmount(diskName: string): void {\n    this.#mountedDirs.delete(diskName)\n  }\n\n  /**\n   * Make path to a given template. The paths are resolved from the root\n   * of the mounted directory.\n   *\n   * ```js\n   * loader.makePath('welcome') // returns {diskRootPath}/welcome.edge\n   * loader.makePath('admin::welcome') // returns {adminRootPath}/welcome.edge\n   * loader.makePath('users.list') // returns {diskRootPath}/users/list.edge\n   * ```\n   *\n   * @throws Error if disk is not mounted and attempting to make path for it.\n   */\n  makePath(templatePath: string): string {\n    /**\n     * Return the template path as it is, when it is registered\n     * dynamically\n     */\n    if (this.#preRegistered.has(templatePath)) {\n      return templatePath\n    }\n\n    /**\n     * Return absolute path as it is\n     */\n    if (isAbsolute(templatePath)) {\n      return templatePath\n    }\n\n    /**\n     * Extract disk name and template path from the expression\n     */\n    const [diskName, template] = this.#extractDiskAndTemplateName(templatePath)\n\n    /**\n     * Raise exception when disk name is not registered\n     */\n    const mountedDir = this.#mountedDirs.get(diskName)\n    if (!mountedDir) {\n      throw new Error(`\"${diskName}\" namespace is not mounted`)\n    }\n\n    return join(mountedDir, template)\n  }\n\n  /**\n   * Resolves the template by reading its contents from the disk\n   *\n   * ```js\n   * loader.resolve('welcome', true)\n   *\n   * // output\n   * {\n   *   template: `<h1> Template content </h1>`,\n   * }\n   * ```\n   */\n  resolve(templatePath: string): LoaderTemplate {\n    /**\n     * Return from pre-registered one's if exists\n     */\n    if (this.#preRegistered.has(templatePath)) {\n      return this.#preRegistered.get(templatePath)!\n    }\n\n    /**\n     * Make absolute to the file on the disk\n     */\n    templatePath = isAbsolute(templatePath) ? templatePath : this.makePath(templatePath)\n\n    return {\n      template: this.#readTemplateContents(templatePath),\n    }\n  }\n\n  /**\n   * Register in memory template for a given path. This is super helpful\n   * when distributing components.\n   *\n   * ```js\n   * loader.register('welcome', {\n   *   template: '<h1> Template content </h1>',\n   *   Presenter: class Presenter {\n   *     constructor (state) {\n   *       this.state = state\n   *     }\n   *   }\n   * })\n   * ```\n   *\n   * @throws Error if template content is empty.\n   */\n  register(templatePath: string, contents: LoaderTemplate) {\n    /**\n     * Ensure template content is defined as a string\n     */\n    if (typeof contents.template !== 'string') {\n      throw new Error('Make sure to define the template content as a string')\n    }\n\n    /**\n     * Do not overwrite existing template with same template path\n     */\n    if (this.#preRegistered.has(templatePath)) {\n      throw new Error(`Cannot override previously registered \"${templatePath}\" template`)\n    }\n\n    this.#preRegistered.set(templatePath, contents)\n  }\n\n  /**\n   * Remove registered template\n   */\n  remove(templatePath: string) {\n    this.#preRegistered.delete(templatePath)\n  }\n\n  /**\n   * Returns a list of components from all the disks. We assume\n   * the components are stored within the components directory.\n   *\n   * Also, we treat all in-memory templates as components.\n   *\n   * The return path is same the path you will pass to the `@component`\n   * tag.\n   */\n  listComponents(): ComponentsTree {\n    const diskNames = [...this.#mountedDirs.keys()]\n    return diskNames.map((diskName) => {\n      return {\n        diskName,\n        components: this.#getDiskComponents(diskName),\n      }\n    })\n  }\n\n  /**\n   * Returns a list of templates from all the disks and in-memory\n   * templates as well\n   */\n  listTemplates(): { diskName: string; templates: string[] }[] {\n    const diskNames = [...this.#mountedDirs.keys()]\n    return diskNames.map((diskName) => {\n      return {\n        diskName,\n        templates: this.#getDiskTemplates(diskName),\n      }\n    })\n  }\n}\n","/*\n * edge.js\n *\n * (c) EdgeJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nexport { ifTag as if } from './if.js'\nexport { letTag as let } from './let.js'\nexport { eachTag as each } from './each.js'\nexport { slotTag as slot } from './slot.js'\nexport { elseTag as else } from './else.js'\nexport { evalTag as eval } from './eval.js'\nexport { assignTag as assign } from './assign.js'\nexport { injectTag as inject } from './inject.js'\nexport { unlessTag as unless } from './unless.js'\nexport { elseIfTag as elseif } from './else_if.js'\nexport { includeTag as include } from './include.js'\nexport { debuggerTag as debugger } from './debugger.js'\nexport { newErrorTag as newError } from './new_error.js'\nexport { componentTag as component } from './component.js'\nexport { includeIfTag as includeIf } from './include_if.js'\n","/*\n * edge.js\n *\n * (c) EdgeJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { expressions } from 'edge-parser'\n\nimport { TagContract } from '../types.js'\nimport { unallowedExpression, isNotSubsetOf, parseJsArg } from '../utils.js'\n\n/**\n * If tag is used to define conditional blocks.\n */\nexport const ifTag: TagContract = {\n  block: true,\n  seekable: true,\n  tagName: 'if',\n\n  /**\n   * Compiles the if block node to a Javascript if statement\n   */\n  compile(parser, buffer, token) {\n    const parsed = parseJsArg(parser, token)\n\n    /**\n     * Disallow sequence expressions\n     */\n    isNotSubsetOf(parsed, [expressions.SequenceExpression], () => {\n      unallowedExpression(\n        `\"${token.properties.jsArg}\" is not a valid argument type for the @if tag`,\n        token.filename,\n        parser.utils.getExpressionLoc(parsed)\n      )\n    })\n\n    /**\n     * Start if block\n     */\n    buffer.writeStatement(\n      `if (${parser.utils.stringify(parsed)}) {`,\n      token.filename,\n      token.loc.start.line\n    )\n\n    /**\n     * Process of all children recursively\n     */\n    token.children.forEach((child) => parser.processToken(child, buffer))\n\n    /**\n     * Close if block\n     */\n    buffer.writeStatement('}', token.filename, -1)\n  },\n}\n","/*\n * edge.js\n *\n * (c) EdgeJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { expressions } from 'edge-parser'\nimport lodash from '@poppinss/utils/lodash'\n\nimport { TagContract } from '../types.js'\nimport { isSubsetOf, unallowedExpression } from '../utils.js'\n\n/**\n * The let tag is used to set runtime values within the template. The value\n * is set inside the current scope of the template.\n */\nexport const letTag: TagContract = {\n  block: false,\n  seekable: true,\n  tagName: 'let',\n  noNewLine: true,\n\n  /**\n   * Compiles else block node to Javascript else statement\n   */\n  compile(parser, buffer, token) {\n    const parsed = parser.utils.generateAST(\n      `let ${token.properties.jsArg}`,\n      token.loc,\n      token.filename\n    ).declarations[0]\n\n    const key = parsed.id\n    const value = parsed.init\n\n    /**\n     * The variable name has to be an identifier or the destructuring\n     * operator.\n     */\n    isSubsetOf(key, ['ObjectPattern', expressions.Identifier, 'ArrayPattern'], () => {\n      throw unallowedExpression(\n        `Invalid variable name for the @let tag`,\n        token.filename,\n        parser.utils.getExpressionLoc(key)\n      )\n    })\n\n    /**\n     * Define local variables based upon the expression\n     */\n    if (key.type === 'Identifier') {\n      parser.stack.defineVariable(key.name)\n    } else if (key.type === 'ObjectPattern') {\n      key.properties.forEach((property: any) => {\n        parser.stack.defineVariable(\n          property.argument ? property.argument.name : property.value.name\n        )\n      })\n    } else if (key.type === 'ArrayPattern') {\n      key.elements.forEach((element: any) => {\n        parser.stack.defineVariable(element.argument ? element.argument.name : element.name)\n      })\n    }\n\n    /**\n     * Declare let variable\n     */\n    const expression = `let ${parser.utils.stringify(key)} = ${parser.utils.stringify(\n      parser.utils.transformAst(value, token.filename, parser)\n    )}`\n\n    buffer.writeExpression(expression, token.filename, token.loc.start.line)\n  },\n\n  /**\n   * Add methods to the template for running the loop\n   */\n  boot(template) {\n    template.macro('setValue', lodash.set)\n  },\n}\n","/*\n * edge.js\n *\n * (c) EdgeJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport lodash from '@poppinss/utils/lodash'\nimport * as lexerUtils from 'edge-lexer/utils'\nimport { Parser, expressions } from 'edge-parser'\n\nimport { TagContract } from '../types.js'\nimport { isSubsetOf, asyncEach, each, unallowedExpression } from '../utils.js'\n\ndeclare module '../template.js' {\n  export interface Template {\n    loopAsync: typeof asyncEach\n    loop: typeof each\n    size: (typeof lodash)['size']\n  }\n}\n\n/**\n * Returns the list to loop over for the each binary expression\n */\nfunction getLoopList(rhsExpression: any, parser: Parser, filename: string): string {\n  return parser.utils.stringify(parser.utils.transformAst(rhsExpression, filename, parser))\n}\n\n/**\n * Returns loop item and the index for the each binary expression\n */\nfunction getLoopItemAndIndex(\n  lhsExpression: any,\n  parser: Parser,\n  filename: string\n): [string, string?] {\n  /**\n   * Ensure the LHS content inside `@each()` curly braces is a `SequenceExpression` or\n   * `Identifier`. Anything else is not allowed.\n   *\n   * For example:\n   *\n   * - In `@each(user in users)`, `user` is an indentifier\n   * - In `@each((user, index) in users)`, `(user, index)` is a sequence expression\n   */\n  isSubsetOf(lhsExpression, [expressions.SequenceExpression, expressions.Identifier], () => {\n    unallowedExpression(\n      `invalid left hand side \"${lhsExpression.type}\" expression for the @each tag`,\n      filename,\n      parser.utils.getExpressionLoc(lhsExpression)\n    )\n  })\n\n  /**\n   * Return list index from the sequence expression\n   */\n  if (lhsExpression.type === 'SequenceExpression') {\n    /**\n     * First item of the sequence expression must be an idenifier\n     */\n    isSubsetOf(lhsExpression.expressions[0], [expressions.Identifier], () => {\n      unallowedExpression(\n        `\"${lhsExpression.expressions[0]}.type\" is not allowed as value identifier for @each tag`,\n        filename,\n        parser.utils.getExpressionLoc(lhsExpression.expressions[0])\n      )\n    })\n\n    /**\n     * Second item of the sequence expression must be an idenifier\n     */\n    isSubsetOf(lhsExpression.expressions[1], [expressions.Identifier], () => {\n      unallowedExpression(\n        `\"${lhsExpression.expressions[1]}.type\" is not allowed as key identifier for @each tag`,\n        filename,\n        parser.utils.getExpressionLoc(lhsExpression.expressions[1])\n      )\n    })\n\n    return [lhsExpression.expressions[0].name, lhsExpression.expressions[1].name]\n  }\n\n  /**\n   * There is no key, just the value\n   */\n  return [lhsExpression.name]\n}\n\n/**\n * Each tag is used to run a foreach loop on arrays and even objects.\n *\n * ```edge\n * @each((user, index) in users)\n *   {{ user }} {{ index }}\n * @endeach\n * ```\n */\nexport const eachTag: TagContract = {\n  block: true,\n  seekable: true,\n  tagName: 'each',\n\n  /**\n   * Compile the template\n   */\n  compile(parser, buffer, token) {\n    const awaitKeyword = parser.asyncMode ? 'await ' : ''\n    const loopFunctionName = parser.asyncMode ? 'loopAsync' : 'loop'\n    const asyncKeyword = parser.asyncMode ? 'async ' : ''\n\n    /**\n     * We just generate the AST and do not transform it, since the transform\n     * function attempts to resolve identifiers and we don't want that\n     */\n    const { expression } = parser.utils.generateAST(\n      token.properties.jsArg,\n      token.loc,\n      token.filename\n    )\n\n    /**\n     * Each tag only accepts the binary expression or sequence expression. ie `user in users`\n     */\n    isSubsetOf(expression, [expressions.BinaryExpression], () => {\n      unallowedExpression(\n        `\"${token.properties.jsArg}\" is not valid expression for the @each tag`,\n        token.filename,\n        parser.utils.getExpressionLoc(expression)\n      )\n    })\n\n    /**\n     * Finding if an else child exists inside the each tag\n     */\n    const elseIndex = token.children.findIndex((child) => lexerUtils.isTag(child, 'else'))\n    const elseChildren = elseIndex > -1 ? token.children.splice(elseIndex) : []\n\n    /**\n     * Fetching the item,index and list for the each loop\n     */\n    const list = getLoopList(expression.right, parser, token.filename)\n    const [item, index] = getLoopItemAndIndex(expression.left, parser, token.filename)\n\n    /**\n     * If there is an else statement, then wrap the loop inside the `if` statement first\n     */\n    if (elseIndex > -1) {\n      buffer.writeStatement(`if(template.size(${list})) {`, token.filename, token.loc.start.line)\n    }\n\n    /**\n     * Write the loop statement to the template\n     */\n    const loopCallbackArgs = (index ? [item, index] : [item]).join(',')\n    buffer.writeStatement(\n      `${awaitKeyword}template.${loopFunctionName}(${list}, ${asyncKeyword}function (${loopCallbackArgs}) {`,\n      token.filename,\n      token.loc.start.line\n    )\n\n    /**\n     * Start a new parser scope. So that all variable resolutions for the `item`\n     * are pointing to the local variable and not the template `state`.\n     */\n    parser.stack.defineScope()\n    parser.stack.defineVariable(item)\n    index && parser.stack.defineVariable(index)\n\n    /**\n     * Process all children\n     */\n    token.children.forEach((child) => parser.processToken(child, buffer))\n\n    /**\n     * Clear scope\n     */\n    parser.stack.clearScope()\n\n    /**\n     * Close each loop\n     */\n    buffer.writeExpression('})', token.filename, -1)\n\n    /**\n     * If there is an else statement, then process\n     * else childs and close the if block\n     */\n    if (elseIndex > -1) {\n      elseChildren.forEach((elseChild) => parser.processToken(elseChild, buffer))\n      buffer.writeStatement('}', token.filename, -1)\n    }\n  },\n\n  /**\n   * Add methods to the template for running the loop\n   */\n  boot(template) {\n    template.macro('loopAsync', asyncEach)\n    template.macro('loop', each)\n    template.macro('size', lodash.size)\n  },\n}\n","/*\n * edge.js\n *\n * (c) EdgeJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { EdgeError } from 'edge-error'\nimport { TagContract } from '../types.js'\n\n/**\n * Slot tag is used to define the slots of a given component. Slots cannot be\n * nested and must appear as top level children inside a component.\n */\nexport const slotTag: TagContract = {\n  block: true,\n  seekable: true,\n  tagName: 'slot',\n  noNewLine: true,\n\n  compile(_, __, token) {\n    throw new EdgeError(\n      '@slot tag must appear as top level tag inside the @component tag',\n      'E_ORPHAN_SLOT_TAG',\n      {\n        line: token.loc.start.line,\n        col: token.loc.start.col,\n        filename: token.filename,\n      }\n    )\n  },\n}\n","/*\n * edge.js\n *\n * (c) EdgeJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { TagContract } from '../types.js'\n\nexport const elseTag: TagContract = {\n  block: false,\n  seekable: false,\n  tagName: 'else',\n\n  /**\n   * Compiles else block node to Javascript else statement\n   */\n  compile(_, buffer, token) {\n    buffer.writeStatement('} else {', token.filename, -1)\n  },\n}\n","/*\n * edge.js\n *\n * (c) EdgeJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { parseJsArg } from '../utils.js'\nimport type { TagContract } from '../types.js'\n\n/**\n * The eval tag accepts expressions similar to double curly\n * braces. However, it does not write anything to the\n * output.\n */\nexport const evalTag: TagContract = {\n  block: false,\n  seekable: true,\n  tagName: 'eval',\n  noNewLine: true,\n\n  /**\n   * Compiles the tag AST\n   */\n  compile(parser, buffer, token) {\n    const parsed = parseJsArg(parser, token)\n    buffer.writeExpression(parser.utils.stringify(parsed), token.filename, token.loc.start.line)\n  },\n}\n","/*\n * edge.js\n *\n * (c) EdgeJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { expressions } from 'edge-parser'\nimport lodash from '@poppinss/utils/lodash'\n\nimport { TagContract } from '../types.js'\nimport { isSubsetOf, parseJsArg, unallowedExpression } from '../utils.js'\n\n/**\n * The assign tag is used to re-assign value to an existing variable\n */\nexport const assignTag: TagContract = {\n  block: false,\n  seekable: true,\n  tagName: 'assign',\n  noNewLine: true,\n\n  /**\n   * Compiles else block node to Javascript else statement\n   */\n  compile(parser, buffer, token) {\n    const parsed = parseJsArg(parser, token)\n\n    isSubsetOf(parsed, [expressions.AssignmentExpression], () => {\n      throw unallowedExpression(\n        `Invalid expression for the @assign tag`,\n        token.filename,\n        parser.utils.getExpressionLoc(parsed)\n      )\n    })\n\n    buffer.writeExpression(parser.utils.stringify(parsed), token.filename, token.loc.start.line)\n  },\n\n  /**\n   * Add methods to the template for running the loop\n   */\n  boot(template) {\n    template.macro('setValue', lodash.set)\n  },\n}\n","/*\n * edge.js\n *\n * (c) EdgeJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { expressions } from 'edge-parser'\n\nimport type { TagContract } from '../types.js'\nimport { isSubsetOf, unallowedExpression, parseJsArg } from '../utils.js'\n\n/**\n * The inject tag is used within the components to share values with the\n * component caller.\n */\nexport const injectTag: TagContract = {\n  block: false,\n  seekable: true,\n  tagName: 'inject',\n  noNewLine: true,\n\n  compile(parser, buffer, token) {\n    token.properties.jsArg = `(${token.properties.jsArg})`\n    const parsed = parseJsArg(parser, token)\n\n    /**\n     * The inject tag only accepts an object expression.\n     */\n    isSubsetOf(\n      parsed,\n      [expressions.ObjectExpression, expressions.Identifier, expressions.CallExpression],\n      () => {\n        throw unallowedExpression(\n          `\"${token.properties.jsArg}\" is not a valid key-value pair for the @inject tag`,\n          token.filename,\n          parser.utils.getExpressionLoc(parsed)\n        )\n      }\n    )\n\n    /**\n     * Ensure $slots are defined before merging shared state\n     */\n    buffer.writeStatement(\n      'if (!state.$slots || !state.$slots.$context) {',\n      token.filename,\n      token.loc.start.line\n    )\n    buffer.writeExpression(\n      `throw new Error('Cannot use \"@inject\" outside of a component scope')`,\n      token.filename,\n      token.loc.start.line\n    )\n    buffer.writeStatement('}', token.filename, token.loc.start.line)\n\n    buffer.writeExpression(\n      `Object.assign(state.$slots.$context, ${parser.utils.stringify(parsed)})`,\n      token.filename,\n      token.loc.start.line\n    )\n  },\n}\n","/*\n * edge.js\n *\n * (c) EdgeJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { expressions } from 'edge-parser'\n\nimport { TagContract } from '../types.js'\nimport { isNotSubsetOf, unallowedExpression, parseJsArg } from '../utils.js'\n\n/**\n * Inverse of the `if` condition. The term `unless` is more readable and logical\n * vs using `@if(!expression)`.\n *\n * ```edge\n * @unless(auth.user)\n *   <a href=\"/login\"> Login </a>\n * @endunless\n * ```\n */\nexport const unlessTag: TagContract = {\n  block: true,\n  seekable: true,\n  tagName: 'unless',\n\n  /**\n   * Compiles the if block node to a Javascript if statement\n   */\n  compile(parser, buffer, token) {\n    const parsed = parseJsArg(parser, token)\n\n    /**\n     * Disallow sequence expressions\n     */\n    isNotSubsetOf(parsed, [expressions.SequenceExpression], () => {\n      unallowedExpression(\n        `\"${token.properties.jsArg}\" is not a valid argument type for the @unless tag`,\n        token.filename,\n        parser.utils.getExpressionLoc(parsed)\n      )\n    })\n\n    /**\n     * Start if block\n     */\n    buffer.writeStatement(\n      `if (!${parser.utils.stringify(parsed)}) {`,\n      token.filename,\n      token.loc.start.line\n    )\n\n    /**\n     * Process of all children recursively\n     */\n    token.children.forEach((child) => parser.processToken(child, buffer))\n\n    /**\n     * Close if block\n     */\n    buffer.writeStatement('}', token.filename, -1)\n  },\n}\n","/*\n * edge.js\n *\n * (c) EdgeJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { expressions } from 'edge-parser'\nimport { TagContract } from '../types.js'\nimport { isNotSubsetOf, unallowedExpression, parseJsArg } from '../utils.js'\n\n/**\n * Else if tag is used to define conditional blocks. We keep `@elseif` tag\n * is a inline tag, so that everything between the `if` and the `elseif`\n * comes `if` children.\n */\nexport const elseIfTag: TagContract = {\n  block: false,\n  seekable: true,\n  tagName: 'elseif',\n\n  /**\n   * Compiles the else if block node to a Javascript if statement\n   */\n  compile(parser, buffer, token) {\n    const parsed = parseJsArg(parser, token)\n\n    /**\n     * Disallow sequence expressions\n     */\n    isNotSubsetOf(parsed, [expressions.SequenceExpression], () => {\n      unallowedExpression(\n        `{${token.properties.jsArg}} is not a valid argument type for the @elseif tag`,\n        token.filename,\n        parser.utils.getExpressionLoc(parsed)\n      )\n    })\n\n    /**\n     * Start else if block\n     */\n    buffer.writeStatement(\n      `} else if (${parser.utils.stringify(parsed)}) {`,\n      token.filename,\n      token.loc.start.line\n    )\n  },\n}\n","/*\n * edge.js\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { expressions, Parser } from 'edge-parser'\n\nimport type { TagContract } from '../types.js'\nimport { unallowedExpression, isSubsetOf, parseJsArg } from '../utils.js'\n\n/**\n * List of expressions allowed for the include tag\n */\nexport const ALLOWED_EXPRESSION = [\n  expressions.Literal,\n  expressions.Identifier,\n  expressions.CallExpression,\n  expressions.TemplateLiteral,\n  expressions.MemberExpression,\n  expressions.LogicalExpression,\n  expressions.ConditionalExpression,\n]\n\n/**\n * Returns the expression for rendering the partial\n */\nexport function getRenderExpression(parser: Parser, parsedExpression: any) {\n  /**\n   * We need to pass the local variables to the partial render function\n   */\n  const localVariables = parser.stack.list()\n\n  /**\n   * Arguments for the `renderInline` method\n   */\n  const renderArgs = localVariables.length\n    ? [\n        parser.utils.stringify(parsedExpression),\n        localVariables.map((localVar) => `\"${localVar}\"`).join(','),\n      ]\n    : [parser.utils.stringify(parsedExpression)]\n\n  /**\n   * Arguments for invoking the output function of `renderInline`\n   */\n  const callFnArgs = localVariables.length\n    ? ['template', 'state', '$context', localVariables.map((localVar) => localVar).join(',')]\n    : ['template', 'state', '$context']\n\n  return `template.compilePartial(${renderArgs.join(',')})(${callFnArgs.join(',')})`\n}\n\n/**\n * Include tag is used to include partials in the same scope of the parent\n * template.\n *\n * ```edge\n * @include('partials.header')\n * ```\n */\nexport const includeTag: TagContract = {\n  block: false,\n  seekable: true,\n  tagName: 'include',\n\n  /**\n   * Compiles else block node to Javascript else statement\n   */\n  compile(parser, buffer, token) {\n    const awaitKeyword = parser.asyncMode ? 'await ' : ''\n    const parsed = parseJsArg(parser, token)\n\n    /**\n     * Only mentioned expressions are allowed inside `@include` tag\n     */\n    isSubsetOf(parsed, ALLOWED_EXPRESSION, () => {\n      unallowedExpression(\n        `\"${token.properties.jsArg}\" is not a valid argument type for the @include tag`,\n        token.filename,\n        parser.utils.getExpressionLoc(parsed)\n      )\n    })\n\n    buffer.outputExpression(\n      `${awaitKeyword}${getRenderExpression(parser, parsed)}`,\n      token.filename,\n      token.loc.start.line,\n      false\n    )\n  },\n}\n","/*\n * edge.js\n *\n * (c) EdgeJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { TagContract } from '../types.js'\n\n/**\n * Add debugger break point to the compiled template\n */\nexport const debuggerTag: TagContract = {\n  block: false,\n  seekable: false,\n  tagName: 'debugger',\n  noNewLine: true,\n\n  /**\n   * Compiles `@debugger` tags\n   */\n  compile(_, buffer, token) {\n    buffer.writeExpression('debugger', token.filename, token.loc.start.line)\n  },\n}\n","/*\n * edge.js\n *\n * (c) EdgeJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { expressions } from 'edge-parser'\n\nimport { TagContract } from '../types.js'\nimport { parseJsArg } from '../utils.js'\n\n/**\n * newError tag to raise exceptions inside your templates. They will point\n * back to the exact line:col in the template\n */\nexport const newErrorTag: TagContract = {\n  block: false,\n  seekable: true,\n  tagName: 'newError',\n  noNewLine: true,\n\n  compile(parser, buffer, token) {\n    const parsed = parseJsArg(parser, token)\n\n    let message = ''\n    let line: string | number = token.loc.start.line\n    let col: string | number = token.loc.start.col\n    let filename: string = '$filename'\n\n    if (parsed.type === expressions.SequenceExpression) {\n      message = parser.utils.stringify(parsed.expressions[0])\n      filename = parsed.expressions[1] ? parser.utils.stringify(parsed.expressions[1]) : '$filename'\n      line = parsed.expressions[2]\n        ? parser.utils.stringify(parsed.expressions[2])\n        : token.loc.start.line\n      col = parsed.expressions[3]\n        ? parser.utils.stringify(parsed.expressions[3])\n        : token.loc.start.col\n    } else {\n      message = parser.utils.stringify(parsed)\n    }\n\n    /**\n     * Raise the exception with the correct filename and the line number\n     */\n    buffer.writeStatement(\n      `template.newError(${message}, ${filename}, ${line}, ${col})`,\n      token.filename,\n      token.loc.start.line\n    )\n  },\n}\n","/*\n * edge.js\n *\n * (c) EdgeJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { EdgeError } from 'edge-error'\nimport * as lexerUtils from 'edge-lexer/utils'\nimport type { TagToken } from 'edge-lexer/types'\nimport { EdgeBuffer, expressions, Parser } from 'edge-parser'\n\nimport type { TagContract } from '../types.js'\nimport { isSubsetOf, unallowedExpression, parseJsArg, StringifiedObject } from '../utils.js'\n\n/**\n * A list of allowed expressions for the component name\n */\nconst ALLOWED_EXPRESSION_FOR_COMPONENT_NAME = [\n  expressions.Identifier,\n  expressions.Literal,\n  expressions.LogicalExpression,\n  expressions.MemberExpression,\n  expressions.ConditionalExpression,\n  expressions.CallExpression,\n  expressions.TemplateLiteral,\n] as const\n\n/**\n * Shape of a slot\n */\ntype Slot = {\n  outputVar: string\n  props: any\n  buffer: EdgeBuffer\n  line: number\n  filename: string\n}\n\n/**\n * Returns the component name and props by parsing the component jsArg expression\n */\nfunction getComponentNameAndProps(\n  expression: any,\n  parser: Parser,\n  filename: string\n): [string, string] {\n  let name: string\n\n  /**\n   * Use the first expression inside the sequence expression as the name\n   * of the component\n   */\n  if (expression.type === expressions.SequenceExpression) {\n    name = expression.expressions.shift()\n  } else {\n    name = expression\n  }\n\n  /**\n   * Ensure the component name is a literal value or an expression that\n   * outputs a literal value\n   */\n  isSubsetOf(name, ALLOWED_EXPRESSION_FOR_COMPONENT_NAME, () => {\n    unallowedExpression(\n      `\"${parser.utils.stringify(name)}\" is not a valid argument for component name`,\n      filename,\n      parser.utils.getExpressionLoc(name)\n    )\n  })\n\n  /**\n   * Parse rest of sequence expressions as an objectified string.\n   */\n  if (expression.type === expressions.SequenceExpression) {\n    /**\n     * We only need to entertain the first expression of the sequence\n     * expression, as components allows a max of two arguments\n     */\n    const firstSequenceExpression = expression.expressions[0]\n    return [parser.utils.stringify(name), parser.utils.stringify(firstSequenceExpression)]\n  }\n\n  /**\n   * When top level expression is not a sequence expression, then we assume props\n   * as empty stringified object.\n   */\n  return [parser.utils.stringify(name), '{}']\n}\n\n/**\n * Parses the slot component to fetch it's name and props\n */\nfunction getSlotNameAndProps(token: TagToken, parser: Parser): [string, null | string] {\n  /**\n   * We just generate the acorn AST only, since we don't want parser to transform\n   * ast to edge statements for a `@slot` tag.\n   */\n  const parsed = parser.utils.generateAST(\n    token.properties.jsArg,\n    token.loc,\n    token.filename\n  ).expression\n\n  isSubsetOf(parsed, [expressions.Literal, expressions.SequenceExpression], () => {\n    unallowedExpression(\n      `\"${token.properties.jsArg}\" is not a valid argument type for the @slot tag`,\n      token.filename,\n      parser.utils.getExpressionLoc(parsed)\n    )\n  })\n\n  /**\n   * Fetch the slot name\n   */\n  let name: any\n  if (parsed.type === expressions.SequenceExpression) {\n    name = parsed.expressions[0]\n  } else {\n    name = parsed\n  }\n\n  /**\n   * Validating the slot name to be a literal value, since slot names cannot be dynamic\n   */\n  isSubsetOf(name, [expressions.Literal], () => {\n    unallowedExpression(\n      'slot name must be a valid string literal',\n      token.filename,\n      parser.utils.getExpressionLoc(name)\n    )\n  })\n\n  /**\n   * Return the slot name with empty props, when the expression is a literal\n   * value.\n   */\n  if (parsed.type === expressions.Literal) {\n    return [name.raw, null]\n  }\n\n  /**\n   * Make sure the sequence expression has only 2 arguments in it. Though it doesn't hurt\n   * the rendering of component, we must not run code with false expectations.\n   */\n  if (parsed.expressions.length > 2) {\n    throw new EdgeError('maximum of 2 arguments are allowed for @slot tag', 'E_MAX_ARGUMENTS', {\n      line: parsed.loc.start.line,\n      col: parsed.loc.start.column,\n      filename: token.filename,\n    })\n  }\n\n  isSubsetOf(parsed.expressions[1], [expressions.Identifier], () => {\n    unallowedExpression(\n      `\"${parser.utils.stringify(\n        parsed.expressions[1]\n      )}\" is not valid prop identifier for @slot tag`,\n      token.filename,\n      parser.utils.getExpressionLoc(parsed.expressions[1])\n    )\n  })\n\n  /**\n   * Returning the slot name and slot props name\n   */\n  return [name.raw, parsed.expressions[1].name]\n}\n\n/**\n * The component tag implementation. It is one of the most complex tags and\n * can be used as a reference for creating other tags.\n */\nexport const componentTag: TagContract = {\n  block: true,\n  seekable: true,\n  tagName: 'component',\n\n  compile(parser, buffer, token) {\n    const asyncKeyword = parser.asyncMode ? 'async ' : ''\n    const awaitKeyword = parser.asyncMode ? 'await ' : ''\n    const parsed = parseJsArg(parser, token)\n\n    /**\n     * Check component jsProps for allowed expressions\n     */\n    isSubsetOf(\n      parsed,\n      ALLOWED_EXPRESSION_FOR_COMPONENT_NAME.concat(expressions.SequenceExpression as any),\n      () => {\n        unallowedExpression(\n          `\"${token.properties.jsArg}\" is not a valid argument type for the @component tag`,\n          token.filename,\n          parser.utils.getExpressionLoc(parsed)\n        )\n      }\n    )\n\n    /**\n     * Pulling the name and props for the component. The underlying method will\n     * ensure that the arguments passed to component tag are valid\n     */\n    const [name, props] = getComponentNameAndProps(parsed, parser, token.filename)\n\n    /**\n     * Loop over all the children and set them as part of slots. If no slot\n     * is defined, then the content will be part of the main slot\n     */\n    const slots: { [slotName: string]: Slot } = {}\n\n    /**\n     * Main slot collects everything that is out of the named slots\n     * inside a component\n     */\n    const mainSlot: Slot = {\n      outputVar: 'slot_main',\n      props: {},\n      buffer: buffer.create(token.filename, {\n        outputVar: 'slot_main',\n      }),\n      line: -1,\n      filename: token.filename,\n    }\n\n    let slotsCounter = 0\n\n    /**\n     * Loop over all the component children\n     */\n    token.children.forEach((child) => {\n      /**\n       * If children is not a slot, then add it to the main slot\n       */\n      if (!lexerUtils.isTag(child, 'slot')) {\n        /**\n         * Ignore first newline inside the unnamed main slot\n         */\n        if (mainSlot.buffer.size === 0 && child.type === 'newline') {\n          return\n        }\n        parser.processToken(child, mainSlot.buffer)\n        return\n      }\n\n      /**\n       * Fetch slot and props\n       */\n      const [slotName, slotProps] = getSlotNameAndProps(child, parser)\n      slotsCounter++\n\n      /**\n       * Create a new slot with buffer to process the children\n       */\n      if (!slots[slotName]) {\n        /**\n         * Slot buffer points to the component file name, since slots doesn't\n         * have their own file names.\n         */\n        slots[slotName] = {\n          outputVar: `slot_${slotsCounter}`,\n          buffer: buffer.create(token.filename, {\n            outputVar: `slot_${slotsCounter}`,\n          }),\n          props: slotProps,\n          line: -1,\n          filename: token.filename,\n        }\n\n        /**\n         * Only start the frame, when there are props in use for a given slot.\n         */\n        if (slotProps) {\n          parser.stack.defineScope()\n          parser.stack.defineVariable(slotProps)\n        }\n      }\n\n      /**\n       * Self process the slot children.\n       */\n      child.children.forEach((grandChildren) => {\n        parser.processToken(grandChildren, slots[slotName].buffer)\n      })\n\n      /**\n       * Close the frame after process the slot children\n       */\n      if (slotProps) {\n        parser.stack.clearScope()\n      }\n    })\n\n    const obj = new StringifiedObject()\n\n    /**\n     * Creating a shallow copy of context for the component slots and its children\n     */\n    obj.add('$context', 'Object.assign({}, $context)')\n\n    /**\n     * Add main slot to the stringified object, when main slot\n     * is not defined otherwise.\n     */\n    if (!slots['main']) {\n      if (mainSlot.buffer.size) {\n        mainSlot.buffer.wrap(`${asyncKeyword}function () { const $context = this.$context;`, '}')\n        obj.add('main', mainSlot.buffer.disableFileAndLineVariables().flush())\n      } else {\n        obj.add('main', 'function () { return \"\" }')\n      }\n    }\n\n    /**\n     * We convert the slots to an objectified string, that is passed to `template.renderWithState`,\n     * which will pass it to the component as it's local state.\n     */\n    Object.keys(slots).forEach((slotName) => {\n      if (slots[slotName].buffer.size) {\n        const fnCall = slots[slotName].props\n          ? `${asyncKeyword}function (${slots[slotName].props}) { const $context = this.$context;`\n          : `${asyncKeyword}function () { const $context = this.$context;`\n        slots[slotName].buffer.wrap(fnCall, '}')\n\n        obj.add(slotName, slots[slotName].buffer.disableFileAndLineVariables().flush())\n      } else {\n        obj.add(slotName, 'function () { return \"\" }')\n      }\n    })\n\n    const caller = new StringifiedObject()\n    caller.add('filename', '$filename')\n    caller.add('line', '$lineNumber')\n    caller.add('col', 0)\n\n    /**\n     * Write the line to render the component with it's own state\n     */\n    buffer.outputExpression(\n      `${awaitKeyword}template.compileComponent(${name})(template, template.getComponentState(${props}, ${obj.flush()}, ${caller.flush()}), $context)`,\n      token.filename,\n      token.loc.start.line,\n      false\n    )\n  },\n}\n","/*\n * edge.js\n *\n * (c) EdgeJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { EdgeError } from 'edge-error'\nimport { expressions } from 'edge-parser'\n\nimport { TagContract } from '../types.js'\nimport { ALLOWED_EXPRESSION, getRenderExpression } from './include.js'\nimport { unallowedExpression, isSubsetOf, parseJsArg, isNotSubsetOf } from '../utils.js'\n\n/**\n * Include tag is used to include partials in the same scope of the parent\n * template.\n *\n * ```edge\n * @include('partials.header')\n * ```\n */\nexport const includeIfTag: TagContract = {\n  block: false,\n  seekable: true,\n  tagName: 'includeIf',\n\n  /**\n   * Compiles else block node to Javascript else statement\n   */\n  compile(parser, buffer, token) {\n    const awaitKeyword = parser.asyncMode ? 'await ' : ''\n    const parsed = parseJsArg(parser, token)\n\n    /**\n     * The include if only accepts the sequence expression\n     */\n    isSubsetOf(parsed, [expressions.SequenceExpression], () => {\n      unallowedExpression(\n        `\"${token.properties.jsArg}\" is not a valid argument type for the @includeIf tag`,\n        token.filename,\n        parser.utils.getExpressionLoc(parsed)\n      )\n    })\n\n    /**\n     * Disallow more than or less than 2 values for the sequence expression\n     */\n    if (parsed.expressions.length !== 2) {\n      throw new EdgeError('@includeIf expects a total of 2 arguments', 'E_ARGUMENTS_MIS_MATCH', {\n        line: parsed.loc.start.line,\n        col: parsed.loc.start.column,\n        filename: token.filename,\n      })\n    }\n\n    const [conditional, include] = parsed.expressions\n\n    isNotSubsetOf(conditional, [expressions.SequenceExpression], () => {\n      unallowedExpression(\n        `\"${conditional.type}\" is not a valid 1st argument type for the @includeIf tag`,\n        token.filename,\n        parser.utils.getExpressionLoc(conditional)\n      )\n    })\n\n    isSubsetOf(include, ALLOWED_EXPRESSION, () => {\n      unallowedExpression(\n        `\"${include.type}\" is not a valid 2nd argument type for the @includeIf tag`,\n        token.filename,\n        parser.utils.getExpressionLoc(include)\n      )\n    })\n\n    buffer.writeStatement(\n      `if (${parser.utils.stringify(conditional)}) {`,\n      token.filename,\n      token.loc.start.line\n    )\n    buffer.outputExpression(\n      `${awaitKeyword}${getRenderExpression(parser, include)}`,\n      token.filename,\n      token.loc.start.line,\n      false\n    )\n    buffer.writeStatement('}', token.filename, -1)\n  },\n}\n","/*\n * edge.js\n *\n * (c) EdgeJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { EdgeError } from 'edge-error'\nimport * as lexerUtils from 'edge-lexer/utils'\nimport { Parser, EdgeBuffer, Stack } from 'edge-parser'\nimport type { Token, TagToken } from 'edge-lexer/types'\n\nimport { Processor } from './processor.js'\nimport { CacheManager } from './cache_manager.js'\nimport type {\n  ClaimTagFn,\n  TagsContract,\n  LoaderContract,\n  CompilerOptions,\n  CompiledTemplate,\n} from './types.js'\n\nconst AsyncFunction = Object.getPrototypeOf(async function () {}).constructor\n\n/**\n * Compiler is to used to compile templates using the `edge-parser`. Along with that\n * it natively merges the contents of a layout with a parent template.\n */\nexport class Compiler {\n  /**\n   * The variables someone can access inside templates. All other\n   * variables will get prefixed with `state` property name\n   */\n  #inlineVariables: string[] = ['$filename', 'state', '$context']\n\n  /**\n   * A fixed set of params to pass to the template every time.\n   */\n  #templateParams = ['template', 'state', '$context']\n\n  #claimTagFn?: ClaimTagFn\n  #loader: LoaderContract\n  #tags: TagsContract\n  #processor: Processor\n\n  /**\n   * Caches compiled templates\n   */\n  cacheManager: CacheManager\n\n  /**\n   * A boolean to know if compat mode is enabled\n   */\n  compat: boolean\n\n  /**\n   * Know if compiler is compiling in the async mode or not\n   */\n  async: boolean\n\n  constructor(\n    loader: LoaderContract,\n    tags: TagsContract,\n    processor: Processor,\n    options: CompilerOptions = {\n      cache: true,\n      async: false,\n      compat: false,\n    }\n  ) {\n    this.#processor = processor\n    this.#loader = loader\n    this.#tags = tags\n\n    this.async = !!options.async\n    this.compat = options.compat === true\n    this.cacheManager = new CacheManager(!!options.cache)\n  }\n\n  /**\n   * Merges sections of base template and parent template tokens\n   */\n  #mergeSections(base: Token[], extended: Token[]): Token[] {\n    /**\n     * Collection of all sections from the extended tokens\n     */\n    const extendedSections: { [key: string]: TagToken } = {}\n\n    /**\n     * Collection of extended set calls as top level nodes. The set\n     * calls are hoisted just like `var` statements in Javascript.\n     */\n    const extendedSetCalls: TagToken[] = []\n\n    extended.forEach((node) => {\n      /**\n       * Ignore new lines, comments, layout tag and empty raw nodes inside the parent\n       * template\n       */\n      if (\n        lexerUtils.isTag(node, 'layout') ||\n        node.type === 'newline' ||\n        (node.type === 'raw' && !node.value.trim()) ||\n        node.type === 'comment'\n      ) {\n        return\n      }\n\n      /**\n       * Collect parent template sections\n       */\n      if (lexerUtils.isTag(node, 'section')) {\n        extendedSections[(node as TagToken).properties.jsArg.trim()] = node\n        return\n      }\n\n      /**\n       * Collect set calls inside parent templates\n       */\n      if (lexerUtils.isTag(node, 'set')) {\n        extendedSetCalls.push(node)\n        return\n      }\n\n      /**\n       * Everything else is not allowed as top level nodes\n       */\n      const [line, col] = lexerUtils.getLineAndColumn(node)\n\n      throw new EdgeError(\n        'Template extending a layout can only use \"@section\" or \"@set\" tags as top level nodes',\n        'E_UNALLOWED_EXPRESSION',\n        { line, col, filename: node.filename }\n      )\n    })\n\n    /**\n     * Replace/extend sections inside base tokens list\n     */\n    const finalNodes = base.map((node) => {\n      if (!lexerUtils.isTag(node, 'section')) {\n        return node\n      }\n\n      const sectionName = node.properties.jsArg.trim()\n      const extendedNode = extendedSections[sectionName]\n      if (!extendedNode) {\n        return node\n      }\n\n      /**\n       * Concat children when super was called\n       */\n      if (extendedNode.children.length) {\n        if (lexerUtils.isTag(extendedNode.children[0], 'super')) {\n          extendedNode.children.shift()\n          extendedNode.children = node.children.concat(extendedNode.children)\n        } else if (lexerUtils.isTag(extendedNode.children[1], 'super')) {\n          extendedNode.children.shift()\n          extendedNode.children.shift()\n          extendedNode.children = node.children.concat(extendedNode.children)\n        }\n      }\n\n      return extendedNode\n    })\n\n    /**\n     * Set calls are hoisted to the top\n     */\n    return ([] as Token[]).concat(extendedSetCalls).concat(finalNodes)\n  }\n\n  /**\n   * Generates an array of lexer tokens from the template string. Further tokens\n   * are checked for layouts and if layouts are used, their sections will be\n   * merged together.\n   */\n  #templateContentToTokens(content: string, parser: Parser, absPath: string): Token[] {\n    let templateTokens = parser.tokenize(content, { filename: absPath })\n\n    /**\n     * Parse layout and section in compat mode only\n     */\n    if (this.compat) {\n      const firstToken = templateTokens[0]\n\n      /**\n       * The `layout` is inbuilt feature from core, where we merge the layout\n       * and parent template sections together\n       */\n      if (lexerUtils.isTag(firstToken, 'layout')) {\n        const layoutName = firstToken.properties.jsArg.replace(/'|\"/g, '')\n        templateTokens = this.#mergeSections(this.tokenize(layoutName, parser), templateTokens)\n      }\n    }\n\n    return templateTokens\n  }\n\n  /**\n   * Returns the parser instance for a given template\n   */\n  #getParserFor(templatePath: string, localVariables?: string[]) {\n    const parser = new Parser(this.#tags, new Stack(), {\n      claimTag: this.#claimTagFn,\n      async: this.async,\n      statePropertyName: 'state',\n      escapeCallPath: ['template', 'escape'],\n      localVariables: this.#inlineVariables,\n      onTag: (tag) => this.#processor.executeTag({ tag, path: templatePath }),\n    })\n\n    /**\n     * Define local variables on the parser. This is helpful when trying to compile\n     * a partail and we want to share the local state of the parent template\n     * with it\n     */\n    if (localVariables) {\n      localVariables.forEach((localVariable) => parser.stack.defineVariable(localVariable))\n    }\n\n    return parser\n  }\n\n  /**\n   * Returns the parser instance for a given template\n   */\n  #getBufferFor(templatePath: string) {\n    return new EdgeBuffer(templatePath, {\n      outputVar: 'out',\n      rethrowCallPath: ['template', 'reThrow'],\n    })\n  }\n\n  /**\n   * Wraps template output to a function along with local variables\n   */\n  #wrapToFunction(template: string, localVariables?: string[]): CompiledTemplate {\n    const args = localVariables ? this.#templateParams.concat(localVariables) : this.#templateParams\n\n    if (this.async) {\n      return new AsyncFunction(...args, template)\n    }\n\n    return new Function(...args, template) as CompiledTemplate\n  }\n\n  /**\n   * Define a function to claim tags\n   */\n  claimTag(fn: ClaimTagFn): this {\n    this.#claimTagFn = fn\n    return this\n  }\n\n  /**\n   * Converts the template content to an array of lexer tokens. The method is\n   * same as the `parser.tokenize`, but it also handles layouts natively.\n   *\n   * ```\n   * compiler.tokenize('<template-path>')\n   * ```\n   */\n  tokenize(templatePath: string, parser?: Parser): Token[] {\n    const absPath = this.#loader.makePath(templatePath)\n    let { template } = this.#loader.resolve(absPath)\n    return this.tokenizeRaw(template, absPath, parser)\n  }\n\n  /**\n   * Tokenize a raw template\n   */\n  tokenizeRaw(contents: string, templatePath: string = 'eval.edge', parser?: Parser): Token[] {\n    contents = this.#processor.executeRaw({ path: templatePath, raw: contents })\n    return this.#templateContentToTokens(\n      contents,\n      parser || this.#getParserFor(templatePath),\n      templatePath\n    )\n  }\n\n  /**\n   * Compiles the template contents to string. The output is same as the `edge-parser`,\n   * it's just that the compiler uses the loader to load the templates and also\n   * handles layouts.\n   *\n   * ```js\n   * compiler.compile('welcome')\n   * ```\n   */\n  compile(templatePath: string, localVariables?: string[]): CompiledTemplate {\n    const absPath = this.#loader.makePath(templatePath)\n    let cachedResponse = localVariables ? null : this.cacheManager.get(absPath)\n\n    /**\n     * Process the template and cache it\n     */\n    if (!cachedResponse) {\n      const parser = this.#getParserFor(absPath, localVariables)\n      const buffer = this.#getBufferFor(absPath)\n\n      /**\n       * Generate tokens and process them\n       */\n      const templateTokens = this.tokenize(absPath, parser)\n      templateTokens.forEach((token) => parser.processToken(token, buffer))\n\n      /**\n       * Processing template via hook\n       */\n      const template = this.#processor.executeCompiled({\n        path: absPath,\n        compiled: buffer.flush(),\n      })\n\n      const compiledTemplate = this.#wrapToFunction(template, localVariables)\n      if (!localVariables) {\n        this.cacheManager.set(absPath, compiledTemplate)\n      }\n\n      cachedResponse = compiledTemplate\n    }\n\n    return cachedResponse!\n  }\n\n  /**\n   * Compiles the template contents to string. The output is same as the `edge-parser`,\n   * it's just that the compiler uses the loader to load the templates and also\n   * handles layouts.\n   *\n   * ```js\n   * compiler.compileRaw('welcome')\n   * ```\n   */\n  compileRaw(contents: string, templatePath: string = 'eval.edge'): CompiledTemplate {\n    const parser = this.#getParserFor(templatePath)\n    const buffer = this.#getBufferFor(templatePath)\n    const templateTokens = this.tokenizeRaw(contents, templatePath, parser)\n\n    templateTokens.forEach((token) => parser.processToken(token, buffer))\n\n    const template = this.#processor.executeCompiled({\n      path: templatePath,\n      compiled: buffer.flush(),\n    })\n\n    return this.#wrapToFunction(template)\n  }\n}\n","/*\n * edge.js\n *\n * (c) EdgeJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { CacheManagerContract, CompiledTemplate } from './types.js'\n\n/**\n * In memory cache manager to cache pre-compiled templates.\n */\nexport class CacheManager implements CacheManagerContract {\n  #cacheStore: Map<string, CompiledTemplate> = new Map()\n\n  constructor(public enabled: boolean) {}\n\n  /**\n   * Returns a boolean to tell if a template has already been cached\n   * or not.\n   */\n  has(absPath: string): boolean {\n    return this.#cacheStore.has(absPath)\n  }\n\n  /**\n   * Returns the template from the cache. If caching is disabled,\n   * then it will return undefined.\n   */\n  get(absPath: string): undefined | CompiledTemplate {\n    if (!this.enabled) {\n      return\n    }\n\n    return this.#cacheStore.get(absPath)\n  }\n\n  /**\n   * Set's the template path and the payload to the cache. If\n   * cache is disabled, then this function results in a noop.\n   */\n  set(absPath: string, payload: CompiledTemplate) {\n    if (!this.enabled) {\n      return\n    }\n\n    this.#cacheStore.set(absPath, payload)\n  }\n\n  /**\n   * Delete template from the compiled cache\n   */\n  delete(absPath: string) {\n    if (!this.enabled) {\n      return\n    }\n\n    this.#cacheStore.delete(absPath)\n  }\n}\n","/*\n * edge.js.js\n *\n * (c) EdgeJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n// @ts-expect-error untyped module\nimport stringify from 'js-stringify'\nimport classNames from 'classnames'\n// @ts-expect-error untyped module\nimport inspect from '@poppinss/inspect'\nimport string from '@poppinss/utils/string'\n\nimport type { EdgeGlobals } from '../types.js'\nimport { htmlSafe, escape } from '../template.js'\nimport { stringifyAttributes } from '../utils.js'\n\n/**\n * Inbuilt globals\n */\nexport const edgeGlobals: EdgeGlobals = {\n  /**\n   * Converts new lines to break\n   */\n  nl2br: (value: string | null | undefined) => {\n    if (!value) {\n      return\n    }\n\n    return String(value).replace(/([^>\\r\\n]?)(\\r\\n|\\n\\r|\\r|\\n)/g, '$1<br>')\n  },\n\n  /**\n   * Inspect state\n   */\n  inspect: (value: any) => {\n    return htmlSafe(inspect.string.html(value))\n  },\n\n  /**\n   * Truncate a sentence\n   */\n  truncate: (\n    value: string,\n    length: number = 20,\n    options?: { completeWords?: boolean; strict?: boolean; suffix?: string }\n  ) => {\n    options = options || {}\n    return string.truncate(value, length, {\n      completeWords: options.completeWords !== undefined ? options.completeWords : !options.strict,\n      suffix: options.suffix,\n    })\n  },\n\n  /**\n   * Generate an excerpt\n   */\n  excerpt: (\n    value: string,\n    length: number = 20,\n    options?: { completeWords?: boolean; strict?: boolean; suffix?: string }\n  ) => {\n    options = options || {}\n    return string.excerpt(value, length, {\n      completeWords: options.completeWords !== undefined ? options.completeWords : !options.strict,\n      suffix: options.suffix,\n    })\n  },\n\n  /**\n   * Helpers related to HTML\n   */\n  html: {\n    escape: escape,\n    safe: htmlSafe,\n    classNames: classNames,\n    attrs: (values: Record<string, any>) => {\n      return htmlSafe(stringifyAttributes(values))\n    },\n  },\n\n  /**\n   * Helpers related to JavaScript\n   */\n  js: {\n    stringify: stringify,\n  },\n\n  camelCase: string.camelCase,\n  snakeCase: string.snakeCase,\n  dashCase: string.dashCase,\n  pascalCase: string.pascalCase,\n  capitalCase: string.capitalCase,\n  sentenceCase: string.sentenceCase,\n  dotCase: string.dotCase,\n  noCase: string.noCase,\n  titleCase: string.titleCase,\n  pluralize: string.pluralize,\n  sentence: string.sentence,\n  prettyMs: string.milliseconds.format,\n  toMs: string.milliseconds.parse,\n  prettyBytes: string.bytes.format,\n  toBytes: string.bytes.parse,\n  ordinal: string.ordinal,\n}\n","/*\n * edge.js\n *\n * (c) EdgeJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { Template } from './template.js'\nimport type { TagToken } from 'edge-lexer/types'\n\n/**\n * Exposes the API to register a set of handlers to process the\n * templates output at different stages\n */\nexport class Processor {\n  #handlers: Map<string, Set<(...args: any[]) => any>> = new Map()\n\n  /**\n   * Execute tag handler\n   */\n  executeTag(data: { tag: TagToken; path: string }): void {\n    const handlers = this.#handlers.get('tag')\n    if (!handlers) {\n      return\n    }\n\n    handlers.forEach((handler) => {\n      handler(data)\n    })\n  }\n\n  /**\n   * Execute raw handlers\n   */\n  executeRaw(data: { raw: string; path: string }): string {\n    const handlers = this.#handlers.get('raw')\n    if (!handlers) {\n      return data.raw\n    }\n\n    handlers.forEach((handler) => {\n      const output = handler(data)\n      if (output !== undefined) {\n        data.raw = output\n      }\n    })\n\n    return data.raw\n  }\n\n  /**\n   * Execute compiled handlers\n   */\n  executeCompiled(data: { compiled: string; path: string }): string {\n    const handlers = this.#handlers.get('compiled')\n    if (!handlers) {\n      return data.compiled\n    }\n\n    handlers.forEach((handler) => {\n      const output = handler(data)\n      if (output !== undefined) {\n        data.compiled = output\n      }\n    })\n\n    return data.compiled\n  }\n\n  /**\n   * Execute output handlers\n   */\n  executeOutput(data: { output: string; template: Template; state: Record<string, any> }): string {\n    const handlers = this.#handlers.get('output')\n    if (!handlers) {\n      return data.output\n    }\n\n    handlers.forEach((handler) => {\n      const output = handler(data)\n      if (output !== undefined) {\n        data.output = output\n      }\n    })\n\n    return data.output\n  }\n\n  /**\n   * Define a processor function\n   */\n  process(event: 'raw', handler: (data: { raw: string; path: string }) => string | void): this\n  process(event: 'tag', handler: (data: { tag: TagToken; path: string }) => void): this\n  process(\n    event: 'compiled',\n    handler: (data: { compiled: string; path: string }) => string | void\n  ): this\n  process(\n    event: 'output',\n    handler: (data: {\n      output: string\n      template: Template\n      state: Record<string, any>\n    }) => string | void\n  ): this\n  process(event: string, handler: (...args: any[]) => any): this {\n    if (!this.#handlers.has(event)) {\n      this.#handlers.set(event, new Set())\n    }\n\n    this.#handlers.get(event)!.add(handler)\n    return this\n  }\n}\n","/*\n * edge.js\n *\n * (c) EdgeJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport lodash from '@poppinss/utils/lodash'\n\nimport { Template } from '../template.js'\nimport { Processor } from '../processor.js'\nimport type { Compiler } from '../compiler.js'\n\n/**\n * Renders a given template with it's shared state\n */\nexport class EdgeRenderer {\n  #compiler: Compiler\n  #processor: Processor\n  #asyncCompiler: Compiler\n\n  /**\n   * Global state\n   */\n  #locals: Record<string, any> = {}\n  #globals: Record<string, any>\n\n  constructor(\n    compiler: Compiler,\n    asyncCompiler: Compiler,\n    processor: Processor,\n    globals: Record<string, any>\n  ) {\n    this.#compiler = compiler\n    this.#asyncCompiler = asyncCompiler\n    this.#processor = processor\n\n    this.#globals = globals\n  }\n\n  /**\n   * Share local variables with the template. They will overwrite the\n   * globals\n   */\n  share(data: Record<string, any>): this {\n    lodash.merge(this.#locals, data)\n    return this\n  }\n\n  /**\n   * Render the template\n   */\n  async render(templatePath: string, state: Record<string, any> = {}): Promise<string> {\n    return new Template(this.#asyncCompiler, this.#globals, this.#locals, this.#processor).render(\n      templatePath,\n      state\n    )\n  }\n\n  /**\n   * Render the template\n   */\n  renderSync(templatePath: string, state: Record<string, any> = {}): string {\n    return new Template(\n      this.#compiler,\n      this.#globals,\n      this.#locals,\n      this.#processor\n    ).render<string>(templatePath, state)\n  }\n\n  /**\n   * Render the template from a raw string\n   */\n  async renderRaw(\n    contents: string,\n    state: Record<string, any> = {},\n    templatePath?: string\n  ): Promise<string> {\n    return new Template(\n      this.#asyncCompiler,\n      this.#globals,\n      this.#locals,\n      this.#processor\n    ).renderRaw(contents, state, templatePath)\n  }\n\n  /**\n   * Render the template from a raw string\n   */\n  renderRawSync(contents: string, state: Record<string, any> = {}, templatePath?: string): string {\n    return new Template(this.#compiler, this.#globals, this.#locals, this.#processor).renderRaw(\n      contents,\n      state,\n      templatePath\n    )\n  }\n}\n","/*\n * edge.js\n *\n * (c) EdgeJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { Edge } from '../edge/main.js'\nimport { PluginFn } from '../types.js'\n\n/**\n * Hooks into the compiler phase of Edge and converts\n * tags to components.\n *\n * The components are discovered from the components directory\n * inside every registered disk.\n */\nclass SuperChargedComponents {\n  #edge: Edge\n  #components: Record<string, string> = {}\n\n  constructor(edge: Edge) {\n    this.#edge = edge\n    this.#claimTags()\n    this.#transformTags()\n  }\n\n  /**\n   * Refreshes the list of components\n   */\n  refreshComponents() {\n    this.#components = this.#edge.loader\n      .listComponents()\n      .reduce<Record<string, string>>((result, { components }) => {\n        components.forEach((component) => {\n          result[component.tagName] = component.componentName\n        })\n        return result\n      }, {})\n  }\n\n  /**\n   * Registers hook to claim self processing of tags that\n   * are references to components\n   */\n  #claimTags() {\n    this.#edge.compiler.claimTag((name) => {\n      if (this.#components[name]) {\n        return { seekable: true, block: true }\n      }\n      return null\n    })\n\n    this.#edge.asyncCompiler.claimTag((name) => {\n      if (this.#components[name]) {\n        return { seekable: true, block: true }\n      }\n      return null\n    })\n  }\n\n  /**\n   * Transforms tags to component calls\n   */\n  #transformTags() {\n    this.#edge.processor.process('tag', ({ tag }) => {\n      const component = this.#components[tag.properties.name]\n      if (!component) {\n        return\n      }\n\n      tag.properties.name = 'component'\n      if (tag.properties.jsArg.trim() === '') {\n        tag.properties.jsArg = `'${component}'`\n      } else {\n        tag.properties.jsArg = `'${component}',${tag.properties.jsArg}`\n      }\n    })\n  }\n}\n\n/**\n * The superCharged plugin converts components stored within the\n * components directory of all the disk to Edge tags.\n */\nlet superCharged: SuperChargedComponents\nexport const pluginSuperCharged: PluginFn<{ recurring: boolean }> = (edge, firstRun) => {\n  if (firstRun) {\n    superCharged = new SuperChargedComponents(edge)\n  }\n  superCharged.refreshComponents()\n}\n","/*\n * edge.js\n *\n * (c) EdgeJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { Loader } from '../loader.js'\nimport * as Tags from '../tags/main.js'\nimport { Compiler } from '../compiler.js'\nimport { Template } from '../template.js'\nimport { edgeGlobals } from './globals.js'\nimport { Processor } from '../processor.js'\nimport { EdgeRenderer } from './renderer.js'\nimport type {\n  PluginFn,\n  TagContract,\n  EdgeGlobals,\n  EdgeOptions,\n  LoaderTemplate,\n  LoaderContract,\n} from '../types.js'\nimport { pluginSuperCharged } from '../plugins/supercharged.js'\n\n/**\n * Exposes the API to render templates, register custom tags and globals\n */\nexport class Edge {\n  /**\n   * Create an instance of edge with given options\n   */\n  static create(options: EdgeOptions = {}) {\n    return new Edge(options)\n  }\n\n  /**\n   * An array of bundled plugins\n   */\n  #bundledPlugins: {\n    fn: PluginFn<any>\n    executed: boolean\n    options?: any\n  }[] = []\n\n  /**\n   * An array of registered plugins\n   */\n  #plugins: {\n    fn: PluginFn<any>\n    executed: boolean\n    options?: any\n  }[] = []\n\n  /**\n   * Array of registered renderer hooks\n   */\n  #renderCallbacks: ((renderer: EdgeRenderer) => void)[] = []\n\n  /**\n   * Reference to the registered processor handlers\n   */\n  processor = new Processor()\n\n  /**\n   * A flag to know if using compat mode\n   */\n  compat: boolean = false\n\n  /**\n   * The loader to load templates. A loader can read and return\n   * templates from anywhere. The default loader reads files\n   * from the disk\n   */\n  declare loader: LoaderContract\n\n  /**\n   * The underlying compiler in use\n   */\n  declare compiler: Compiler\n\n  /**\n   * The underlying compiler in use\n   */\n  declare asyncCompiler: Compiler\n\n  /**\n   * Globals are shared with all rendered templates\n   */\n  globals: EdgeGlobals = { ...edgeGlobals }\n\n  /**\n   * List of registered tags. Adding new tags will only impact\n   * this list\n   */\n  tags: { [name: string]: TagContract } = {}\n\n  constructor(options: EdgeOptions = {}) {\n    this.configure(options)\n\n    /**\n     * Registering bundled set of tags\n     */\n    Object.keys(Tags).forEach((name) => {\n      this.registerTag(Tags[name as keyof typeof Tags])\n    })\n\n    this.#bundledPlugins.push({\n      fn: pluginSuperCharged,\n      executed: false,\n      options: { recurring: !options.cache },\n    })\n  }\n\n  /**\n   * Re-configure an existing edge instance\n   */\n  configure(options: EdgeOptions) {\n    if (options.loader) {\n      this.loader = options.loader\n    } else if (!this.loader) {\n      this.loader = new Loader()\n    }\n\n    this.compiler = new Compiler(this.loader, this.tags, this.processor, {\n      cache: !!options.cache,\n      async: false,\n    })\n\n    this.asyncCompiler = new Compiler(this.loader, this.tags, this.processor, {\n      cache: !!options.cache,\n      async: true,\n    })\n  }\n\n  /**\n   * Execute plugins\n   */\n  #executePlugins() {\n    /**\n     * Running user-land plugins\n     */\n    this.#plugins\n      .filter(({ options, executed }) => {\n        if (options && options.recurring) {\n          return true\n        }\n        return !executed\n      })\n      .forEach((plugin) => {\n        plugin.fn(this, !plugin.executed, plugin.options)\n        plugin.executed = true\n      })\n\n    /**\n     * Running bundled plugins after the user-land\n     * plugins\n     */\n    this.#bundledPlugins\n      .filter(({ options, executed }) => {\n        if (options && options.recurring) {\n          return true\n        }\n        return !executed\n      })\n      .forEach((plugin) => {\n        plugin.fn(this, !plugin.executed, plugin.options)\n        plugin.executed = true\n      })\n  }\n\n  /**\n   * Register a plugin. Plugins are called only once just before\n   * a rendering a view.\n   *\n   * You can invoke a plugin multiple times by marking it as a\n   * recurring plugin\n   */\n  use<T extends any>(pluginFn: PluginFn<T>, options?: T): this {\n    this.#plugins.push({\n      fn: pluginFn,\n      executed: false,\n      options,\n    })\n    return this\n  }\n\n  /**\n   * Mount named directory to use views. Later you can reference\n   * the views from a named disk as follows.\n   *\n   * ```\n   * edge.mount('admin', join(__dirname, 'admin'))\n   *\n   * edge.render('admin::filename')\n   * ```\n   */\n  mount(viewsDirectory: string | URL): this\n  mount(diskName: string, viewsDirectory: string | URL): this\n  mount(diskName: string | URL, viewsDirectory?: string | URL): this {\n    if (!viewsDirectory) {\n      viewsDirectory = diskName\n      diskName = 'default'\n    }\n\n    this.loader.mount(diskName as string, viewsDirectory)\n    return this\n  }\n\n  /**\n   * Un Mount a disk from the loader.\n   *\n   * ```js\n   * edge.unmount('admin')\n   * ```\n   */\n  unmount(diskName: string): this {\n    this.loader.unmount(diskName)\n    return this\n  }\n\n  /**\n   * Add a new global to the edge globals. The globals are available\n   * to all the templates.\n   *\n   * ```js\n   * edge.global('username', 'virk')\n   * edge.global('time', () => new Date().getTime())\n   * ```\n   */\n  global(name: string, value: any): this {\n    this.globals[name] = value\n    return this\n  }\n\n  /**\n   * Add a new tag to the tags list.\n   *\n   * ```ts\n   * edge.registerTag('svg', {\n   *   block: false,\n   *   seekable: true,\n   *\n   *   compile (parser, buffer, token) {\n   *     const fileName = token.properties.jsArg.trim()\n   *     buffer.writeRaw(fs.readFileSync(__dirname, 'assets', `${fileName}.svg`), 'utf-8')\n   *   }\n   * })\n   * ```\n   */\n  registerTag(tag: TagContract): this {\n    if (typeof tag.boot === 'function') {\n      tag.boot(Template)\n    }\n\n    this.tags[tag.tagName] = tag\n    return this\n  }\n\n  /**\n   * Register an in-memory template.\n   *\n   * ```ts\n   * edge.registerTemplate('button', {\n   *   template: `<button class=\"{{ this.type || 'primary' }}\">\n   *     @!yield($slots.main())\n   *   </button>`,\n   * })\n   * ```\n   *\n   * Later you can use this template\n   *\n   * ```edge\n   * @component('button', type = 'primary')\n   *   Get started\n   * @endcomponent\n   * ```\n   */\n  registerTemplate(templatePath: string, contents: LoaderTemplate): this {\n    this.loader.register(templatePath, contents)\n    return this\n  }\n\n  /**\n   * Remove the template registered using the \"registerTemplate\" method\n   */\n  removeTemplate(templatePath: string): this {\n    this.loader.remove(templatePath)\n    this.compiler.cacheManager.delete(templatePath)\n    this.asyncCompiler.cacheManager.delete(templatePath)\n    return this\n  }\n\n  /**\n   * Get access to the underlying template renderer. Each render call\n   * to edge results in creating an isolated renderer instance.\n   */\n  onRender(callback: (renderer: EdgeRenderer) => void): this {\n    this.#renderCallbacks.push(callback)\n    return this\n  }\n\n  /**\n   * Returns a new instance of edge. The instance\n   * can be used to define locals.\n   */\n  createRenderer(): EdgeRenderer {\n    this.#executePlugins()\n\n    const renderer = new EdgeRenderer(\n      this.compiler,\n      this.asyncCompiler,\n      this.processor,\n      this.globals\n    )\n\n    this.#renderCallbacks.forEach((callback) => callback(renderer))\n    return renderer\n  }\n\n  /**\n   * Render a template with optional state\n   *\n   * ```ts\n   * edge.render('welcome', { greeting: 'Hello world' })\n   * ```\n   */\n  render(templatePath: string, state?: Record<string, any>): Promise<string> {\n    return this.createRenderer().render(templatePath, state)\n  }\n\n  /**\n   * Render a template asynchronously with optional state\n   *\n   * ```ts\n   * edge.render('welcome', { greeting: 'Hello world' })\n   * ```\n   */\n  renderSync(templatePath: string, state?: Record<string, any>): string {\n    return this.createRenderer().renderSync(templatePath, state)\n  }\n\n  /**\n   * Render a template with optional state\n   *\n   * ```ts\n   * edge.render('welcome', { greeting: 'Hello world' })\n   * ```\n   */\n  renderRaw(contents: string, state?: Record<string, any>, templatePath?: string): Promise<string> {\n    return this.createRenderer().renderRaw(contents, state, templatePath)\n  }\n\n  /**\n   * Render a template asynchronously with optional state\n   *\n   * ```ts\n   * edge.render('welcome', { greeting: 'Hello world' })\n   * ```\n   */\n  renderRawSync(templatePath: string, state?: Record<string, any>): string {\n    return this.createRenderer().renderRawSync(templatePath, state)\n  }\n\n  /**\n   * Share locals with the current view context.\n   *\n   * ```js\n   * const view = edge.createRenderer()\n   *\n   * // local state for the current render\n   * view.share({ foo: 'bar' })\n   *\n   * view.render('welcome')\n   * ```\n   */\n  share(data: Record<string, any>): EdgeRenderer {\n    return this.createRenderer().share(data)\n  }\n}\n","/*\n * edge.js\n *\n * (c) EdgeJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { Edge } from './src/edge/main.js'\n\nexport { Template } from './src/template.js'\nexport { edgeGlobals } from './src/edge/globals.js'\nexport { Edge }\n\nconst edge = Edge.create()\nexport default edge\n"],"mappings":"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","names":["expressions","expressions","lodash","expressions","expressions","lodash","expressions","lodash","expressions","lodash","expressions","expressions","expressions","expressions","expressions","expressions","expressions","expressions","expressions","expressions","EdgeError","lexerUtils","expressions","expressions","EdgeError","EdgeError","expressions","expressions","EdgeError","EdgeError","lexerUtils","Parser","EdgeBuffer","EdgeError","Parser","EdgeBuffer","string","string","lodash","lodash","edge"]}