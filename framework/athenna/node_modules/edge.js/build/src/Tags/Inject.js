"use strict";
/*
 * edge
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectTag = void 0;
const edge_parser_1 = require("edge-parser");
const utils_1 = require("../utils");
/**
 * The inject tag is used within the components to share values with the
 * component caller.
 */
exports.injectTag = {
    block: false,
    seekable: true,
    tagName: 'inject',
    noNewLine: true,
    compile(parser, buffer, token) {
        token.properties.jsArg = `(${token.properties.jsArg})`;
        const parsed = (0, utils_1.parseJsArg)(parser, token);
        /**
         * The inject tag only accepts an object expression.
         */
        (0, utils_1.isSubsetOf)(parsed, [edge_parser_1.expressions.ObjectExpression, edge_parser_1.expressions.Identifier], () => {
            throw (0, utils_1.unallowedExpression)(`"${token.properties.jsArg}" is not a valid key-value pair for the @inject tag`, token.filename, parser.utils.getExpressionLoc(parsed));
        });
        /**
         * Ensure $slots are defined before merging shared state
         */
        buffer.writeStatement('if (!state.$slots || !state.$slots.$context) {', token.filename, token.loc.start.line);
        buffer.writeExpression(`throw new Error('Cannot use "@inject" outside of a component scope')`, token.filename, token.loc.start.line);
        buffer.writeStatement('}', token.filename, token.loc.start.line);
        buffer.writeExpression(`Object.assign(state.$slots.$context, ${parser.utils.stringify(parsed)})`, token.filename, token.loc.start.line);
    },
};
