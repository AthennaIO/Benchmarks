import { RouteJSON, LookupStoreTree, UrlBuilderContract, LookupStoreContract } from '@ioc:Adonis/Core/Route';
import { EncryptionContract } from '@ioc:Adonis/Core/Encryption';
/**
 * A class to encapsulate finding routes
 */
declare class Routes {
    private routes;
    constructor(routes: RouteJSON[]);
    /**
     * Find a route by indentifier
     */
    find(routeIdentifier: string): RouteJSON | null;
    /**
     * Find a route by indentifier or fail
     */
    findOrFail(routeIdentifier: string): RouteJSON;
    /**
     * Find if a route exists
     */
    has(routeIdentifier: string): boolean;
}
/**
 * Url builder is responsible for building the URLs
 */
export declare class UrlBuilder implements UrlBuilderContract {
    private encryption;
    private routes;
    /**
     * Params to be used for building the URL
     */
    private routeParams;
    /**
     * A custom query string to append to the URL
     */
    private queryString;
    /**
     * A boolean to know if the route should be looked
     * up inside the route store or not
     */
    private lookupRoute;
    /**
     * A baseUrl to prefix to the endpoint
     */
    private baseUrl;
    constructor(encryption: EncryptionContract, routes: Routes);
    /**
     * Processes the pattern against the params
     */
    private processPattern;
    /**
     * Suffix the query string to the URL
     */
    private suffixQueryString;
    /**
     * Prefix a custom url to the final URI
     */
    prefixUrl(url: string): this;
    /**
     * Disable route lookup. Calling this method considers
     * the "identifier" as the route pattern
     */
    disableRouteLookup(): this;
    /**
     * Append query string to the final URI
     */
    qs(queryString?: Record<string, any>): this;
    /**
     * Define required params to resolve the route
     */
    params(params?: any[] | Record<string, any>): this;
    /**
     * Generate url for the given route identifier
     */
    make(identifier: string): string;
    /**
     * Generate url for the given route identifier
     */
    makeSigned(identifier: string, options?: {
        expiresIn?: string | number;
        purpose?: string;
    }): string;
}
/**
 * The look up store to make URLs for a given route by looking
 * it by its name, route handler or the pattern directly.
 */
export declare class LookupStore implements LookupStoreContract {
    private encryption;
    /**
     * Shape of the registered routes. Optimized for lookups
     */
    tree: LookupStoreTree;
    constructor(encryption: EncryptionContract);
    /**
     * Register a route for lookups
     */
    register(route: RouteJSON): void;
    /**
     * Returns the route builder for the root domain
     */
    builder(): UrlBuilder;
    /**
     * Returns the route builder a given domain.
     */
    builderForDomain(domainPattern: string): UrlBuilder;
    /**
     * Find a route by indentifier. Optionally one can find routes inside
     * a given domain
     */
    find(routeIdentifier: string, domainPattern?: string): RouteJSON | null;
    /**
     * Find a route by indentifier or fail. Optionally one can find routes inside
     * a given domain
     */
    findOrFail(routeIdentifier: string, domainPattern?: string): RouteJSON;
    /**
     * Find if a route for given identifier exists. Optionally one can find routes inside
     * a given domain
     */
    has(routeIdentifier: string, domainPattern?: string): boolean;
}
export {};
