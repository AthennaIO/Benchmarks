"use strict";
/**
 * @adonisjs/http-server
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpContext = void 0;
/// <reference path="../../adonis-typings/index.ts" />
const net_1 = require("net");
const util_1 = require("util");
const macroable_1 = require("macroable");
const matchit_1 = __importDefault(require("@poppinss/matchit"));
const utils_1 = require("@poppinss/utils");
const http_1 = require("http");
const Request_1 = require("../Request");
const Response_1 = require("../Response");
const helpers_1 = require("../helpers");
const LocalStorage_1 = require("./LocalStorage");
const exceptions_json_1 = require("../../exceptions.json");
/**
 * Http context is passed to all route handlers, middleware,
 * error handler and server hooks.
 */
class HttpContext extends macroable_1.Macroable {
    constructor(request, response, logger, profiler) {
        super();
        this.request = request;
        this.response = response;
        this.logger = logger;
        this.profiler = profiler;
        /**
         * Route params
         */
        this.params = {};
        /**
         * Route subdomains
         */
        this.subdomains = {};
        /*
         * Creating the circular reference. We do this, since request and response
         * are meant to be extended and at times people would want to access
         * other ctx properties like `logger`, `profiler` inside those
         * extended methods.
         */
        this.request.ctx = this;
        this.response.ctx = this;
    }
    /**
     * Find if async localstorage is enabled for HTTP requests
     * or not
     */
    static get usingAsyncLocalStorage() {
        return LocalStorage_1.usingAsyncLocalStorage;
    }
    /**
     * Get access to the HTTP context. Available only when
     * "usingAsyncLocalStorage" is true
     */
    static get() {
        if (!LocalStorage_1.usingAsyncLocalStorage) {
            return null;
        }
        return LocalStorage_1.httpContextLocalStorage.getStore() || null;
    }
    /**
     * Get the HttpContext instance or raise an exception if not
     * available
     */
    static getOrFail() {
        /**
         * Localstorage is not enabled
         */
        if (!LocalStorage_1.usingAsyncLocalStorage) {
            const error = new utils_1.Exception(exceptions_json_1.E_INVALID_ALS_ACCESS.message, exceptions_json_1.E_INVALID_ALS_ACCESS.status, exceptions_json_1.E_INVALID_ALS_ACCESS.code);
            error.help = exceptions_json_1.E_INVALID_ALS_ACCESS.help.join('\n');
            throw error;
        }
        const store = this.get();
        /**
         * Store is not accessible
         */
        if (!store) {
            const error = new utils_1.Exception(exceptions_json_1.E_INVALID_ALS_SCOPE.message, exceptions_json_1.E_INVALID_ALS_SCOPE.status, exceptions_json_1.E_INVALID_ALS_SCOPE.code);
            error.help = exceptions_json_1.E_INVALID_ALS_SCOPE.help.join('\n');
            throw error;
        }
        return store;
    }
    /**
     * Run a method that doesn't have access to HTTP context from
     * the async local storage.
     */
    static runOutsideContext(callback, ...args) {
        return LocalStorage_1.httpContextLocalStorage.exit(callback, ...args);
    }
    /**
     * A helper to see top level properties on the context object
     */
    inspect() {
        return (0, util_1.inspect)(this, false, 1, true);
    }
    /**
     * Creates a new fake context instance for a given route. The method is
     * meant to be used inside an AdonisJS application since it relies
     * directly on the IoC container.
     */
    static create(routePattern, routeParams, req, res) {
        const Router = HttpContext.app.container.resolveBinding('Adonis/Core/Route');
        const Encryption = HttpContext.app.container.resolveBinding('Adonis/Core/Encryption');
        const serverConfig = HttpContext.app.container
            .resolveBinding('Adonis/Core/Config')
            .get('app.http', {});
        req = req || new http_1.IncomingMessage(new net_1.Socket());
        res = res || new http_1.ServerResponse(req);
        /*
         * Creating the url from the router pattern and params. Only
         * when actual URL isn't defined.
         */
        req.url = req.url || (0, helpers_1.processPattern)(routePattern, routeParams);
        /*
         * Creating new request instance
         */
        const request = new Request_1.Request(req, res, Encryption, {
            allowMethodSpoofing: serverConfig.allowMethodSpoofing,
            subdomainOffset: serverConfig.subdomainOffset,
            trustProxy: serverConfig.trustProxy,
            generateRequestId: serverConfig.generateRequestId,
        });
        /*
         * Creating new response instance
         */
        const response = new Response_1.Response(req, res, Encryption, {
            etag: serverConfig.etag,
            cookie: serverConfig.cookie,
            jsonpCallbackName: serverConfig.jsonpCallbackName,
        }, Router);
        /*
         * Creating new ctx instance
         */
        const ctx = new HttpContext(request, response, this.app.logger.child({}), this.app.profiler.create('http:context'));
        /*
         * Attaching route to the ctx
         */
        ctx.route = {
            pattern: routePattern,
            middleware: [],
            handler: async () => 'handled',
            meta: {},
            params: matchit_1.default
                .parse(routePattern, {})
                .filter((token) => [1, 3].includes(token.type))
                .map((token) => token.val),
        };
        /*
         * Defining route key
         */
        ctx.routeKey = `${request.method() || 'GET'}-${ctx.route.pattern}`;
        /*
         * Attaching params to the ctx
         */
        ctx.params = routeParams;
        /**
         * Set params on the request
         */
        ctx.request.updateParams(routeParams);
        return ctx;
    }
}
exports.HttpContext = HttpContext;
/**
 * Required by macroable
 */
HttpContext.macros = {};
HttpContext.getters = {};
