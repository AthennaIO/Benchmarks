"use strict";
/*
 * @adonisjs/env
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Env = void 0;
const Schema_1 = require("../Schema");
/**
 * The ENV module enables the use of environment variables by parsing dotfiles syntax
 * and updates the `process.env` object in Node.js.
 *
 * AdonisJs automatically reads and passes the contents of `.env` file to this class.
 */
class Env {
    constructor(valuesToProcess) {
        this.valuesToProcess = valuesToProcess;
        /**
         * A boolean to know if the values have been processed or
         * not
         */
        this.hasProcessedValues = false;
        /**
         * A cache of env values
         */
        this.envCache = {};
        /**
         * The schema to be used for validating and casting environment
         * variables
         */
        this.validationSchema = {};
        /**
         * Reference to the underlying schema
         */
        this.schema = Schema_1.schema;
    }
    /**
     * Process parsed env variables. The values will be validated
     * against the validation schema
     */
    process() {
        /**
         * Avoid re-processing the same values over and over
         * again
         */
        if (this.hasProcessedValues) {
            return;
        }
        this.hasProcessedValues = true;
        /**
         * Loop over the parsed object and set the value
         * on the process.env and the local cache.
         *
         * At this stage we process the values like a regular env parser with
         * no validation taking place
         */
        this.valuesToProcess.forEach(({ values, overwriteExisting }) => {
            Object.keys(values).forEach((key) => {
                /**
                 * Use existing value when it already exists in process.env object
                 * and [this.overwriteExisting] is set to false
                 */
                const existingValue = process.env[key];
                if (existingValue && !overwriteExisting) {
                    this.envCache[key] = existingValue;
                    return;
                }
                /**
                 * Otherwise set the value on "process.env"
                 */
                this.envCache[key] = values[key];
                process.env[key] = values[key];
            });
        });
        /**
         * Release parsed values, since we don't need it anymore
         */
        this.valuesToProcess = [];
        /**
         * Perform validations by reading the environment variables
         */
        Object.keys(this.validationSchema).forEach((key) => {
            this.envCache[key] = this.validationSchema[key](key, this.get(key));
        });
    }
    /**
     * Register the validation schema
     */
    rules(schema) {
        this.validationSchema = schema;
        return {};
    }
    /**
     * Returns the environment variable value. First the cached
     * values are preferred. When missing, the value from
     * "process.env" is used
     */
    get(key, defaultValue) {
        /**
         * Return cached value
         */
        if (this.envCache[key] !== undefined) {
            return this.envCache[key];
        }
        /**
         * Get value from process.env and update the cache
         */
        const envValue = process.env[key];
        if (envValue) {
            this.envCache[key] = envValue;
            return envValue;
        }
        /**
         * Return default value when unable to lookup any other value
         */
        return defaultValue;
    }
    /**
     * Set key-value pair. The value will be validated using
     * the validation rule if exists.
     *
     * The original value is also updated on the `process.env`
     * object
     */
    set(key, value) {
        const validationFn = this.validationSchema[key];
        if (validationFn) {
            this.envCache[key] = validationFn(key, value);
        }
        else {
            this.envCache[key] = value;
        }
        process.env[key] = value;
    }
}
exports.Env = Env;
