/// <reference path="../../adonis-typings/bodyparser.d.ts" />
import { HttpContextContract } from '@ioc:Adonis/Core/HttpContext';
import { MultipartContract, PartHandler as PartHandlerType } from '@ioc:Adonis/Core/BodyParser';
import { DriveManagerContract } from '@ioc:Adonis/Core/Drive';
/**
 * Multipart class offers a low level API to interact the incoming
 * HTTP request data as a stream. This makes it super easy to
 * write files to s3 without saving them to the disk first.
 */
export declare class Multipart implements MultipartContract {
    private ctx;
    private config;
    private drive;
    /**
     * The registered handlers to handle the file uploads
     */
    private handlers;
    /**
     * Collected fields from the multipart stream
     */
    private fields;
    /**
     * Collected files from the multipart stream. Files are only collected
     * when there is an attached listener for a given file.
     */
    private files;
    /**
     * We track the finishing of `this.onFile` async handlers
     * to make sure that `process` promise resolves for all
     * handlers to finish.
     */
    private pendingHandlers;
    /**
     * The reference to underlying multiparty form
     */
    private form;
    /**
     * Total size limit of the multipart stream. If it goes beyond
     * the limit, then an exception will be raised.
     */
    private upperLimit?;
    /**
     * Total size in bytes for all the fields (not the files)
     */
    private maxFieldsSize?;
    /**
     * A track of total number of file bytes processed so far
     */
    private processedBytes;
    /**
     * The current state of the multipart form handler
     */
    state: 'idle' | 'processing' | 'error' | 'success';
    constructor(ctx: HttpContextContract, config: Partial<{
        limit: string | number;
        fieldsLimit: string | number;
        maxFields: number;
        convertEmptyStringsToNull: boolean;
    }>, drive: DriveManagerContract);
    /**
     * Returns a boolean telling whether all streams have been
     * consumed along with all handlers execution
     */
    private isClosed;
    /**
     * Removes array like expression from the part name to
     * find the handler
     */
    private getHandlerName;
    /**
     * Validates and returns an error when upper limit is defined and
     * processed bytes is over the upper limit
     */
    private validateProcessedBytes;
    /**
     * Handles a given part by invoking it's handler or
     * by resuming the part, if there is no defined
     * handler
     */
    private handlePart;
    /**
     * Record the fields inside multipart contract
     */
    private handleField;
    /**
     * Processes the user config and computes the `upperLimit` value from
     * it.
     */
    private processConfig;
    /**
     * Mark the process as finished
     */
    private finish;
    /**
     * Attach handler for a given file. To handle all files, you
     * can attach a wildcard handler.
     *
     * @example
     * ```ts
     * multipart.onFile('package', {}, async (stream) => {
     * })
     *
     * multipart.onFile('*', {}, async (stream) => {
     * })
     * ```
     */
    onFile(name: string, options: Parameters<MultipartContract['onFile']>[1], handler: PartHandlerType): this;
    /**
     * Abort request by emitting error
     */
    abort(error: any): void;
    /**
     * Process the request by going all the file and field
     * streams.
     */
    process(config?: Parameters<MultipartContract['process']>[0]): Promise<void>;
}
