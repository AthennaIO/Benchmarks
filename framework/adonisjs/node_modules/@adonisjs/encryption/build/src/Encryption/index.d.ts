/// <reference path="../../adonis-typings/encryption.d.ts" />
import { EncryptionContract, EncryptionOptions } from '@ioc:Adonis/Core/Encryption';
import { base64 as utilsBase64 } from '@poppinss/utils/build/helpers';
import { MessageVerifier } from '../MessageVerifier';
/**
 * The encryption class allows encrypting and decrypting values using `aes-256-cbc` or `aes-128-cbc`
 * algorithms. The encrypted value uses a unique iv for every encryption and this ensures semantic
 * security (read more https://en.wikipedia.org/wiki/Semantic_security).
 */
export declare class Encryption implements EncryptionContract {
    private options;
    /**
     * The key for signing and encrypting values. It is derived
     * from the user provided secret.
     */
    private cryptoKey;
    /**
     * Use `dot` as a separator for joining encrypted value, iv and the
     * hmac hash. The idea is borrowed from JWT's in which each part
     * of the payload is concatenated with a dot.
     */
    private separator;
    /**
     * Reference to the instance of message verifier for signing
     * and verifying values.
     */
    verifier: MessageVerifier;
    /**
     * Reference to base64 object for base64 encoding/decoding values
     */
    base64: typeof utilsBase64;
    /**
     * The algorithm in use
     */
    algorithm: "aes-256-cbc";
    constructor(options: EncryptionOptions);
    /**
     * Validates the app secret
     */
    private validateSecret;
    /**
     * Encrypt value with optional expiration and purpose
     */
    encrypt(value: any, expiresAt?: string | number, purpose?: string): string;
    /**
     * Decrypt value and verify it against a purpose
     */
    decrypt<T extends any>(value: string, purpose?: string): T | null;
    /**
     * Returns a new instance of encryption with custom secret key
     */
    child(options: EncryptionOptions): Encryption;
}
