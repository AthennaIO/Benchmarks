"use strict";
/*
 * @adonisjs/ace
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeneratorFile = void 0;
const path_1 = require("path");
const StringTransformer_1 = require("./StringTransformer");
const template_1 = require("../utils/template");
/**
 * Exposes the API to construct the output file content, path
 * and template source.
 */
class GeneratorFile {
    constructor(name, options = {}) {
        this.name = name;
        this.options = options;
        this.templateData = {};
        this.mustache = false;
        this.state = 'pending';
    }
    /**
     * Returns relative path for the file. Useful for
     * printing log info
     */
    getFileRelativePath(filepath) {
        if (this.customAppRoot) {
            return filepath.replace(`${this.customAppRoot}${path_1.sep}`, '');
        }
        return filepath;
    }
    /**
     * Set stub for the contents source. When `raw` is true, then string
     * is considered as the raw content and not the file path.
     */
    stub(fileOrContents, options) {
        this.stubContents = fileOrContents;
        this.isStubRaw = !!(options && options.raw);
        return this;
    }
    /**
     * Optionally define  destination directory from the project root.
     */
    destinationDir(directory) {
        this.customDestinationPath = directory;
        return this;
    }
    /**
     * Define `appRoot`. This is just to shorten the logged
     * file names. For example:
     */
    appRoot(directory) {
        this.customAppRoot = directory;
        return this;
    }
    /**
     * Instruct to use mustache
     */
    useMustache() {
        this.mustache = true;
        return this;
    }
    /**
     * Variables for stub subsitution
     */
    apply(contents) {
        this.templateData = contents;
        return this;
    }
    /**
     * Returns the file json
     */
    toJSON() {
        const extension = this.options.extname || '.ts';
        const filename = new StringTransformer_1.StringTransformer((0, path_1.basename)(this.name))
            .dropExtension()
            .cleanSuffix(this.options.suffix)
            .cleanPrefix(this.options.prefix)
            .changeForm(this.options.form, this.options.formIgnoreList)
            .addSuffix(this.options.suffix)
            .addPrefix(this.options.prefix)
            .changeCase(this.options.pattern)
            .toValue();
        const initialFilePath = this.name.replace((0, path_1.basename)(this.name), filename);
        const appRoot = this.customAppRoot || process.cwd();
        /**
         * Computes the file absolute path, where the file will be created.
         *
         * 1. If `customDestinationPath` is not defined, we will merge the
         *    `appRoot` + `initialFilePath`.
         *
         * 2. If `customDestinationPath` is absolute, then we ignore the appRoot
         *    and merge `customDestinationPath` + `initialFilePath`
         *
         * 3. Otherwise we merge `appRoot` + `customDestinationPath` + `initialFilePath`.
         */
        const filepath = this.customDestinationPath
            ? (0, path_1.isAbsolute)(this.customDestinationPath)
                ? (0, path_1.join)(this.customDestinationPath, initialFilePath)
                : (0, path_1.join)(appRoot, this.customDestinationPath, initialFilePath)
            : (0, path_1.join)(appRoot, initialFilePath);
        /**
         * Passing user values + the filename and extension
         */
        const templateContents = Object.assign({ extension, filename }, this.templateData);
        /**
         * Contents of the template file
         */
        const contents = this.stubContents
            ? this.isStubRaw
                ? (0, template_1.template)(this.stubContents, templateContents, undefined, this.mustache)
                : (0, template_1.templateFromFile)(this.stubContents, templateContents, this.mustache)
            : '';
        return {
            filename,
            filepath: `${filepath}${extension}`,
            relativepath: this.getFileRelativePath(`${filepath}${extension}`),
            extension,
            contents,
            state: this.state,
        };
    }
}
exports.GeneratorFile = GeneratorFile;
