/// <reference path="../../adonis-typings/index.d.ts" />
/// <reference path="../../adonis-typings/drive.d.ts" />
/// <reference path="../../test-helpers/drive.d.ts" />
/// <reference types="@adonisjs/logger/build/adonis-typings/logger" />
/// <reference types="node" />
/// <reference types="node" />
import { Manager } from '@poppinss/manager';
import { RouterContract } from '@ioc:Adonis/Core/Route';
import { LoggerContract } from '@ioc:Adonis/Core/Logger';
import { ApplicationContract } from '@ioc:Adonis/Core/Application';
import { DisksList, Visibility, DriveConfig, DriverContract, DriveFileStats, LocalDriverConfig, DriveManagerContract, FakeImplementationCallback, DirectoryListingContract, DriveListItem } from '@ioc:Adonis/Core/Drive';
import { FakeDrive } from '../Fake';
/**
 * Drive manager exposes the API to resolve disks and extend by
 * adding custom drivers
 */
export declare class DriveManager extends Manager<ApplicationContract, DriverContract, DriverContract, {
    [P in keyof DisksList]: DisksList[P]['implementation'];
}> implements DriveManagerContract {
    application: ApplicationContract;
    router: RouterContract;
    private logger;
    private config;
    /**
     * Find if drive is ready to be used
     */
    private isReady;
    /**
     * The fake callback
     */
    private fakeCallback;
    /**
     * Reference to the fake drive
     */
    private fakeDrive;
    /**
     * Cache all disks instances
     */
    protected singleton: boolean;
    /**
     * Reference to registered fakes
     */
    fakes: Map<"local", import("@ioc:Adonis/Core/Drive").FakeDriverContract>;
    constructor(application: ApplicationContract, router: RouterContract, logger: LoggerContract, config: DriveConfig);
    /**
     * Validate config
     */
    private validateConfig;
    /**
     * Returns the default mapping name
     */
    protected getDefaultMappingName(): "local";
    /**
     * Returns config for a given mapping
     */
    protected getMappingConfig(diskName: keyof DisksList): LocalDriverConfig;
    /**
     * Returns the name of the drive used by a given mapping
     */
    protected getMappingDriver(diskName: keyof DisksList): string | undefined;
    /**
     * Make instance of the local driver
     */
    protected createLocal(diskName: keyof DisksList, config: LocalDriverConfig): any;
    /**
     * Fake default or a named disk
     */
    fake(disks?: keyof DisksList | keyof DisksList[]): FakeDrive;
    /**
     * Restore the fake for the default or a named disk
     */
    restore(disks?: keyof DisksList | keyof DisksList[]): void;
    /**
     * Restore all fakes1
     */
    restoreAll(): void;
    /**
     * Resolve instance for a disk
     */
    use(disk?: keyof DisksList): any;
    /**
     * Register a custom fake implementation
     */
    setFakeImplementation(callback: FakeImplementationCallback): void;
    /**
     * Returns the file contents as a buffer. The buffer return
     * value allows you to self choose the encoding when
     * converting the buffer to a string.
     */
    get(location: string, ...args: any[]): Promise<Buffer>;
    /**
     * Returns the file contents as a stream
     */
    getStream(location: string, ...args: any[]): Promise<NodeJS.ReadableStream>;
    /**
     * A boolean to find if the location path exists or not
     */
    exists(location: string, ...args: any[]): Promise<boolean>;
    /**
     * Returns the location path visibility
     */
    getVisibility(location: string, ...args: any[]): Promise<Visibility>;
    /**
     * Returns the location path stats
     */
    getStats(location: string, ...args: any[]): Promise<DriveFileStats>;
    /**
     * Returns a signed URL for a given location path
     */
    getSignedUrl(location: string, ...args: any[]): Promise<string>;
    /**
     * Returns a URL for a given location path
     */
    getUrl(location: string, ...args: any[]): Promise<string>;
    /**
     * Write string|buffer contents to a destination. The missing
     * intermediate directories will be created (if required).
     */
    put(location: string, ...args: any[]): Promise<void>;
    /**
     * Write a stream to a destination. The missing intermediate
     * directories will be created (if required).
     */
    putStream(location: string, ...args: any[]): Promise<void>;
    /**
     * Not supported
     */
    setVisibility(location: string, ...args: any[]): Promise<void>;
    /**
     * Remove a given location path
     */
    delete(location: string, ...args: any[]): Promise<void>;
    /**
     * Copy a given location path from the source to the desination.
     * The missing intermediate directories will be created (if required)
     */
    copy(source: string, ...args: any[]): Promise<void>;
    /**
     * Move a given location path from the source to the desination.
     * The missing intermediate directories will be created (if required)
     */
    move(source: string, ...args: any[]): Promise<void>;
    /**
     * Return a listing directory iterator for given location.
     */
    list(location: string): DirectoryListingContract<DriverContract, DriveListItem>;
}
