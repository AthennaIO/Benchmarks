/// <reference path="../../adonis-typings/index.d.ts" />
import { DirectoryListingContract, DriveListItem, DriverContract } from '@ioc:Adonis/Core/Drive';
/**
 * Directory listing exposes the API to list directory contents using async iterators
 * and also adds some helper functions for transforming the output of driver list.
 */
export declare class DirectoryListing<Driver extends DriverContract, T extends DriveListItem> implements DirectoryListingContract<Driver, T> {
    driver: Driver;
    private listing;
    /**
     * Functions chain to be executed for transforming generated listing iterable
     */
    private chain;
    constructor(driver: Driver, listing: (this: Driver) => AsyncGenerator<T>);
    /**
     * Filter generated items of listing with the given predicate function.
     */
    filter(predicate: (item: T, index: number, driver: Driver) => Promise<boolean> | boolean): DirectoryListingContract<Driver, T>;
    /**
     * Transform generated items of listing with the given mapper function.
     */
    map<M>(mapper: (item: T, index: number, driver: Driver) => M | Promise<M>): DirectoryListingContract<Driver, Awaited<M>>;
    /**
     * Do recursive listing of items. Without the next function it will do listing of leaf nodes only.
     * For advanced usage you can pass the next function which will get as parameter current item and it should
     * return the next location for list or null if the recursion should stop and yield the current item.
     * For advanced usage you can also limit the depth of recursion using the second argument of next function.
     */
    recursive(next?: (current: T, depth: number, driver: Driver) => Promise<string | null> | string | null): DirectoryListingContract<Driver, any>;
    /**
     * Add a piping chain function which gets the current async iterable and returns
     * new async iterable with modified directory listing output.
     * Function this is bound to instance of driver for which the listing is generated.
     * This allows using async generator functions and reference the driver methods easily.
     * Piping will always return clone of the current instance and add the function
     * to the chain of new cloned instance only to prevent side effects.
     */
    pipe<U>(fn: (this: Driver, iterable: AsyncIterable<T>) => AsyncIterable<U>): DirectoryListingContract<Driver, U>;
    /**
     * Get the final async iterable after passing directory listing through chain of piping functions modifying the output.
     */
    toIterable(): AsyncIterable<T>;
    /**
     * Convert directory listing to array.
     */
    toArray(): Promise<T[]>;
    /**
     * A method that returns the default async iterator for an object.
     */
    [Symbol.asyncIterator](): AsyncIterableIterator<T>;
}
