/// <reference path="../../adonis-typings/index.d.ts" />
/// <reference types="node" />
/// <reference types="node" />
import { RouterContract } from '@ioc:Adonis/Core/Route';
import { DisksList, Visibility, ContentHeaders, DriveFileStats, FakeDriverContract, DirectoryListingContract, FakeDriveListItem } from '@ioc:Adonis/Core/Drive';
/**
 * Memory driver is mainly used for testing
 */
export declare class FakeDriver implements FakeDriverContract {
    disk: keyof DisksList;
    private config;
    private router;
    /**
     * Reference to the underlying adapter. Which is memfs
     */
    adapter: import("memfs/lib/volume").Volume;
    /**
     * Name of the driver
     */
    name: 'fake';
    /**
     * Path prefixer used for prefixing paths with disk root
     * It doesn't play any role but we will try to construct same path as faked driver is using
     * We use the root path if it is available for driver and also add prefix if provided
     */
    private prefixer;
    /**
     * Rely on the config for visibility or fallback to private
     */
    private visibility;
    constructor(disk: keyof DisksList, config: any, router: RouterContract);
    /**
     * Make absolute path to a given location
     */
    makePath(location: string): string;
    /**
     * Creates the directory recursively with in the memory
     */
    private ensureDir;
    /**
     * Returns the file contents as a buffer. The buffer return
     * value allows you to self choose the encoding when
     * converting the buffer to a string.
     */
    get(location: string): Promise<Buffer>;
    /**
     * Returns the file contents as a stream
     */
    getStream(location: string): Promise<NodeJS.ReadableStream>;
    /**
     * A boolean to find if the location path exists or not
     */
    exists(location: string): Promise<boolean>;
    /**
     * Not supported
     */
    getVisibility(): Promise<Visibility>;
    /**
     * Returns the file stats
     */
    getStats(location: string): Promise<DriveFileStats>;
    /**
     * Returns a signed URL for a given location path
     */
    getSignedUrl(location: string, options?: ContentHeaders & {
        expiresIn?: string | number;
    }): Promise<string>;
    /**
     * Returns a URL for a given location path
     */
    getUrl(location: string): Promise<string>;
    /**
     * Write string|buffer contents to a destination. The missing
     * intermediate directories will be created (if required).
     */
    put(location: string, contents: Buffer | string): Promise<void>;
    /**
     * Write a stream to a destination. The missing intermediate
     * directories will be created (if required).
     */
    putStream(location: string, contents: NodeJS.ReadableStream): Promise<void>;
    /**
     * Not supported
     */
    setVisibility(): Promise<void>;
    /**
     * Remove a given location path
     */
    delete(location: string): Promise<void>;
    /**
     * Copy a given location path from the source to the desination.
     * The missing intermediate directories will be created (if required)
     */
    copy(source: string, destination: string): Promise<void>;
    /**
     * Move a given location path from the source to the desination.
     * The missing intermediate directories will be created (if required)
     */
    move(source: string, destination: string): Promise<void>;
    /**
     * Return a listing directory iterator for given location.
     */
    list(location: string): DirectoryListingContract<this, FakeDriveListItem>;
}
