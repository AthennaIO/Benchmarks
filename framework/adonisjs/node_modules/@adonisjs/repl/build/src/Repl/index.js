"use strict";
/*
 * @adonisjs/repl
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Repl = void 0;
const vm_1 = require("vm");
const string_width_1 = __importDefault(require("string-width"));
const colors_1 = require("@poppinss/colors");
const repl_1 = require("repl");
const util_1 = require("util");
const Compiler_1 = require("../Compiler");
/**
 * List of node global properties to remove from the
 * ls inspect
 */
const GLOBAL_NODE_PROPERTIES = [
    'performance',
    'global',
    'clearInterval',
    'clearTimeout',
    'setInterval',
    'setTimeout',
    'queueMicrotask',
    'clearImmediate',
    'setImmediate',
    'exports',
    '__importDefault',
];
/**
 * Properties injected by the ts-utils
 * library
 */
const TS_UTIL_HELPERS = [
    '__extends',
    '__assign',
    '__rest',
    '__decorate',
    '__param',
    '__metadata',
    '__awaiter',
    '__generator',
    '__exportStar',
    '__values',
    '__read',
    '__spread',
    '__spreadArrays',
    '__spreadArray',
    '__await',
    '__asyncGenerator',
    '__asyncDelegator',
    '__asyncValues',
    '__makeTemplateObject',
    '__importStar',
    '__importDefault',
    '__classPrivateFieldGet',
    '__classPrivateFieldSet',
    '__createBinding',
];
const icons = process.platform === 'win32' && !process.env.WT_SESSION
    ? {
        tick: '√',
        pointer: '>',
    }
    : {
        tick: '✔',
        pointer: '❯',
    };
/**
 * Exposes the API to work the REPL server
 */
class Repl {
    constructor(tsCompiler, historyFilePath) {
        this.tsCompiler = tsCompiler;
        this.historyFilePath = historyFilePath;
        /**
         * Compiler to compile REPL input
         */
        this.compiler = new Compiler_1.Compiler(this.tsCompiler);
        /**
         * Length of the longest custom method name. We need to show a
         * symmetric view of custom methods and their description
         */
        this.longestCustomMethodName = 0;
        /**
         * Set of registered ready callbacks
         */
        this.onReadyCallbacks = [];
        /**
         * A set of registered custom methods
         */
        this.customMethods = {};
        /**
         * Reference to the colors to print colorful messages
         */
        this.colors = (0, colors_1.getBest)(false);
    }
    /**
     * Find if the error is recoverable or not
     */
    isRecoverableError(error) {
        if (error.name === 'SyntaxError') {
            return /^(Unexpected end of input|Unexpected token)/.test(error.message);
        }
        return false;
    }
    /**
     * Custom eval method to execute the user code
     */
    async eval(cmd, _, filename, callback) {
        try {
            let response;
            const { compiled, awaitPromise } = await this.compiler.compile(cmd, filename);
            if (awaitPromise) {
                response = await new vm_1.Script(compiled, { filename }).runInThisContext();
            }
            else {
                response = new vm_1.Script(compiled, { filename }).runInThisContext();
            }
            callback(null, response);
        }
        catch (error) {
            if (this.isRecoverableError(error)) {
                callback(new repl_1.Recoverable(error), null);
                return;
            }
            callback(error, null);
        }
    }
    registerCustomMethodWithContext(name) {
        const customMethod = this.customMethods[name];
        if (!customMethod) {
            return;
        }
        /**
         * Wrap handler
         */
        const handler = (...args) => customMethod.handler(this, ...args);
        /**
         * Re-define the function name to be more description
         */
        Object.defineProperty(handler, 'name', { value: customMethod.handler.name });
        /**
         * Register with the context
         */
        this.server.context[name] = handler;
    }
    /**
     * Register custom methods with the server context
     */
    registerCustomMethodsWithContext() {
        Object.keys(this.customMethods).forEach((name) => {
            this.registerCustomMethodWithContext(name);
        });
    }
    /**
     * Setup context with default globals
     */
    setupContext() {
        /**
         * Register "clear" method
         */
        this.addMethod('clear', function clear(repl, key) {
            if (!key) {
                console.log(repl.colors.red('Define a property name to remove from the context'));
            }
            else {
                delete repl.server.context[key];
            }
            repl.server.displayPrompt();
        }, {
            description: 'Clear a property from the REPL context',
            usage: `clear ${this.colors.gray('(propertyName)')}`,
        });
        /**
         * Register "p" method
         */
        this.addMethod('p', function promisify(_, fn) {
            return (0, util_1.promisify)(fn);
        }, {
            description: 'Promisify a function. Similar to Node.js "util.promisify"',
            usage: `p ${this.colors.gray('(function)')}`,
        });
        /**
         * Register all custom methods with the context
         */
        this.registerCustomMethodsWithContext();
    }
    /**
     * Setup history file
     */
    setupHistory() {
        if (!this.historyFilePath) {
            return;
        }
        this.server.setupHistory(this.historyFilePath, (error) => {
            if (!error) {
                return;
            }
            console.log(this.colors.red('Unable to write to the history file. Exiting'));
            console.error(error);
            process.exit(1);
        });
    }
    /**
     * Prints the welcome message
     */
    printWelcomeMessage() {
        console.log('');
        /**
         * Log about typescript support
         */
        if (this.compiler.compilesTs) {
            console.log(`${this.colors.dim(icons.tick)} ${this.colors.dim('typescript compilation supported')}`);
        }
        /**
         * Log about top level imports
         */
        console.log(`${this.colors.dim(icons.tick)} ${this.colors.dim('allows top level imports')}`);
        console.log('');
        /**
         * Log about help command
         */
        this.notify('Type ".ls" to a view list of available context methods/properties');
    }
    /**
     * Prints the help for the custom methods
     */
    printCustomMethodsHelp() {
        /**
         * Print loader methods
         */
        console.log('');
        console.log(this.colors.green('GLOBAL METHODS:'));
        Object.keys(this.customMethods).forEach((method) => {
            const { options } = this.customMethods[method];
            const spaces = new Array(this.longestCustomMethodName - options.width + 2).join(' ');
            console.log(`${this.colors.yellow(options.usage || method)}${spaces}${this.colors.dim(options.description || '')}`);
        });
    }
    /**
     * Prints the help for the context properties
     */
    printContextHelp() {
        /**
         * Print context properties
         */
        console.log('');
        console.log(this.colors.green('CONTEXT PROPERTIES/METHODS:'));
        const context = Object.keys(this.server?.context).reduce((result, key) => {
            if (!this.customMethods[key] &&
                !GLOBAL_NODE_PROPERTIES.includes(key) &&
                !TS_UTIL_HELPERS.includes(key)) {
                result[key] = this.server?.context[key];
            }
            return result;
        }, {});
        console.log((0, util_1.inspect)(context, false, 1, true));
    }
    /**
     * Prints the context to the console
     */
    ls() {
        this.printCustomMethodsHelp();
        this.printContextHelp();
        this.server.displayPrompt();
    }
    /**
     * Notify by writing to the console
     */
    notify(message) {
        console.log(this.colors.yellow().italic(message));
        if (this.server) {
            this.server.displayPrompt();
        }
    }
    /**
     * Start the REPL session
     */
    start() {
        this.printWelcomeMessage();
        this.server = (0, repl_1.start)({
            prompt: '> ',
            input: process.stdin,
            output: process.stdout,
            terminal: process.stdout.isTTY && !parseInt(process.env.NODE_NO_READLINE, 10),
            useGlobal: true,
        });
        /**
         * Define ls command
         */
        this.server.defineCommand('ls', {
            help: 'View a list of available context methods/properties',
            action: this.ls.bind(this),
        });
        /**
         * Setup context
         */
        this.setupContext();
        /**
         * Setup history
         */
        this.setupHistory();
        /**
         * Assigning eval function like this has better completion support.
         */
        // @ts-ignore
        this.server['eval'] = this.eval.bind(this);
        /**
         * Define exports variable when using Typescript
         */
        if (this.compiler.compilesTs) {
            new vm_1.Script('exports = module.exports', { filename: __dirname }).runInThisContext();
        }
        /**
         * Display prompt
         */
        this.server.displayPrompt();
        /**
         * Execute onready callbacks
         */
        this.onReadyCallbacks.forEach((callback) => callback(this));
        return this;
    }
    /**
     * Register a callback to be invoked once the server is ready
     */
    ready(callback) {
        this.onReadyCallbacks.push(callback);
        return this;
    }
    /**
     * Register a custom loader function to be added to the context
     */
    addMethod(name, handler, options) {
        const width = (0, string_width_1.default)(options?.usage || name);
        if (width > this.longestCustomMethodName) {
            this.longestCustomMethodName = width;
        }
        this.customMethods[name] = { handler, options: Object.assign({ width }, options) };
        /**
         * Register method right away when server has been started
         */
        if (this.server) {
            this.registerCustomMethodWithContext(name);
        }
        return this;
    }
}
exports.Repl = Repl;
