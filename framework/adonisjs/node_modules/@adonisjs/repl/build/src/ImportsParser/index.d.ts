/**
 * This is a crazy attempt to hack around the Typescript behavior around un-used
 * imports. Writing half baked parsers is something I want to avoid everytime.
 * However, there isn't any other way (atleast I don't know about it).
 *
 * In REPL, you usually write one line of code at a time. For example:
 * - You write 2 + 2 and then press enter. The REPL prints 4
 * - You write `await Database.query().first()` and it prints the query result.
 *
 * However, when you write `import User from 'App/Models/User'` and expect to
 * access User variable then you are out of luck.
 *
 * - The import statement will go to the typescript compiler
 * - It will compile the code and sees that no one is using this import.
 *   And hence it will just remove it from the compiled output.
 *
 * Bang! No import/require exists and hence no `User` variable exists.
 *
 * To hack around it, we need to monitor and parse import statements and hold
 * a reference to them so that the compiler doesn't remove. For example:
 *
 * Converting
 * ```ts
 * 	import User from 'App/Models/User'
 * ```
 *
 * To
 * ```ts
 * 	import repl_User from 'App/Models/User'; var User = repl_User
 * ```
 *
 * Now you can access the `User` variable.
 *
 * The tough part is attempting to parse all styles in which an import
 * statement can be written. Lucikly, there are 4 different ways to
 * do that as per the spec http://www.ecma-international.org/ecma-262/6.0/#table-40
 *
 * 		import v from "mod";									(Import default)
 * 		import * as ns from "mod";						(Import alias)
 * 		import {x} from "mod";								(Import named)
 * 		import {x as v} from "mod";						(Import named + aliases)
 *
 * However, we have to be tolerant to the white spaces.
 */
export declare class ImportsParser {
    private parseImport;
    /**
     * Parse a given line of code
     */
    parse(line: string): Promise<string>;
}
