{"version":3,"sources":["../src/stripSlashes.ts"],"names":["deprecated","getSingleCharEscapes","stripSlashes","str","countOrOptions","options","count","defaultEscapeValue","b","f","n","r","t","v","nul","x","u","uEs6","singleCharEscapes","delete","patterns","push","rx","RegExp","join","i","Math","max","replace","g1","suffix","length","String","fromCharCode","Number","parseInt","slice","codePointStr","codePoint","s1","s2","get","strip"],"mappings":"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","sourcesContent":["import { deprecated } from './deprecated';\nimport { getSingleCharEscapes } from './escapes';\n\nexport interface IStripSlashesOptions {\n  /**\n   * Number of times to strip slashes. Equivalent to invoking the function\n   * `count` times. Defaults to 1.\n   */\n  readonly count?: number;\n  /**\n   * The default value for all escape options (b, f, n, r, t, v, 0, x, u, and\n   * uEs6). When true, escape options must be explicitly disabled. When false,\n   * escape options must be explicitly enabled. Defaults to true.\n   */\n  readonly defaultEscapeValue?: boolean;\n  /**\n   * Unescape `\"\\\\b\"` to a backspace character.\n   */\n  readonly b?: boolean;\n  /**\n   * Unescape `\"\\\\f\"` to a form feed character.\n   */\n  readonly f?: boolean;\n  /**\n   * Unescape `\"\\\\n\"` to a newline (line feed) character.\n   */\n  readonly n?: boolean;\n  /**\n   * Unescape `\"\\\\r\"` to a carriage return character.\n   */\n  readonly r?: boolean;\n  /**\n   * Unescape `\"\\\\t\"` to a tag character.\n   */\n  readonly t?: boolean;\n  /**\n   * Unescape `\"\\\\v\"` to a vertical tab character.\n   */\n  readonly v?: boolean;\n  /**\n   * Unescape `\"\\\\0\"` to a null character.\n   */\n  readonly '0'?: boolean;\n  /**\n   * Unescape hex escape sequences (e.g. `\"\\\\xa9\"`).\n   */\n  readonly x?: boolean;\n  /**\n   * Unescape basic unicode escape sequences (e.g. `\"\\\\u2020\"`).\n   */\n  readonly u?: boolean;\n  /**\n   * Unescape ES6 unicode code point escape sequences (e.g. `\"\\\\u{1F60a}\"`).\n   */\n  readonly uEs6?: boolean;\n}\n\n/**\n * Remove one layer of slashes. All escape sequences will be transformed into\n * the character indicated by the sequence (e.g. `\"\\\\n\"` will become a\n * newline).\n *\n * @param str String to remove slashes from.\n * @param options Options for which escape sequences to recognize. Defaults to\n * recognizing all single character, hex, and unicode escape sequences\n */\nexport function stripSlashes(str: string, options?: IStripSlashesOptions): string;\n/**\n * Remove one layer of slashes. All escape sequences will be transformed into\n * the character indicated by the sequence (e.g. `\"\\\\n\"` will become a\n * newline).\n *\n * @param str String to remove slashes from.\n * @param count Number of times to strip slashes. Equivalent to invoking the\n * function `count` times. Defaults to 1.\n */\nexport function stripSlashes(str: string, count?: number): string;\nexport function stripSlashes(str: string, countOrOptions?: number | IStripSlashesOptions): string {\n  let options: IStripSlashesOptions;\n\n  if (typeof countOrOptions === 'number') {\n    options = { count: countOrOptions };\n  } else if (countOrOptions && typeof countOrOptions === 'object') {\n    options = countOrOptions;\n  } else {\n    options = {};\n  }\n\n  const {\n    count = 1,\n    defaultEscapeValue = true,\n    b = defaultEscapeValue,\n    f = defaultEscapeValue,\n    n = defaultEscapeValue,\n    r = defaultEscapeValue,\n    t = defaultEscapeValue,\n    v = defaultEscapeValue,\n    '0': nul = defaultEscapeValue,\n    x = defaultEscapeValue,\n    u = defaultEscapeValue,\n    uEs6 = u\n  } = options;\n\n  const singleCharEscapes = getSingleCharEscapes();\n\n  if (!b) singleCharEscapes.delete('b');\n  if (!f) singleCharEscapes.delete('f');\n  if (!n) singleCharEscapes.delete('n');\n  if (!r) singleCharEscapes.delete('r');\n  if (!t) singleCharEscapes.delete('t');\n  if (!v) singleCharEscapes.delete('v');\n  if (!nul) singleCharEscapes.delete('0');\n\n  const patterns: string[] = [];\n\n  if (x) patterns.push('x[a-fA-F0-9]{2}');\n  if (u) patterns.push('u[a-fA-F0-9]{4}');\n  if (uEs6) patterns.push('u{[a-fA-F0-9]+}');\n\n  const rx = new RegExp(`\\\\\\\\(${[...patterns, '.', '$'].join('|')})`, 'g');\n\n  for (let i = Math.max(1, count >> 0); i > 0; --i) {\n    str = str.replace(rx, (...[, g1]) => {\n      const suffix = g1 as string;\n\n      if (suffix.length > 1) {\n        if (suffix[0] === 'x') {\n          return String.fromCharCode(Number.parseInt(suffix.slice(1), 16));\n        } else if (suffix[0] === 'u') {\n          if (suffix[1] === '{') {\n            const codePointStr = suffix.slice(2, -1);\n            const codePoint = Number.parseInt(codePointStr, 16);\n\n            if (codePoint > 0x10ffff) {\n              // Not valid unicode, so just remove the slash, leaving the\n              // trailing characters in place.\n              return suffix;\n            } else if (codePoint >= 0x10000) {\n              const u = codePoint - 0x10000;\n              const s1 = 0xd800 + (u >> 10);\n              const s2 = 0xdc00 + (u & 0x3ff);\n\n              return `${String.fromCharCode(s1, s2)}`;\n            }\n\n            return String.fromCharCode(codePoint);\n          }\n\n          return String.fromCharCode(Number.parseInt(suffix.slice(1), 16));\n        }\n      }\n\n      return singleCharEscapes.get(suffix) || suffix;\n    });\n  }\n\n  return str;\n}\n\n/**\n * @deprecated Use `stripSlashes()` instead.\n *\n * Maintains legacy behavior of _only_ recognizing newline (`\"\\n\"`) and null\n * escape sequences (`\"\\0\"`). Other slashes will not consume any trailing\n * characters (e.g. `\"\\\\r\"` becomes `\"r\"`, _not a carriage return_).\n */\nexport const strip = (str: string, count?: number): string => {\n  deprecated('The strip() function is deprecated and should be replaced with stripSlashes().');\n  return stripSlashes(str, { count, defaultEscapeValue: false, n: true, '0': true });\n};\n"],"file":"stripSlashes.js"}