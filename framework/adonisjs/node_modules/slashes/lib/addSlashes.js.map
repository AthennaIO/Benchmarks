{"version":3,"sources":["../src/addSlashes.ts"],"names":["deprecated","CHAR_TO_ESCAPE","addSlashes","str","countOrCharactersOrOptions","characters","count","escapeNonAscii","rx","RegExp","replace","i","Math","max","char","escape","get","charCode","charCodeAt","hex","toString","length","add"],"mappings":"AAAA,SAASA,UAAT,QAA2B,cAA3B;AACA,SAASC,cAAT,QAA+B,WAA/B;AAsEA,OAAO,SAASC,UAAT,CACLC,GADK,EAELC,0BAFK,EAGLC,UAAU,GAAI,oBAHT,EAIG;AACR,MAAIC,KAAK,GAAG,CAAZ;AACA,MAAIC,cAAc,GAAG,KAArB;;AAEA,MAAI,OAAOH,0BAAP,KAAsC,QAA1C,EAAoD;AAClDE,IAAAA,KAAK,GAAGF,0BAAR;AACD,GAFD,MAEO,IAAIA,0BAAJ,EAAgC;AACrC,QAAI,OAAOA,0BAAP,KAAsC,QAA1C,EAAoD;AAClD,OAAC;AAAEE,QAAAA,KAAK,GAAGA,KAAV;AAAiBD,QAAAA,UAAU,GAAGA,UAA9B;AAA0CE,QAAAA,cAAc,GAAGA;AAA3D,UAA8EH,0BAA/E;AACD,KAFD,MAEO;AACLC,MAAAA,UAAU,GAAGD,0BAAb;AACD;AACF;;AAED,QAAMI,EAAE,GAAG,IAAIC,MAAJ,CAAY,IAAGJ,UAAU,CAACK,OAAX,CAAmB,UAAnB,EAA+B,MAA/B,CAAuC,GAAtD,EAA0D,GAA1D,CAAX;;AAEA,OAAK,IAAIC,CAAC,GAAGC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYP,KAAK,IAAI,CAArB,CAAb,EAAsCK,CAAC,GAAG,CAA1C,EAA6C,EAAEA,CAA/C,EAAkD;AAChDR,IAAAA,GAAG,GAAGA,GAAG,CAACO,OAAJ,CAAYF,EAAZ,EAAgBM,IAAI,IAAI;AAC5B,YAAMC,MAAM,GAAGd,cAAc,CAACe,GAAf,CAAmBF,IAAnB,CAAf;;AAEA,UAAIC,MAAJ,EAAY;AACV,eAAOA,MAAP;AACD;;AAED,YAAME,QAAQ,GAAGH,IAAI,CAACI,UAAL,CAAgB,CAAhB,CAAjB;;AAEA,UAAID,QAAQ,IAAI,MAAZ,IAAsBA,QAAQ,IAAI,MAAtC,EAA8C;AAC5C,cAAME,GAAG,GAAGF,QAAQ,CAACG,QAAT,CAAkB,EAAlB,CAAZ;AACA,eAAQ,MAAKD,GAAI,EAAjB;AACD,OAHD,MAGO,IAAIZ,cAAc,IAAIU,QAAQ,GAAG,IAAjC,EAAuC;AAC5C,YAAIE,GAAG,GAAGF,QAAQ,CAACG,QAAT,CAAkB,EAAlB,CAAV;;AAEA,YAAIH,QAAQ,IAAI,IAAhB,EAAsB;AACpB,iBAAQ,MAAKE,GAAI,EAAjB;AACD,SAFD,MAEO;AACL,iBAAOA,GAAG,CAACE,MAAJ,GAAa,CAApB,EAAuBF,GAAG,GAAI,IAAGA,GAAI,EAAd;;AACvB,iBAAQ,MAAKA,GAAI,EAAjB;AACD;AACF;;AAED,aAAQ,KAAIL,IAAK,EAAjB;AACD,KAxBK,CAAN;AAyBD;;AAED,SAAOX,GAAP;AACD;AAED;;;;;;;;AAOA,OAAO,MAAMmB,GAAG,GAAG,CAACnB,GAAD,EAAcG,KAAd,KAAyC;AAC1DN,EAAAA,UAAU,CAAC,4EAAD,CAAV;AACA,SAAOE,UAAU,CAACC,GAAD,EAAMG,KAAN,EAAc,UAAd,CAAjB;AACD,CAHM","sourcesContent":["import { deprecated } from './deprecated';\nimport { CHAR_TO_ESCAPE } from './escapes';\n\nexport interface IAddSlashesOptions {\n  /**\n   * Number of times to add slashes. Equivalent to invoking the function\n   * `count` times. Defaults to 1.\n   */\n  count?: number;\n\n  /**\n   * Characters to escape. Defaults to all single character escape sequence\n   * characters (i.e. `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\v`, `\\0`, `\\'`, `\\\"`,\n   * and `\\\\`).\n   */\n  characters?: string;\n\n  /**\n   * Use escape sequences (e.g. `\"\\xa9\"` or `\"\\u2020\"`) for non-ascii\n   * characters (i.e. unicode code point 0x0080 and greater). Defaults to\n   * false.\n   *\n   * _NOTE: Escaped code points over 2 bytes (Unicode supplementary planes),\n   * are **always** encoded using two escape sequences as a surrogate pair\n   * (e.g. `\"\\\\ud83d\\\\ude0a\"`), so that the output doesn't contain invalid\n   * UTF-16 characters._\n   */\n  escapeNonAscii?: boolean;\n}\n\n/**\n * Escape all single character escapable sequences (i.e. `\\b`, `\\f`, `\\n`,\n * `\\r`, `\\t`, `\\v`, `\\0`, `\\'`, `\\\"`, and `\\\\`).\n *\n * @param str String in which to escape characters.\n * @param options Options for which characters to add slashes to, how many\n * slashes to add, and whether to use escape sequences for non-ascii\n * characters.\n */\nexport function addSlashes(str: string, options?: IAddSlashesOptions): string;\n/**\n * Escape all single character escapable sequences (i.e. `\\b`, `\\f`, `\\n`,\n * `\\r`, `\\t`, `\\v`, `\\0`, `\\'`, `\\\"`, and `\\\\`).\n *\n * _NOTE: Escaped code points over 2 bytes (Unicode supplementary planes),\n * are **always** encoded using two escape sequences as a surrogate pair\n * (e.g. `\"\\\\ud83d\\\\ude0a\"`), so that the output doesn't contain invalid\n * UTF-16 characters._\n *\n * @param str String in which to escape characters.\n * @param characters Characters to escape. Defaults to all single character\n * escape sequence characters (i.e. `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\v`, `\\0`,\n * `\\'`, `\\\"`, and `\\\\`).\n */\nexport function addSlashes(str: string, characters?: string): string;\n/**\n * Escape specific characters.\n *\n * _NOTE: Escaped code points over 2 bytes (Unicode supplementary planes),\n * are **always** encoded using two escape sequences as a surrogate pair\n * (e.g. `\"\\\\ud83d\\\\ude0a\"`), so that the output doesn't contain invalid\n * UTF-16 characters._\n *\n * @param str String to add slashes to.\n * @param count Number of times to add slashes. Equivalent to invoking the\n * function `count` times. Defaults to 1.\n * @param characters Characters to escape. Defaults to all single character\n * escape sequence characters (i.e. `\\b`, `\\f`, `\\n`, `\\r`, `\\t`, `\\v`, `\\0`,\n * `\\'`, `\\\"`, and `\\\\`).\n */\nexport function addSlashes(str: string, count?: number, characters?: string): string;\nexport function addSlashes(\n  str: string,\n  countOrCharactersOrOptions?: number | string | IAddSlashesOptions,\n  characters = `\\b\\f\\n\\r\\t\\v\\0'\"\\\\`\n): string {\n  let count = 1;\n  let escapeNonAscii = false;\n\n  if (typeof countOrCharactersOrOptions === 'number') {\n    count = countOrCharactersOrOptions;\n  } else if (countOrCharactersOrOptions) {\n    if (typeof countOrCharactersOrOptions === 'object') {\n      ({ count = count, characters = characters, escapeNonAscii = escapeNonAscii } = countOrCharactersOrOptions);\n    } else {\n      characters = countOrCharactersOrOptions;\n    }\n  }\n\n  const rx = new RegExp(`[${characters.replace(/[\\]\\\\^]/g, '\\\\$&')}]`, 'g');\n\n  for (let i = Math.max(1, count >> 0); i > 0; --i) {\n    str = str.replace(rx, char => {\n      const escape = CHAR_TO_ESCAPE.get(char);\n\n      if (escape) {\n        return escape;\n      }\n\n      const charCode = char.charCodeAt(0);\n\n      if (charCode >= 0xd800 && charCode <= 0xf8ff) {\n        const hex = charCode.toString(16);\n        return `\\\\u${hex}`;\n      } else if (escapeNonAscii && charCode > 0x7f) {\n        let hex = charCode.toString(16);\n\n        if (charCode <= 0xff) {\n          return `\\\\x${hex}`;\n        } else {\n          while (hex.length < 4) hex = `0${hex}`;\n          return `\\\\u${hex}`;\n        }\n      }\n\n      return `\\\\${char}`;\n    });\n  }\n\n  return str;\n}\n\n/**\n * @deprecated Use `addSlashes()` instead.\n *\n * Maintains the legacy behavior of only adding slashes to newlines (`\"\\n\"`),\n * carriage returns (`\"\\r\"`), nulls (`\"\\0\"`), single quotes (`\"'\"`), double\n * quotes (`\"\\\"\"`), and backslashes (`\"\\\\\"`).\n */\nexport const add = (str: string, count?: number): string => {\n  deprecated('The add() function is deprecated and should be replaced with addSlashes().');\n  return addSlashes(str, count, `\\n\\0'\"\\\\`);\n};\n"],"file":"addSlashes.js"}