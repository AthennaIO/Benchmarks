"use strict";
/*
 * @poppinss/utils
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Spinner = void 0;
/**
 * The most simplest spinner to log message with a progress indicator
 */
class Spinner {
    constructor(text, logger, testing = false) {
        this.text = text;
        this.logger = logger;
        this.testing = testing;
        /**
         * Frames to loop over
         */
        this.frames = ['.  ', '.. ', '...', ' ..', '  .', '   '];
        /**
         * Animation duration
         */
        this.interval = 200;
        /**
         * The state of the spinner
         */
        this.state = 'idle';
        /**
         * The current index for the frames
         */
        this.currentIndex = 0;
        /**
         * Builds the message to the print from the text
         */
        this.messageBuilder = {
            render(text) {
                if (this.prefix) {
                    text = `[${this.prefix}] ${text}`;
                }
                if (this.suffix) {
                    text = `${text} ${this.suffix}`;
                }
                return text;
            },
        };
    }
    /**
     * Increment index. Also, handles the index overflow
     */
    incrementIndex() {
        this.currentIndex = this.frames.length === this.currentIndex + 1 ? 0 : this.currentIndex + 1;
    }
    /**
     * Loop over the message and animate the spinner
     */
    loop() {
        if (this.state !== 'running') {
            return;
        }
        /**
         * Print the message as it is in testing mode or when the TTY is
         * not interactive
         */
        if (this.testing || !this.logger.options.interactive) {
            this.logger.logUpdate(`${this.messageBuilder.render(this.text)} ${this.frames[2]}`);
            return;
        }
        /**
         * Otherwise log the current frame and re-run the function
         * with some delay
         */
        const frame = this.frames[this.currentIndex];
        this.logger.logUpdate(`${this.messageBuilder.render(this.text)} ${frame}`);
        setTimeout(() => {
            this.incrementIndex();
            this.loop();
        }, this.interval);
    }
    /**
     * Star the spinner
     */
    start() {
        this.state = 'running';
        this.loop();
        return this;
    }
    /**
     * Define a custom message builder
     */
    useMessageBuilder(messageBuilder) {
        this.messageBuilder = messageBuilder;
        return this;
    }
    /**
     * Update spinner
     */
    update(text, prefix, suffix) {
        if (this.state !== 'running') {
            return this;
        }
        this.text = text;
        if (prefix !== undefined) {
            this.messageBuilder.prefix = prefix;
        }
        if (suffix !== undefined) {
            this.messageBuilder.suffix = suffix;
        }
        /**
         * Print the message as it is in testing mode or when the TTY is
         * not interactive
         */
        if (this.testing || !this.logger.options.interactive) {
            this.logger.logUpdate(`${this.messageBuilder.render(this.text)} ${this.frames[2]}`);
            return this;
        }
        return this;
    }
    /**
     * Stop spinner
     */
    stop() {
        this.state = 'stopped';
        this.currentIndex = 0;
        this.logger.logUpdatePersist();
    }
}
exports.Spinner = Spinner;
